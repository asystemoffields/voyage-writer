<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Voyage Writer</title>
<style>
/* ═══════════════════════════════════════════
   VOYAGE WRITER — CSS
   ═══════════════════════════════════════════ */

@import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,600;1,300;1,400&family=JetBrains+Mono:wght@300;400&family=Poiret+One&display=swap');

:root {
  --hud-font: 'Poiret One', 'Didot', serif;
  --editor-font: 'Cormorant Garamond', 'Georgia', serif;
  --mono-font: 'JetBrains Mono', monospace;
  --frost-opacity: 0.78;
  --frost-blur: 28px;
  --frost-r: 15;
  --frost-g: 15;
  --frost-b: 25;
  --text-color: #e8e4df;
  --text-shadow: 0 1px 3px rgba(0,0,0,0.5);
  --hud-color: rgba(200,210,220,0.7);
  --hud-glow: rgba(200,210,220,0.15);
  --sky-top: #0a0a14;
  --sky-bottom: #0f0f1a;
  --star-color: #e0d8c8;
  --accent: rgba(140,160,200,0.6);
  --accent-glow: rgba(140,160,200,0.04);
  --day-progress: 0.5;
}

* { margin:0; padding:0; box-sizing:border-box; }

html, body {
  width:100%; height:100%;
  overflow:hidden;
  background:#000;
  color: var(--text-color);
  font-family: var(--editor-font);
  cursor: crosshair;
  user-select: none;
}

/* ── Canvas & Layers ── */
#starfield {
  position:fixed; top:0; left:0;
  width:100%; height:100%;
  z-index:1;
}

/* Three.js 3D Landscape Canvas */
#landscape-3d {
  position:fixed; top:0; left:0;
  width:100%; height:100%;
  z-index:2;
  opacity:0;
  transition: opacity 1.5s ease;
  pointer-events:none;
}
#landscape-3d.visible { opacity:1; }

#landscape-layer {
  position:fixed; top:0; left:0;
  width:100%; height:100%;
  z-index:3;
  opacity:0;
  transition: opacity 1.5s ease;
  pointer-events:none;
  overflow:hidden;
}

/* When 3D is active, CSS layer is hidden */
body.webgl-active #landscape-layer { opacity:0 !important; display:none; }

#landscape-layer.visible { opacity:1; }

/* Landscape sub-layers */
.land-sky {
  position:absolute; top:0; left:0; width:100%; height:100%;
  transition: background 8s ease;
}
.land-celestial {
  position:absolute; top:0; left:0; width:100%; height:100%;
}
.land-far {
  position:absolute; bottom:0; left:0; width:100%; height:45%;
}
.land-mid {
  position:absolute; bottom:0; left:0; width:100%; height:30%;
}
.land-near {
  position:absolute; bottom:0; left:0; width:100%; height:15%;
}
.land-atmosphere {
  position:absolute; top:0; left:0; width:100%; height:100%;
  pointer-events:none;
}

/* Additional landscape layers */
.land-far2 {
  position:absolute; bottom:0; left:0; width:100%; height:38%;
}
.land-foreground {
  position:absolute; bottom:0; left:0; width:100%; height:18%;
  pointer-events:none;
}
.land-weather {
  position:absolute; top:0; left:0; width:100%; height:100%;
  pointer-events:none;
  overflow:hidden;
}

/* Surface texture overlays */
.surface-texture {
  position:absolute; top:0; left:0; width:100%; height:100%;
  pointer-events:none;
  opacity:0.12;
  mix-blend-mode:overlay;
}

/* ── System View ── */
#system-view {
  position:fixed; top:0; left:0;
  width:100%; height:100%;
  z-index:5;
  display:none;
  opacity:0;
  transition: opacity 1s ease;
}
#system-view.visible { opacity:1; }
#system-canvas {
  width:100%; height:100%;
}

/* ── Editor ── */
#editor-scrim {
  position:fixed; top:0; left:0;
  width:100%; height:100%;
  z-index:9;
  background: rgba(0,0,0,0);
  pointer-events:none;
  transition: background 1.2s ease;
}
#editor-scrim.visible {
  background: rgba(0,0,0,0.35);
}
body.focus-mode #editor-scrim.visible {
  background: rgba(0,0,0,0.6);
}

#editor-layer {
  position:fixed; top:0; left:0;
  width:100%; height:100%;
  z-index:10;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  opacity:0;
  transition: opacity 0.8s ease;
  pointer-events:none;
}
#editor-layer.visible {
  opacity:1;
  pointer-events:auto;
}

#frost-panel {
  position:relative;
  width: min(820px, 88vw);
  height: 72vh;
  border-radius: 6px;
  overflow:hidden;
  z-index: 0; /* establish stacking context */
}

/* Solid backing layer — guarantees 3D scene never shows sharp objects through editor */
#frost-panel::before {
  content:'';
  position:absolute; top:0; left:0;
  width:100%; height:100%;
  border-radius: 6px;
  background: rgb(var(--frost-r), var(--frost-g), var(--frost-b));
  opacity: calc(var(--frost-opacity) * 0.7);
  z-index:-1;
  transition: opacity 2s ease;
  pointer-events:none;
}

/* Inner accent vignette — picks up world palette */
#frost-panel::after {
  content:'';
  position:absolute; top:0; left:0;
  width:100%; height:100%;
  border-radius: 6px;
  box-shadow: inset 0 0 80px var(--accent-glow);
  pointer-events:none;
  z-index:1;
  transition: box-shadow 3s ease;
}

#frost-bg {
  position:absolute; top:0; left:0;
  width:100%; height:100%;
  background: rgba(var(--frost-r), var(--frost-g), var(--frost-b), var(--frost-opacity));
  backdrop-filter: blur(var(--frost-blur));
  -webkit-backdrop-filter: blur(var(--frost-blur));
  border: 1px solid rgba(200,210,220,0.06);
  border-top: 1px solid rgba(200,210,220,0.1);
  border-radius: 6px;
  transition: background 2s ease, border-color 2s ease, box-shadow 2s ease;
  box-shadow:
    inset 0 0 150px rgba(var(--frost-r), var(--frost-g), var(--frost-b), 0.5),
    inset 0 0 60px rgba(var(--frost-r), var(--frost-g), var(--frost-b), 0.3),
    inset 0 1px 0 rgba(255,255,255,0.07),
    inset 0 -1px 0 rgba(0,0,0,0.2),
    0 0 60px rgba(var(--frost-r), var(--frost-g), var(--frost-b), 0.12),
    0 12px 48px rgba(0,0,0,0.5),
    0 2px 8px rgba(0,0,0,0.3);
}

/* Subtle animated luminance along top edge */
#frost-bg::before {
  content:'';
  position:absolute; top:0; left:10%; right:10%;
  height:1px;
  background: linear-gradient(90deg, transparent, rgba(200,210,220,0.15), rgba(200,210,220,0.25), rgba(200,210,220,0.15), transparent);
  animation: edgeLuminance 8s ease-in-out infinite;
}
#frost-bg::after {
  content:'';
  position:absolute; bottom:0; left:15%; right:15%;
  height:1px;
  background: linear-gradient(90deg, transparent, rgba(200,210,220,0.08), rgba(200,210,220,0.12), rgba(200,210,220,0.08), transparent);
  animation: edgeLuminance 8s ease-in-out infinite reverse;
}
@keyframes edgeLuminance {
  0%, 100% { opacity:0.3; left:10%; right:10%; }
  50% { opacity:1; left:5%; right:5%; }
}

#editor-textarea {
  position:relative;
  width:100%; height:100%;
  padding: 44px 52px;
  background:transparent;
  border:none;
  outline:none;
  resize:none;
  color: var(--text-color);
  font-family: var(--editor-font);
  font-size: 19px;
  line-height: 1.8;
  letter-spacing: 0.015em;
  word-spacing: 0.04em;
  text-shadow: var(--text-shadow);
  caret-color: var(--accent);
  user-select: text;
  cursor: text;
  z-index:2;
}
#editor-textarea::placeholder {
  color: rgba(200,210,220,0.2);
  font-style: italic;
  letter-spacing: 0.08em;
}
#editor-textarea::selection {
  background: rgba(140,160,200,0.25);
  color: inherit;
}
#editor-textarea::-webkit-scrollbar { width:5px; }
#editor-textarea::-webkit-scrollbar-track { background:transparent; margin:20px 0; }
#editor-textarea::-webkit-scrollbar-thumb { background: rgba(200,210,220,0.12); border-radius:3px; }
#editor-textarea::-webkit-scrollbar-thumb:hover { background: rgba(200,210,220,0.22); }

/* ── HUD ── */
#hud {
  position:fixed; top:0; left:0;
  width:100%; height:100%;
  z-index:20;
  pointer-events:none;
  font-family: var(--hud-font);
  color: var(--hud-color);
  text-transform: uppercase;
  letter-spacing: 0.15em;
  font-size: 13px;
}

#hud * { pointer-events:auto; }

.hud-top {
  position:absolute; top:0; left:0; right:0;
  height:48px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding: 0 24px;
  background: linear-gradient(to bottom, rgba(0,0,0,0.4) 0%, transparent 100%);
}
.hud-top-left, .hud-top-center, .hud-top-right {
  display:flex; align-items:center; gap:16px;
}

.hud-bottom {
  position:absolute; bottom:0; left:0; right:0;
  height:48px;
  display:flex;
  align-items:center;
  justify-content:center;
  padding: 0 24px;
  background: linear-gradient(to top, rgba(0,0,0,0.4) 0%, transparent 100%);
  gap:20px;
}

.hud-btn {
  background:none; border:1px solid rgba(200,210,220,0.15);
  color: var(--hud-color);
  font-family: var(--hud-font);
  font-size:12px;
  letter-spacing:0.15em;
  text-transform:uppercase;
  padding:6px 14px;
  border-radius:2px;
  cursor:pointer;
  transition: all 0.3s;
}
.hud-btn:hover {
  border-color: rgba(200,210,220,0.4);
  background: rgba(200,210,220,0.06);
  text-shadow: 0 0 10px rgba(200,210,220,0.3);
}

.hud-label {
  opacity:0.6;
  font-size:11px;
}

#scanner-readout {
  position:fixed;
  bottom:70px; left:50%;
  transform:translateX(-50%);
  z-index:22;
  font-family: var(--mono-font);
  font-size:13px;
  color: rgba(200,210,220,0.7);
  text-align:center;
  pointer-events:none;
  transition: opacity 0.5s;
  max-width:550px;
  line-height:1.6;
  max-height: 60vh;
  overflow-y: hidden;
}

/* ── HUD Frame (landed) ── */
.hud-frame {
  position:fixed; top:0; left:0;
  width:100%; height:100%;
  z-index:15;
  pointer-events:none;
  border: 2px solid rgba(200,210,220,0.04);
  border-radius:2px;
  box-shadow: inset 0 0 60px rgba(0,0,0,0.5);
  opacity:0;
  transition: opacity 1s;
}
.hud-frame.visible { opacity:1; }

/* ── Naming Modal ── */
#naming-modal {
  position:fixed; top:0; left:0;
  width:100%; height:100%;
  z-index:50;
  display:none;
  align-items:center;
  justify-content:center;
  flex-direction:column;
  background: rgba(0,0,0,0.6);
  backdrop-filter: blur(8px);
  gap:20px;
}
#naming-modal.visible { display:flex; }

#naming-input {
  background:transparent;
  border:none;
  border-bottom: 1px solid rgba(200,210,220,0.25);
  color: var(--text-color);
  font-family: var(--hud-font);
  font-size:28px;
  letter-spacing:0.15em;
  text-transform:uppercase;
  text-align:center;
  padding:10px 20px;
  outline:none;
  width:400px;
  caret-color: var(--accent);
}
#naming-input::placeholder {
  color: rgba(200,210,220,0.2);
}

/* ── Font Modal ── */
#font-modal {
  position:fixed; top:0; left:0;
  width:100%; height:100%;
  z-index:50;
  display:none;
  align-items:center;
  justify-content:center;
  flex-direction:column;
  background: rgba(0,0,0,0.6);
  backdrop-filter: blur(8px);
  gap:16px;
}
#font-modal.visible { display:flex; }

#font-select {
  background: rgba(20,20,30,0.8);
  border: 1px solid rgba(200,210,220,0.2);
  color: var(--text-color);
  font-family: var(--hud-font);
  font-size: 16px;
  padding: 10px 20px;
  border-radius: 3px;
  outline: none;
  cursor: pointer;
  min-width: 280px;
}
#font-select:focus {
  border-color: rgba(200,210,220,0.4);
}
#font-select option {
  background: #0a0a14;
  color: var(--text-color);
  padding: 8px;
}

.font-size-control {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-top: 8px;
}
#font-size-slider {
  -webkit-appearance: none;
  appearance: none;
  width: 150px;
  height: 4px;
  background: rgba(200,210,220,0.15);
  border-radius: 2px;
  outline: none;
}
#font-size-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 14px;
  height: 14px;
  border-radius: 50%;
  background: rgba(200,210,220,0.6);
  cursor: pointer;
}
.naming-hint {
  font-family: var(--mono-font);
  font-size:11px;
  color: rgba(200,210,220,0.3);
  letter-spacing:0.05em;
}

/* ── Logbook ── */
#logbook {
  position:fixed; top:0; left:0;
  width:100%; height:100%;
  z-index:40;
  display:none;
  background: rgba(5,5,12,0.92);
  backdrop-filter: blur(20px);
}
#logbook.visible { display:flex; }

#logbook-canvas {
  width:100%; height:100%;
  cursor:pointer;
}

#logbook-sidebar {
  position:absolute; right:0; top:0;
  width:320px; height:100%;
  background: rgba(10,10,20,0.8);
  border-left:1px solid rgba(200,210,220,0.06);
  padding:40px 24px;
  overflow-y:auto;
  font-family: var(--editor-font);
}

.logbook-title {
  font-family: var(--hud-font);
  font-size:18px;
  letter-spacing:0.2em;
  text-transform:uppercase;
  color: var(--hud-color);
  margin-bottom:24px;
}

.logbook-entry {
  padding:12px 0;
  border-bottom:1px solid rgba(200,210,220,0.06);
  cursor:pointer;
  transition: background 0.2s;
}
.logbook-entry:hover {
  background: rgba(200,210,220,0.03);
}
.logbook-entry-name {
  font-size:15px;
  color: var(--text-color);
  margin-bottom:4px;
}
.logbook-entry-type {
  font-family: var(--mono-font);
  font-size:10px;
  color: rgba(200,210,220,0.4);
  letter-spacing:0.05em;
}
.logbook-entry-swatch {
  display:inline-block;
  width:8px; height:8px;
  border-radius:50%;
  margin-right:6px;
  vertical-align:middle;
}

/* ── Opacity Slider ── */
#opacity-control {
  position:fixed;
  right:24px;
  top:50%;
  transform:translateY(-50%);
  z-index:25;
  display:none;
  flex-direction:column;
  align-items:center;
  gap:8px;
}
#opacity-control.visible { display:flex; }

#opacity-slider {
  -webkit-appearance:none;
  appearance:none;
  width:4px;
  height:120px;
  background: rgba(200,210,220,0.1);
  outline:none;
  writing-mode:vertical-lr;
  direction:rtl;
  border-radius:2px;
}
#opacity-slider::-webkit-slider-thumb {
  -webkit-appearance:none;
  appearance:none;
  width:12px; height:12px;
  border-radius:50%;
  background: rgba(200,210,220,0.5);
  border:1px solid rgba(200,210,220,0.2);
  cursor:pointer;
}

/* ── Focus Mode ── */
body.focus-mode #hud { opacity:0; transition:opacity 1.5s; }
body.focus-mode .hud-frame { border-color:transparent; box-shadow:none; }
body.focus-mode #opacity-control { opacity:0; }
body.focus-mode #frost-bg {
  background: rgba(var(--frost-r), var(--frost-g), var(--frost-b), 0.97);
  backdrop-filter: blur(44px);
  -webkit-backdrop-filter: blur(44px);
  box-shadow:
    inset 0 0 150px rgba(var(--frost-r), var(--frost-g), var(--frost-b), 0.5),
    inset 0 0 60px rgba(var(--frost-r), var(--frost-g), var(--frost-b), 0.3),
    inset 0 1px 0 rgba(255,255,255,0.05),
    0 0 80px rgba(var(--frost-r), var(--frost-g), var(--frost-b), 0.08),
    0 16px 64px rgba(0,0,0,0.6);
}
body.focus-mode #frost-panel::before {
  opacity: 0.85;
}
body.focus-mode #frost-panel {
  width: 94vw;
  height: 90vh;
  max-width: none;
  transition: width 0.8s ease, height 0.8s ease;
}
body.focus-mode #editor-textarea {
  padding: 64px 88px;
  font-size: 20px;
}

/* Ensure smooth transitions out of focus mode too */
#frost-panel {
  transition: width 0.8s ease, height 0.8s ease;
}
#editor-textarea {
  transition: padding 0.8s ease;
}

/* ── Transitions ── */
.cinematic-fade {
  animation: cinematicFade 2s ease forwards;
}
@keyframes cinematicFade {
  0% { opacity:0; }
  100% { opacity:1; }
}

/* Landing descent */
#landscape-layer.landing-in,
#landscape-3d.landing-in {
  animation: landingDescent 2s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
}
@keyframes landingDescent {
  0% { opacity:0; transform: scale(0.3) translateY(-30%); filter: blur(6px); }
  40% { opacity:0.6; filter: blur(2px); }
  100% { opacity:1; transform: scale(1) translateY(0); filter: blur(0); }
}

/* Launch ascent */
#landscape-layer.launching,
#landscape-3d.launching {
  animation: launchAscent 1.2s cubic-bezier(0.55, 0, 1, 0.45) forwards;
}
@keyframes launchAscent {
  0% { opacity:1; transform: scale(1) translateY(0); filter: blur(0); }
  60% { opacity:0.5; filter: blur(3px); }
  100% { opacity:0; transform: scale(0.4) translateY(40%); filter: blur(8px); }
}

/* Editor slide-in on landing */
#editor-layer.landing-in {
  animation: editorArrive 1s ease 1.5s both;
}
@keyframes editorArrive {
  0% { opacity:0; transform: translateY(20px); }
  100% { opacity:1; transform: translateY(0); }
}

/* ── Scanner typing effect ── */
.scanner-line {
  display:block;
  opacity:0;
  animation: scanReveal 0.5s ease forwards;
}
@keyframes scanReveal {
  from { opacity:0; transform:translateY(4px); }
  to { opacity:1; transform:translateY(0); }
}

/* ── Stars CSS effects ── */
.star-label {
  position:absolute;
  font-family: var(--mono-font);
  font-size:10px;
  color: rgba(200,210,220,0.35);
  white-space:nowrap;
  pointer-events:none;
  letter-spacing:0.05em;
}

/* ── System view planet markers ── */
.system-body {
  position:absolute;
  border-radius:50%;
  cursor:pointer;
  transition: box-shadow 0.3s, transform 0.3s;
}
.system-body:hover {
  box-shadow: 0 0 20px rgba(200,210,220,0.3);
  transform:scale(1.15);
}
.system-body-label {
  position:absolute;
  top:100%;
  left:50%;
  transform:translateX(-50%);
  margin-top:8px;
  font-family: var(--mono-font);
  font-size:10px;
  color: rgba(200,210,220,0.45);
  white-space:nowrap;
  text-align:center;
}

/* ── Atmosphere particles ── */
@keyframes drift-left {
  from { transform:translateX(100vw); }
  to { transform:translateX(-200px); }
}
@keyframes fall-down {
  from { transform:translateY(-20px); opacity:0.7; }
  to { transform:translateY(100vh); opacity:0; }
}
@keyframes shimmer {
  0%,100% { opacity:0.3; }
  50% { opacity:0.8; }
}
@keyframes aurora {
  0% { transform:translateX(0) scaleY(1); opacity:0.15; }
  25% { transform:translateX(-3%) scaleY(1.15); opacity:0.3; }
  50% { transform:translateX(-6%) scaleY(1.3); opacity:0.35; }
  75% { transform:translateX(-3%) scaleY(1.1); opacity:0.25; }
  100% { transform:translateX(0) scaleY(1); opacity:0.15; }
}

@keyframes wave-bob {
  0%,100% { transform:translateY(0); }
  50% { transform:translateY(-6px); }
}
@keyframes wave-bob2 {
  0%,100% { transform:translateY(0); }
  50% { transform:translateY(-4px); }
}
@keyframes wave-bob3 {
  0%,100% { transform:translateY(0); }
  50% { transform:translateY(-8px); }
}
@keyframes fog-drift {
  0% { transform:translateX(-30%); opacity:0.06; }
  50% { opacity:0.1; }
  100% { transform:translateX(30%); opacity:0.06; }
}
@keyframes shooting-star {
  0% { opacity:0; transform:translateX(0) translateY(0); }
  10% { opacity:0.7; }
  90% { opacity:0.7; }
  100% { opacity:0; transform:translateX(200px) translateY(150px); }
}
@keyframes gas-band-drift {
  0% { transform:translateX(0); }
  100% { transform:translateX(-15px); }
}
@keyframes pulse-glow {
  0%,100% { opacity:0.15; }
  50% { opacity:0.35; }
}
@keyframes heat-shimmer {
  0%,100% { transform:scaleY(1); }
  50% { transform:scaleY(1.003); }
}
@keyframes spore-rise {
  0% { transform:translateY(0) translateX(0); opacity:0; }
  15% { opacity:0.5; }
  85% { opacity:0.4; }
  100% { transform:translateY(-120px) translateX(20px); opacity:0; }
}
@keyframes lava-pulse {
  0%,100% { opacity:0.6; filter:blur(2px) brightness(1); }
  50% { opacity:0.9; filter:blur(3px) brightness(1.3); }
}
@keyframes eruption-drift {
  0% { transform:translateY(0) scale(1); opacity:0.25; }
  40% { opacity:0.4; }
  100% { transform:translateY(-40px) scale(1.3); opacity:0; }
}

.cloud {
  position:absolute;
  border-radius:50%;
  filter: blur(30px);
  opacity:0.15;
  animation: drift-left linear infinite;
}
.particle-fall {
  position:absolute;
  width:1px;
  border-radius:50%;
  animation: fall-down linear infinite;
}

/* ── Nebula bg ── */
.nebula-bg {
  position:fixed; top:0; left:0;
  width:100%; height:100%;
  z-index:0;
  opacity:0;
  transition: opacity 3s;
  pointer-events:none;
}
.nebula-bg.visible { opacity:1; }

/* ── File Status ── */
#hud-file {
  display:inline-flex;
  align-items:center;
  gap:6px;
  font-family: var(--mono-font);
  font-size:10px;
  opacity:0.5;
  letter-spacing:0.05em;
}
#hud-file .dirty-dot {
  width:5px; height:5px;
  border-radius:50%;
  background: rgba(255,180,100,0.8);
  opacity:0;
  transition: opacity 0.3s;
}
#hud-file .dirty-dot.visible { opacity:1; }

.save-flash {
  position:fixed;
  z-index:21;
  font-family: var(--mono-font);
  font-size:10px;
  color: rgba(200,210,220,0.5);
  letter-spacing:0.08em;
  pointer-events:none;
  opacity:0;
  transition: opacity 0.3s;
  bottom:52px;
  left:50%;
  transform:translateX(-50%);
  white-space:nowrap;
}
.save-flash.show {
  animation: saveFlashAnim 2s ease forwards;
}
@keyframes saveFlashAnim {
  0% { opacity:0; }
  15% { opacity:0.6; }
  70% { opacity:0.6; }
  100% { opacity:0; }
}

/* ── Recovery Modal ── */
#recovery-modal {
  position:fixed; top:0; left:0;
  width:100%; height:100%;
  z-index:60;
  display:none;
  align-items:center;
  justify-content:center;
  flex-direction:column;
  background: rgba(0,0,0,0.7);
  backdrop-filter: blur(10px);
  gap:16px;
}
#recovery-modal.visible { display:flex; }
.recovery-preview {
  max-width:500px;
  max-height:120px;
  overflow:hidden;
  font-family: var(--editor-font);
  font-size:15px;
  color: rgba(200,210,220,0.5);
  font-style:italic;
  line-height:1.6;
  text-align:center;
  padding:12px 20px;
  border:1px solid rgba(200,210,220,0.08);
  border-radius:3px;
  background: rgba(200,210,220,0.02);
}
.recovery-meta {
  font-family: var(--mono-font);
  font-size:10px;
  color: rgba(200,210,220,0.3);
  letter-spacing:0.05em;
}
.recovery-actions {
  display:flex; gap:12px; margin-top:8px;
}
</style>
</head>
<body>

<!-- Nebula background -->
<div class="nebula-bg" id="nebula-bg"></div>

<!-- Starfield canvas -->
<canvas id="starfield"></canvas>

<!-- Three.js 3D Landscape Canvas -->
<canvas id="landscape-3d"></canvas>

<!-- CSS Landscape layers (fallback) -->
<div id="landscape-layer">
  <div class="land-sky"></div>
  <div class="land-celestial"></div>
  <div class="land-far"></div>
  <div class="land-far2"></div>
  <div class="land-mid"></div>
  <div class="land-near"></div>
  <div class="land-foreground"></div>
  <div class="land-atmosphere"></div>
  <div class="land-weather"></div>
</div>

<!-- System view -->
<div id="system-view">
  <canvas id="system-canvas"></canvas>
</div>

<!-- HUD frame -->
<div class="hud-frame" id="hud-frame"></div>

<!-- Editor scrim (dims landscape behind editor) -->
<div id="editor-scrim"></div>

<!-- Editor -->
<div id="editor-layer">
  <div id="frost-panel">
    <div id="frost-bg"></div>
    <textarea id="editor-textarea" placeholder="Begin writing..." spellcheck="false"></textarea>
  </div>
</div>

<!-- HUD -->
<div id="hud">
  <div class="hud-top">
    <div class="hud-top-left">
      <span id="hud-location">Deep Space</span>
    </div>
    <div class="hud-top-center">
      <span id="hud-file"><span id="hud-filename"></span><span class="dirty-dot" id="dirty-dot"></span></span>
      <span id="hud-wordcount" class="hud-label">0 words</span>
    </div>
    <div class="hud-top-right">
      <span id="hud-coords" class="hud-label"></span>
    </div>
  </div>
  <div class="hud-bottom">
    <button class="hud-btn" id="btn-fullscreen" title="Fullscreen [F11]">⛶</button>
    <button class="hud-btn" id="btn-logbook" title="Logbook [L]">Logbook</button>
    <button class="hud-btn" id="btn-focus" title="Focus [F]" style="display:none">Focus</button>
    <button class="hud-btn" id="btn-textcolor" title="Text Color [T]" style="display:none">Text: Light</button>
    <button class="hud-btn" id="btn-font" title="Font" style="display:none">Font</button>
    <button class="hud-btn" id="btn-spellcheck" title="Spellcheck [K]" style="display:none">Spell: Off</button>
    <button class="hud-btn" id="btn-daynight" title="Day/Night [N]" style="display:none">☀</button>
    <button class="hud-btn" id="btn-launch" title="Launch [Esc]" style="display:none">Launch</button>
    <button class="hud-btn" id="btn-new" title="New [Ctrl+N]">New</button>
    <button class="hud-btn" id="btn-save" title="Save [Ctrl+S]">Save</button>
    <button class="hud-btn" id="btn-saveas" title="Save As [Ctrl+Shift+S]">Save As</button>
    <button class="hud-btn" id="btn-open" title="Open [Ctrl+O]">Open</button>
  </div>
</div>

<!-- Scanner readout -->
<div id="scanner-readout"></div>

<!-- Save flash indicator -->
<div class="save-flash" id="save-flash">saved</div>

<!-- Recovery modal -->
<div id="recovery-modal">
  <div class="naming-hint">transmission recovered</div>
  <div class="recovery-preview" id="recovery-preview"></div>
  <div class="recovery-meta" id="recovery-meta"></div>
  <div class="recovery-actions">
    <button class="hud-btn" id="btn-recover">Restore</button>
    <button class="hud-btn" id="btn-discard">Discard</button>
  </div>
</div>

<!-- Opacity control -->
<div id="opacity-control">
  <input type="range" id="opacity-slider" min="0.35" max="1.0" step="0.01" value="0.78">
  <span class="hud-label" style="font-size:9px;">frost</span>
</div>

<!-- Naming modal -->
<div id="naming-modal">
  <div class="naming-hint">name this world</div>
  <input type="text" id="naming-input" placeholder="...">
  <div class="naming-hint">press enter to confirm · esc to skip</div>
</div>

<!-- Font modal -->
<div id="font-modal">
  <div class="naming-hint">editor font</div>
  <select id="font-select"></select>
  <div class="font-size-control">
    <label class="naming-hint">size</label>
    <input type="range" id="font-size-slider" min="14" max="32" step="1" value="19">
    <span id="font-size-display" class="naming-hint">19px</span>
  </div>
  <div class="naming-hint" style="margin-top:16px">press esc to close</div>
</div>

<!-- Logbook -->
<div id="logbook">
  <canvas id="logbook-canvas"></canvas>
  <div id="logbook-sidebar">
    <div class="logbook-title">Flight Log</div>
    <div id="logbook-entries"></div>
    <div style="margin-top:20px;padding-top:12px;border-top:1px solid rgba(200,210,220,0.08);text-align:center;">
      <button class="hud-btn" id="btn-reset-logbook" style="font-size:9px;letter-spacing:0.12em;opacity:0.5;padding:4px 12px;">Reset Logbook</button>
    </div>
  </div>
</div>

<!-- Three.js CDN with fallback -->
<script>
// Three.js loader with fallback
window.THREE_LOADED = false;
window.WEBGL_AVAILABLE = false;

function checkWebGL() {
  try {
    const canvas = document.createElement('canvas');
    return !!(window.WebGLRenderingContext && 
      (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
  } catch(e) {
    return false;
  }
}

window.WEBGL_AVAILABLE = checkWebGL();

if (window.WEBGL_AVAILABLE) {
  const script = document.createElement('script');
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
  script.onload = () => {
    window.THREE_LOADED = true;
    console.log('Three.js loaded successfully');
    if (window.initThreeJS) window.initThreeJS();
  };
  script.onerror = () => {
    console.warn('Three.js failed to load, using CSS fallback');
    window.THREE_LOADED = false;
  };
  document.head.appendChild(script);
}
</script>

<script>
/* ═══════════════════════════════════════════
   VOYAGE WRITER — JavaScript Engine
   ═══════════════════════════════════════════ */

// ─── Seeded PRNG (mulberry32) ───
function mulberry32(a) {
  return function() {
    a |= 0; a = a + 0x6D2B79F5 | 0;
    let t = Math.imul(a ^ a >>> 15, 1 | a);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

function hashCoords(x, y) {
  let h = 2166136261;
  h ^= x & 0xFFFF; h = Math.imul(h, 16777619);
  h ^= (x >> 16) & 0xFFFF; h = Math.imul(h, 16777619);
  h ^= y & 0xFFFF; h = Math.imul(h, 16777619);
  h ^= (y >> 16) & 0xFFFF; h = Math.imul(h, 16777619);
  return h >>> 0;
}

// ─── Simplex-like noise (2D) ───
const NOISE_PERM = new Uint8Array(512);
(function initNoise() {
  const p = [];
  for (let i = 0; i < 256; i++) p[i] = i;
  // Fisher-Yates with fixed seed
  let s = mulberry32(42);
  for (let i = 255; i > 0; i--) {
    const j = (s() * (i + 1)) | 0;
    [p[i], p[j]] = [p[j], p[i]];
  }
  for (let i = 0; i < 512; i++) NOISE_PERM[i] = p[i & 255];
})();

function noise2D(x, y) {
  const GRAD = [[1,1],[-1,1],[1,-1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]];
  const F2 = 0.5 * (Math.sqrt(3) - 1);
  const G2 = (3 - Math.sqrt(3)) / 6;
  const s = (x + y) * F2;
  const i = Math.floor(x + s), j = Math.floor(y + s);
  const t = (i + j) * G2;
  const X0 = i - t, Y0 = j - t;
  const x0 = x - X0, y0 = y - Y0;
  const i1 = x0 > y0 ? 1 : 0, j1 = x0 > y0 ? 0 : 1;
  const x1 = x0 - i1 + G2, y1 = y0 - j1 + G2;
  const x2 = x0 - 1 + 2 * G2, y2 = y0 - 1 + 2 * G2;
  const ii = i & 255, jj = j & 255;
  function dot(gi, xp, yp) { const g = GRAD[gi % 8]; return g[0]*xp + g[1]*yp; }
  const gi0 = NOISE_PERM[ii + NOISE_PERM[jj]] % 8;
  const gi1 = NOISE_PERM[ii + i1 + NOISE_PERM[jj + j1]] % 8;
  const gi2 = NOISE_PERM[ii + 1 + NOISE_PERM[jj + 1]] % 8;
  let n0 = 0, n1 = 0, n2 = 0;
  let t0 = 0.5 - x0*x0 - y0*y0;
  if (t0 > 0) { t0 *= t0; n0 = t0 * t0 * dot(gi0, x0, y0); }
  let t1 = 0.5 - x1*x1 - y1*y1;
  if (t1 > 0) { t1 *= t1; n1 = t1 * t1 * dot(gi1, x1, y1); }
  let t2 = 0.5 - x2*x2 - y2*y2;
  if (t2 > 0) { t2 *= t2; n2 = t2 * t2 * dot(gi2, x2, y2); }
  return 70 * (n0 + n1 + n2);
}

function fbm(x, y, octaves = 4) {
  let val = 0, amp = 1, freq = 1, max = 0;
  for (let i = 0; i < octaves; i++) {
    val += noise2D(x * freq, y * freq) * amp;
    max += amp;
    amp *= 0.5;
    freq *= 2;
  }
  return val / max;
}

// ─── CPU-side terrain height (mirrors the GLSL terrainHeight) ───
function smoothstepJS(edge0, edge1, x) {
  const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
  return t * t * (3 - 2 * t);
}

function computeTerrainHeight(px, py, style, scale, freq) {
  let h = 0;
  if (style === 0) {
    // Rolling hills
    h += fbm(px * 0.06 * freq, py * 0.06 * freq, 4) * 14.0 * scale;
    h += fbm(px * 0.015 * freq, py * 0.015 * freq, 3) * 22.0 * scale;
    h += noise2D(px * 0.25 * freq, py * 0.25 * freq) * 3.0 * scale;
  } else if (style === 1) {
    // Jagged peaks
    const ridge = fbm(px * 0.04 * freq, py * 0.04 * freq, 5) * 35.0 * scale;
    let sharp = Math.abs(noise2D(px * 0.12 * freq, py * 0.12 * freq));
    sharp = Math.pow(sharp, 0.6) * 20.0 * scale;
    h += ridge + sharp;
    const crater = noise2D(px * 0.025 * freq, py * 0.025 * freq);
    if (crater > 0.6) h -= (crater - 0.6) * 40.0 * scale;
  } else if (style === 2) {
    // Smooth dunes
    const d1 = Math.sin(px * 0.08 * freq + py * 0.03 * freq) * 8.0 * scale;
    const d2 = Math.sin(px * 0.04 * freq - py * 0.06 * freq + 2.0) * 12.0 * scale;
    const d3 = Math.sin(px * 0.15 * freq + py * 0.12 * freq - 1.0) * 3.0 * scale;
    const ripple = noise2D(px * 0.3 * freq, py * 0.3 * freq) * 1.5 * scale;
    h += d1 + d2 + d3 + ripple;
  } else if (style === 3) {
    // Crystal spires
    const base = fbm(px * 0.03 * freq, py * 0.03 * freq, 3) * 5.0 * scale;
    let spire = noise2D(px * 0.15 * freq, py * 0.15 * freq);
    spire = Math.max(0, spire - 0.3) * 3.33;
    spire = Math.pow(spire, 2.5) * 45.0 * scale;
    let mini = noise2D(px * 0.35 * freq, py * 0.35 * freq);
    mini = Math.max(0, mini - 0.4) * 2.5;
    mini = Math.pow(mini, 2.0) * 15.0 * scale;
    h += base + spire + mini;
  } else if (style === 4) {
    // Mesa / canyon
    const n = fbm(px * 0.04 * freq, py * 0.04 * freq, 4);
    const mesa = Math.floor(n * 4.0) / 4.0 * 28.0 * scale;
    const smooth = fbm(px * 0.04 * freq, py * 0.04 * freq, 4) * 28.0 * scale;
    h += mesa * 0.75 + smooth * 0.25;
    let canyon = Math.sin(px * 0.05 * freq + noise2D(px * 0.02, py * 0.02) * 3.0);
    canyon = smoothstepJS(0.0, 0.15, Math.abs(canyon));
    h *= canyon;
  } else if (style === 5) {
    // Bulbous — rounded mounds
    let mound = noise2D(px * 0.08 * freq, py * 0.08 * freq);
    mound = Math.max(0, mound) * mound * 30.0 * scale;
    let detail = noise2D(px * 0.2 * freq, py * 0.2 * freq);
    detail = Math.max(0, detail) * detail * 10.0 * scale;
    const base = fbm(px * 0.02 * freq, py * 0.02 * freq, 3) * 8.0 * scale;
    h += mound + detail + base;
  } else if (style === 6) {
    // Glacier
    let smooth = Math.sin(px * 0.03 * freq) * Math.cos(py * 0.02 * freq) * 12.0 * scale;
    smooth += fbm(px * 0.02 * freq, py * 0.02 * freq, 3) * 15.0 * scale;
    let ridge = noise2D(px * 0.06 * freq, py * 0.06 * freq);
    ridge = Math.pow(Math.max(0, ridge), 4.0) * 35.0 * scale;
    const crev = noise2D(px * 0.1 * freq + 5.0, py * 0.1 * freq + 3.0);
    const cut = smoothstepJS(0.02, 0.0, Math.abs(crev)) * 12.0 * scale;
    h += smooth + ridge - cut;
  } else if (style === 7) {
    // Terraced
    const n = fbm(px * 0.05 * freq, py * 0.05 * freq, 4) * 25.0 * scale;
    const stepSize = 5.0 * scale;
    h = Math.floor(n / stepSize) * stepSize;
    const wear = noise2D(px * 0.2 * freq, py * 0.2 * freq) * 2.0 * scale;
    h += wear;
    const structure = noise2D(px * 0.3 * freq, py * 0.3 * freq);
    if (structure > 0.65) h += 6.0 * scale;
  } else if (style === 8) {
    // Angular — faceted metallic ridges
    const f1 = noise2D(px * 0.06 * freq, py * 0.06 * freq);
    const f2 = noise2D(px * 0.12 * freq + 10.0, py * 0.12 * freq + 7.0);
    h += Math.abs(f1) * 22.0 * scale;
    h += Math.abs(f2) * 12.0 * scale;
    const ridge = Math.sin(px * 0.08 * freq + py * 0.04 * freq);
    h += Math.abs(ridge) * 10.0 * scale;

  // ─── NEW TERRAIN STYLES ───────────────────

  } else if (style === 9) {
    // Volcanic cones — shield volcanoes with calderas and lava channels
    // Base undulating lava field
    h += fbm(px * 0.025 * freq, py * 0.025 * freq, 3) * 8.0 * scale;
    // Volcanic cones: radial distance from scattered points creates cone shapes
    for (let ci = 0; ci < 5; ci++) {
      // Deterministic cone centers from noise
      const cx = noise2D(ci * 73.1, ci * 37.9) * 200;
      const cy = noise2D(ci * 51.3, ci * 19.7) * 100;
      const dist = Math.sqrt((px - cx) * (px - cx) + (py - cy) * (py - cy));
      const coneRadius = 25 + Math.abs(noise2D(ci * 11.1, ci * 22.2)) * 35;
      const coneHeight = (20 + Math.abs(noise2D(ci * 33.3, ci * 44.4)) * 25) * scale;
      // Cone shape: rises toward center, with caldera dip at very top
      let cone = Math.max(0, 1.0 - dist / coneRadius);
      cone = Math.pow(cone, 1.5) * coneHeight;
      // Caldera: dip at the very center
      const calderaDepth = coneHeight * 0.35;
      const calderaWidth = coneRadius * 0.2;
      if (dist < calderaWidth) {
        const calderaFactor = 1.0 - dist / calderaWidth;
        cone -= calderaDepth * calderaFactor * calderaFactor;
      }
      h += cone;
    }
    // Lava channels: sinuous low cuts between cones
    const lavaPath = Math.sin(px * 0.04 * freq + noise2D(px * 0.01, py * 0.01) * 6.0);
    const lavaChannel = smoothstepJS(0.08, 0.0, Math.abs(lavaPath)) * 8.0 * scale;
    h -= lavaChannel;
    // Rough volcanic texture
    h += Math.abs(noise2D(px * 0.15 * freq, py * 0.15 * freq)) * 4.0 * scale;

  } else if (style === 10) {
    // River valley — rolling green terrain with sinuous river channels
    // Base rolling hills
    h += fbm(px * 0.04 * freq, py * 0.04 * freq, 4) * 18.0 * scale;
    h += fbm(px * 0.012 * freq, py * 0.012 * freq, 3) * 25.0 * scale;
    h += noise2D(px * 0.15 * freq, py * 0.15 * freq) * 4.0 * scale;
    // Main river: sinuous path carving deep into terrain
    const riverWander = noise2D(py * 0.008 * freq, 0.5) * 80;
    const riverWander2 = noise2D(py * 0.02 * freq, 1.5) * 25;
    const riverCenter = riverWander + riverWander2;
    const riverDist = Math.abs(px - riverCenter);
    const riverWidth = 8 + noise2D(py * 0.015, 3.0) * 6;
    // Carve the river bed — smooth V shape with flat bottom
    const riverDepth = smoothstepJS(riverWidth * 2.5, riverWidth * 0.3, riverDist) * 18.0 * scale;
    h -= riverDepth;
    // River banks: slight ridge on either side
    const bankRidge = smoothstepJS(riverWidth * 3, riverWidth, riverDist) *
                      (1 - smoothstepJS(riverWidth, riverWidth * 0.5, riverDist)) * 4.0 * scale;
    h += bankRidge;
    // Tributary stream joining from the side
    const tribAngle = px * 0.03 + py * 0.05 + noise2D(px * 0.01, py * 0.01 + 10) * 3;
    const tribPath = Math.sin(tribAngle);
    const tribCut = smoothstepJS(0.12, 0.0, Math.abs(tribPath)) * 6.0 * scale;
    // Only carve tributary on one side
    if (px > riverCenter + 15) h -= tribCut * 0.6;

  } else if (style === 11) {
    // Island archipelago — terrain above and below sea level
    // Large-scale island masses
    const continent = fbm(px * 0.018 * freq, py * 0.018 * freq, 4) * 35.0 * scale;
    // Medium detail — individual islands
    const islands = fbm(px * 0.05 * freq, py * 0.05 * freq, 3) * 15.0 * scale;
    // Fine detail — beaches and rocky shores
    const detail = noise2D(px * 0.12 * freq, py * 0.12 * freq) * 5.0 * scale;
    // Combine with an offset that pushes ~40% below sea level
    h += continent + islands + detail - 14.0 * scale;
    // Volcanic island peaks — occasional sharp rises
    let peak = noise2D(px * 0.04 * freq + 5, py * 0.04 * freq + 5);
    peak = Math.max(0, peak - 0.5) * 2.0;
    h += Math.pow(peak, 2.0) * 20.0 * scale;
    // Sandbars / shallow areas — flatten near sea level
    if (h > -2 * scale && h < 2 * scale) {
      h *= 0.4; // Flatten the transition zone for shallow shelves
    }

  } else if (style === 12) {
    // Fjord / coastal cliffs — steep walls plunging to water
    // High plateau base
    h += 20.0 * scale;
    h += fbm(px * 0.03 * freq, py * 0.03 * freq, 3) * 12.0 * scale;
    // Fjord channels: deep sinuous cuts
    const fjord1 = Math.sin(px * 0.025 * freq + noise2D(py * 0.008, 0.0) * 8.0);
    const fjordCut1 = smoothstepJS(0.2, 0.0, Math.abs(fjord1));
    h -= fjordCut1 * 38.0 * scale;
    // Second narrower fjord at an angle
    const fjord2 = Math.sin(px * 0.02 * freq + py * 0.03 * freq + noise2D(px * 0.005, py * 0.005) * 5.0);
    const fjordCut2 = smoothstepJS(0.15, 0.0, Math.abs(fjord2));
    h -= fjordCut2 * 30.0 * scale;
    // Cliff face roughness
    h += Math.abs(noise2D(px * 0.1 * freq, py * 0.1 * freq)) * 4.0 * scale;
    // Scattered sea stacks in the water
    let stack = noise2D(px * 0.08 * freq + 20, py * 0.08 * freq + 20);
    stack = Math.max(0, stack - 0.65) * 2.86;
    h += Math.pow(stack, 3.0) * 18.0 * scale;

  } else if (style === 13) {
    // Caldera — massive volcanic crater with high rim and flat interior
    // Distance from center of plane
    const dx = px * 0.012 * freq;
    const dy = py * 0.012 * freq;
    const dist = Math.sqrt(dx * dx + dy * dy);
    // Rim: rises sharply then drops
    const rimRadius = 1.2;
    const rimWidth = 0.3;
    const rimHeight = 35.0 * scale;
    let rim = Math.exp(-Math.pow((dist - rimRadius) / rimWidth, 2)) * rimHeight;
    // Outer slopes
    const outerSlope = Math.max(0, 1 - (dist - rimRadius - rimWidth) * 0.8);
    h += Math.min(rim, rimHeight) + outerSlope * 8.0 * scale;
    // Interior floor: mostly flat with some rubble
    if (dist < rimRadius) {
      const interior = 3.0 * scale + fbm(px * 0.06 * freq, py * 0.06 * freq, 3) * 4.0 * scale;
      h = Math.max(h, interior);
      // Central lava dome
      const domeHeight = 12.0 * scale;
      const domeDist = dist / (rimRadius * 0.25);
      if (domeDist < 1) {
        h += domeHeight * (1 - domeDist * domeDist);
      }
    }
    // Erosion gullies on outer slopes
    const gully = Math.sin(Math.atan2(dy, dx) * 12 + noise2D(dx * 5, dy * 5) * 2);
    h -= smoothstepJS(0.3, 0.8, gully) * 3.0 * scale * Math.max(0, dist - rimRadius);
    // Surface roughness
    h += noise2D(px * 0.08 * freq, py * 0.08 * freq) * 2.5 * scale;

  } else if (style === 14) {
    // Stormy crags — chaotic, extreme terrain with dramatic peaks and gullies
    // Multi-scale chaos: lots of octaves, high amplitude
    h += fbm(px * 0.035 * freq, py * 0.035 * freq, 5) * 30.0 * scale;
    // Sharp ridgelines from absolute noise
    const ridge1 = Math.abs(noise2D(px * 0.05 * freq, py * 0.05 * freq));
    const ridge2 = Math.abs(noise2D(px * 0.08 * freq + 7, py * 0.08 * freq + 3));
    h += Math.pow(ridge1, 0.5) * 18.0 * scale;
    h += Math.pow(ridge2, 0.7) * 12.0 * scale;
    // Deep ravines: sudden cuts
    const ravine = noise2D(px * 0.06 * freq + 20, py * 0.04 * freq + 15);
    const ravineDepth = smoothstepJS(0.02, 0.0, Math.abs(ravine)) * 20.0 * scale;
    h -= ravineDepth;
    // Shattered peaks: sharp spiky overhangs
    let shatter = noise2D(px * 0.2 * freq, py * 0.2 * freq);
    shatter = Math.max(0, shatter - 0.4) * 1.67;
    h += Math.pow(shatter, 1.5) * 15.0 * scale;
    // Windswept lean — terrain leans in one direction
    h += Math.sin(px * 0.01 + py * 0.005) * 6.0 * scale;
    // Fine destruction detail
    h += noise2D(px * 0.3 * freq, py * 0.3 * freq) * 3.0 * scale;

  } else if (style === 15) {
    // Icefall cascade — stepped ice shelves with crevasses and seracs
    // Broad glacial flow: terrain descends from back to front (py direction)
    const glacierSlope = (py + 75) * 0.15 * scale; // rises toward the back
    h += glacierSlope;
    // Large ice shelves: quantized steps like a frozen waterfall
    const shelfNoise = fbm(px * 0.03 * freq, py * 0.025 * freq, 3) * 20.0 * scale;
    const shelfStep = 6.0 * scale;
    h += Math.floor(shelfNoise / shelfStep) * shelfStep;
    // Serac towers: jagged ice blocks on shelf edges
    const serac = noise2D(px * 0.12 * freq, py * 0.12 * freq);
    if (serac > 0.45) {
      h += Math.pow((serac - 0.45) * 1.82, 1.5) * 22.0 * scale;
    }
    // Deep crevasses: narrow vertical cuts
    const crev1 = Math.sin(px * 0.06 * freq + noise2D(px * 0.01 + 3, py * 0.01 + 3) * 4);
    h -= smoothstepJS(0.06, 0.0, Math.abs(crev1)) * 14.0 * scale;
    const crev2 = Math.sin(px * 0.04 * freq + py * 0.08 * freq + noise2D(px * 0.008 + 7, py * 0.008) * 5);
    h -= smoothstepJS(0.05, 0.0, Math.abs(crev2)) * 10.0 * scale;
    // Ice surface texture: slight ripples
    h += noise2D(px * 0.15 * freq, py * 0.15 * freq) * 1.5 * scale;
    // Smooth rounded ice on the shelves
    h += Math.max(0, Math.sin(px * 0.06 * freq) * Math.cos(py * 0.04 * freq)) * 4.0 * scale;

  } else if (style === 16) {
    // Pillar forest — tall narrow columns rising from a flat plain (Zhangjiajie-like)
    const base = fbm(px * 0.02 * freq, py * 0.02 * freq, 3) * 4.0 * scale;
    h += base;
    // Generate pillars from noise peaks
    const pillarNoise = noise2D(px * 0.1 * freq, py * 0.1 * freq);
    const pillarNoise2 = noise2D(px * 0.14 * freq + 5, py * 0.14 * freq + 5);
    // Hard threshold creates flat-topped pillars
    if (pillarNoise > 0.25) {
      const pillarHeight = Math.pow((pillarNoise - 0.25) / 0.75, 0.3) * 40.0 * scale;
      h += pillarHeight;
      // Flat top with slight variation
      h += noise2D(px * 0.3 * freq, py * 0.3 * freq) * 1.5 * scale;
    }
    if (pillarNoise2 > 0.3) {
      h += Math.pow((pillarNoise2 - 0.3) / 0.7, 0.4) * 28.0 * scale;
    }
    // Narrow bridges between pillars (rare)
    const bridge = Math.sin(px * 0.06 * freq + py * 0.02 * freq);
    if (Math.abs(bridge) < 0.05 && pillarNoise > 0.15 && pillarNoise2 > 0.2) {
      h = Math.max(h, 20.0 * scale);
    }
    // Erosion detail at pillar bases
    h += noise2D(px * 0.25 * freq, py * 0.25 * freq) * 2.0 * scale;

  } else if (style === 17) {
    // Sinkhole / karst — terrain riddled with deep circular depressions
    h += fbm(px * 0.03 * freq, py * 0.03 * freq, 4) * 18.0 * scale;
    h += 15.0 * scale; // Raise base so sinkholes go deep
    // Generate sinkholes at scattered points
    for (let si = 0; si < 7; si++) {
      const sx = noise2D(si * 47.3, si * 83.1) * 150;
      const sy = noise2D(si * 61.7, si * 29.3) * 80;
      const dist = Math.sqrt((px - sx) * (px - sx) + (py - sy) * (py - sy));
      const sinkRadius = 10 + Math.abs(noise2D(si * 13.7, si * 57.1)) * 20;
      const sinkDepth = (15 + Math.abs(noise2D(si * 71.3, si * 39.7)) * 25) * scale;
      if (dist < sinkRadius) {
        const t = dist / sinkRadius;
        // Steep walls with flat bottom
        const wallProfile = smoothstepJS(0.3, 0.9, t);
        h -= sinkDepth * (1.0 - wallProfile);
        // Rim lip — slight raised edge
        if (t > 0.85 && t < 1.0) {
          h += 3.0 * scale * (1.0 - Math.abs(t - 0.92) / 0.08);
        }
      }
    }
    // Surface dissolution texture — pitted and rough
    h += Math.abs(noise2D(px * 0.2 * freq, py * 0.2 * freq)) * 3.0 * scale;
    // Underground river hint: narrow slot
    const slot = Math.sin(px * 0.03 * freq + noise2D(py * 0.01, 5.0) * 5.0);
    h -= smoothstepJS(0.06, 0.0, Math.abs(slot)) * 10.0 * scale;

  } else if (style === 18) {
    // Tide pools / terraced shoreline — undulating terrain with shallow pooling basins
    // Gentle slope toward one side (ocean direction)
    const slope = (px + 100) * 0.06 * scale;
    h += slope;
    // Terraced rock shelves
    const shelfNoise = fbm(px * 0.04 * freq, py * 0.04 * freq, 3) * 16.0 * scale;
    const stepSize = 3.5 * scale;
    h += Math.floor(shelfNoise / stepSize) * stepSize;
    // Pool depressions — smooth bowls cut into shelves
    const poolNoise = noise2D(px * 0.08 * freq, py * 0.08 * freq);
    if (poolNoise < -0.1) {
      h -= Math.pow(Math.abs(poolNoise + 0.1), 0.8) * 8.0 * scale;
    }
    // Erosion channels between pools
    const channel = Math.sin(py * 0.05 * freq + noise2D(px * 0.02 + 3, py * 0.02 + 3) * 4.0);
    h -= smoothstepJS(0.08, 0.0, Math.abs(channel)) * 4.0 * scale;
    // Rock texture
    h += noise2D(px * 0.2 * freq, py * 0.2 * freq) * 1.5 * scale;

  } else if (style === 19) {
    // Badlands — deeply eroded layered terrain with narrow ridges and hoodoos
    // Layered strata base
    const strata = Math.sin(py * 0.04 * freq + fbm(px * 0.01, py * 0.01, 2) * 8.0) * 10.0 * scale;
    h += strata + 12.0 * scale;
    // Deep erosion gullies — multiple parallel cuts
    for (let gi = 0; gi < 4; gi++) {
      const gAngle = 0.03 + gi * 0.015;
      const gPhase = noise2D(gi * 33.0, gi * 77.0) * 10.0;
      const gully = Math.sin(px * gAngle * freq + gPhase + noise2D(py * 0.01, gi * 5.0) * 4.0);
      h -= smoothstepJS(0.12, 0.0, Math.abs(gully)) * (8.0 + gi * 3.0) * scale;
    }
    // Hoodoo columns — narrow remnants where erosion almost but didn't remove terrain
    let hoodoo = noise2D(px * 0.12 * freq + 10, py * 0.12 * freq + 10);
    hoodoo = Math.max(0, hoodoo - 0.5) * 2.0;
    h += Math.pow(hoodoo, 2.0) * 18.0 * scale;
    // Fine erosion texture
    h += fbm(px * 0.08 * freq, py * 0.08 * freq, 3) * 5.0 * scale;
    // Mud-crack pattern on flat areas
    h += Math.abs(noise2D(px * 0.25 * freq, py * 0.25 * freq)) * 1.5 * scale;

  } else if (style === 20) {
    // Floating mesa / anti-gravity — flat-topped chunks with vertical gaps
    // Large flat mesas
    const mesaNoise = fbm(px * 0.025 * freq, py * 0.025 * freq, 3);
    const mesaLevel1 = 15.0 * scale;
    const mesaLevel2 = 30.0 * scale;
    // Quantize to distinct levels
    if (mesaNoise > 0.3) {
      h += mesaLevel2;
      // Flat tops with minimal detail
      h += noise2D(px * 0.1 * freq, py * 0.1 * freq) * 2.0 * scale;
    } else if (mesaNoise > 0.0) {
      h += mesaLevel1;
      h += noise2D(px * 0.1 * freq, py * 0.1 * freq) * 2.0 * scale;
    } else {
      // Low areas between mesas — rubble and scattered boulders
      h += fbm(px * 0.06 * freq, py * 0.06 * freq, 3) * 6.0 * scale;
    }
    // Vertical cliff edges: sharpen transitions
    const edgeGrad = Math.abs(noise2D(px * 0.03 * freq + 5, py * 0.03 * freq + 5) - mesaNoise);
    if (edgeGrad < 0.08) {
      h += noise2D(px * 0.15 * freq, py * 0.15 * freq) * 4.0 * scale;
    }
    // Floating debris above mesas
    const floatNoise = noise2D(px * 0.05 * freq + 20, py * 0.05 * freq + 20);
    if (floatNoise > 0.6 && mesaNoise > 0.2) {
      h += 8.0 * scale;
    }

  } else if (style === 21) {
    // Waterfall cascades — stepped cliff faces with deep plunge pools
    // Dramatic back-to-front descent with sheer drops
    const mainSlope = (py + 75) * 0.25 * scale;
    h += mainSlope;
    // Major cliff steps — large quantized drops
    const cliffNoise = fbm(px * 0.02 * freq, py * 0.015 * freq, 3) * 35.0 * scale;
    const cliffStep = 10.0 * scale;
    const stepped = Math.floor(cliffNoise / cliffStep) * cliffStep;
    const smooth = cliffNoise;
    h += stepped * 0.8 + smooth * 0.2;
    // Plunge pools — circular depressions at cliff bases
    for (let pi = 0; pi < 5; pi++) {
      const poolX = noise2D(pi * 43.7, pi * 91.3) * 120;
      const poolY = noise2D(pi * 67.1, pi * 23.9) * 60 - 10;
      const dist = Math.sqrt((px - poolX) ** 2 + (py - poolY) ** 2);
      const poolR = 8 + Math.abs(noise2D(pi * 17.3, pi * 53.1)) * 12;
      if (dist < poolR) {
        const t = dist / poolR;
        h -= (1 - t * t) * 12.0 * scale;
      }
    }
    // Narrow gorges carved by water flow
    const gorge1 = Math.sin(px * 0.04 * freq + noise2D(py * 0.008, 2.0) * 6.0);
    h -= smoothstepJS(0.08, 0.0, Math.abs(gorge1)) * 10.0 * scale;
    // Spray mist shelves — flat ledges where water collects
    const shelf = noise2D(px * 0.06 * freq, py * 0.06 * freq);
    if (shelf > 0.4 && shelf < 0.55) h += 3.0 * scale;
    // Rock texture and erosion
    h += noise2D(px * 0.2 * freq, py * 0.2 * freq) * 2.0 * scale;
    h += fbm(px * 0.1 * freq, py * 0.1 * freq, 2) * 3.0 * scale;

  } else if (style === 22) {
    // Grand plateau — vast flat-topped highland with dramatic cliff edges
    const plateauBase = fbm(px * 0.012 * freq, py * 0.012 * freq, 3) * 40.0 * scale;
    // Hard plateau level — sharp transition to flat top
    const plateauLevel = 18.0 * scale;
    if (plateauBase > plateauLevel * 0.7) {
      // On the plateau — mostly flat with gentle undulation
      h += plateauLevel;
      h += noise2D(px * 0.04 * freq, py * 0.04 * freq) * 3.0 * scale;
      // Scattered boulders and erosion features on top
      const boulder = noise2D(px * 0.15 * freq + 3, py * 0.15 * freq + 3);
      if (boulder > 0.5) h += Math.pow((boulder - 0.5) * 2, 2) * 8.0 * scale;
      // Ancient river channels cut across the top
      const channel = Math.sin(px * 0.03 * freq + py * 0.02 * freq + noise2D(px * 0.01, py * 0.01) * 3);
      h -= smoothstepJS(0.1, 0.0, Math.abs(channel)) * 4.0 * scale;
    } else {
      // Below the plateau — lower terrain with talus slopes
      h += plateauBase * 0.5;
      h += fbm(px * 0.06 * freq, py * 0.06 * freq, 3) * 6.0 * scale;
      // Cliff-face detail at transition zone
      const edgeDist = Math.abs(plateauBase - plateauLevel * 0.7);
      if (edgeDist < 5.0 * scale) {
        h += noise2D(px * 0.25 * freq, py * 0.25 * freq) * 3.0 * scale;
      }
    }

  } else if (style === 23) {
    // Towering sea cliffs — near-vertical walls plunging into ocean
    // Main cliff line running roughly horizontal with wander
    const cliffWander = noise2D(px * 0.008 * freq, 5.0) * 40;
    const cliffLine = py - cliffWander;
    // Sheer cliff face — extreme steep transition
    const cliffHeight = 35.0 * scale;
    if (cliffLine > 5) {
      // Above cliff — high plateau
      h += cliffHeight;
      h += fbm(px * 0.03 * freq, py * 0.03 * freq, 3) * 8.0 * scale;
      // Wind erosion on cliff top
      h += noise2D(px * 0.1 * freq, py * 0.1 * freq) * 2.0 * scale;
    } else if (cliffLine > -8) {
      // The cliff face itself — steep with overhangs
      const t = (cliffLine + 8) / 13.0;
      h += cliffHeight * smoothstepJS(0, 1, t);
      // Horizontal strata bands
      h += Math.sin(cliffLine * 2.0 * freq) * 1.5 * scale;
      // Loose rock shelves
      const ledge = noise2D(px * 0.12 * freq, cliffLine * 0.5);
      if (ledge > 0.6) h += 3.0 * scale;
    } else {
      // Sea level / beach — low terrain
      h += fbm(px * 0.04 * freq, py * 0.04 * freq, 3) * 5.0 * scale;
      // Sea stacks — dramatic pillars in the water
      const stack = noise2D(px * 0.06 * freq + 10, py * 0.06 * freq + 10);
      if (stack > 0.55) h += Math.pow((stack - 0.55) * 2.22, 2) * 25.0 * scale;
      // Tidal pools
      const pool = noise2D(px * 0.1 * freq, py * 0.1 * freq);
      if (pool < -0.3) h -= 2.0 * scale;
    }
    // General roughness
    h += noise2D(px * 0.2 * freq, py * 0.2 * freq) * 1.5 * scale;

  } else if (style === 24) {
    // Alien ruins — geometric foundations half-buried in terrain
    // Base undulating terrain
    h += fbm(px * 0.025 * freq, py * 0.025 * freq, 3) * 10.0 * scale;
    // Large geometric platforms at regular-ish intervals
    for (let ri = 0; ri < 6; ri++) {
      const rx = noise2D(ri * 57.3, ri * 83.1) * 160;
      const ry = noise2D(ri * 41.7, ri * 29.3) * 80;
      const dx = px - rx, dy = py - ry;
      // Chebyshev distance for square-ish platforms
      const dist = Math.max(Math.abs(dx), Math.abs(dy));
      const platSize = 10 + Math.abs(noise2D(ri * 13.7, ri * 47.1)) * 18;
      const platHeight = (5 + Math.abs(noise2D(ri * 71.3, ri * 39.7)) * 15) * scale;
      if (dist < platSize) {
        const edge = smoothstepJS(platSize, platSize - 2, dist);
        h += platHeight * edge;
        // Concentric rings carved into platform surfaces
        const ringDist = Math.sqrt(dx * dx + dy * dy);
        const ring = Math.sin(ringDist * 0.5) * 0.5 + 0.5;
        if (ring > 0.7 && dist < platSize - 2) h += 2.0 * scale;
        // Central obelisk / monolith
        if (dist < 3) {
          const obelisk = (1 - dist / 3);
          h += obelisk * obelisk * 18.0 * scale;
        }
      }
    }
    // Channels between structures — processional walkways
    const walkway = Math.sin(px * 0.035 * freq + 1.5) + Math.sin(py * 0.04 * freq + 0.8);
    h -= smoothstepJS(0.3, 0.0, Math.abs(walkway)) * 5.0 * scale;
    // Weathering and sand-burial
    h += noise2D(px * 0.15 * freq, py * 0.15 * freq) * 2.5 * scale;
    // Scattered column stumps
    let col = noise2D(px * 0.2 * freq + 20, py * 0.2 * freq + 20);
    col = Math.max(0, col - 0.6) * 2.5;
    h += Math.pow(col, 3) * 12.0 * scale;

  } else if (style === 25) {
    // Cavern system — vast underground chamber with stalactite ceiling implied by inverted terrain
    // Sunken bowl shape — terrain is low with high walls
    const caveDist = Math.sqrt(px * px * 0.0004 + py * py * 0.001) * freq;
    const caveWall = smoothstepJS(0.6, 1.2, caveDist) * 35.0 * scale;
    h += caveWall;
    // Cave floor — mostly flat with underground lake basin in the center
    if (caveDist < 0.6) {
      // Stalagmites from floor
      const stalag = noise2D(px * 0.12 * freq, py * 0.12 * freq);
      if (stalag > 0.35) {
        h += Math.pow((stalag - 0.35) * 1.54, 2) * 20.0 * scale;
      }
      // Flowstone formations — smooth rounded mounds
      const flow = noise2D(px * 0.05 * freq + 7, py * 0.05 * freq + 7);
      h += Math.max(0, flow) * flow * 8.0 * scale;
      // Lake depression in center
      if (caveDist < 0.25) {
        const lakeFade = caveDist / 0.25;
        h -= (1 - lakeFade * lakeFade) * 10.0 * scale;
      }
    }
    // Breakdown boulders scattered around
    const boulder = noise2D(px * 0.08 * freq + 15, py * 0.08 * freq + 15);
    if (boulder > 0.55) h += Math.pow((boulder - 0.55) * 2.22, 1.5) * 10.0 * scale;
    // Crystal clusters on floor
    let crystal = noise2D(px * 0.18 * freq + 30, py * 0.18 * freq + 30);
    crystal = Math.max(0, crystal - 0.55) * 2.22;
    h += Math.pow(crystal, 2.5) * 15.0 * scale;
    // General floor roughness
    h += noise2D(px * 0.25 * freq, py * 0.25 * freq) * 1.5 * scale;

  } else if (style === 26) {
    // Abyssal deep sea — submarine terrain with hydrothermal vents and ridges
    // Base deep ocean floor — mostly flat with gentle undulation
    h += fbm(px * 0.015 * freq, py * 0.015 * freq, 3) * 8.0 * scale;
    h -= 5.0 * scale; // Push everything down
    // Mid-ocean ridge — long raised spine
    const ridgePath = Math.sin(py * 0.02 * freq + noise2D(px * 0.005, 3.0) * 5);
    const ridgeProximity = smoothstepJS(0.3, 0.0, Math.abs(ridgePath));
    h += ridgeProximity * 18.0 * scale;
    // Ridge crest rift — crack along the top
    h -= smoothstepJS(0.05, 0.0, Math.abs(ridgePath)) * 6.0 * scale;
    // Hydrothermal vent chimneys — black smoker towers
    for (let vi = 0; vi < 8; vi++) {
      const vx = noise2D(vi * 53.3, vi * 87.1) * 140;
      const vy = noise2D(vi * 41.7, vi * 63.9) * 70;
      const dist = Math.sqrt((px - vx) ** 2 + (py - vy) ** 2);
      const ventR = 3 + Math.abs(noise2D(vi * 11.1, vi * 22.2)) * 5;
      const ventH = (12 + Math.abs(noise2D(vi * 33.3, vi * 44.4)) * 18) * scale;
      if (dist < ventR) {
        const t = 1 - dist / ventR;
        h += ventH * Math.pow(t, 1.8);
      }
      // Mineral deposits around vents
      if (dist < ventR * 3) {
        h += noise2D(px * 0.15 + vi, py * 0.15 + vi) * 2.0 * scale * (1 - dist / (ventR * 3));
      }
    }
    // Abyssal plains — extremely flat areas with subtle ripples
    const plains = smoothstepJS(0.2, 0.5, Math.abs(ridgePath));
    h *= (1 - plains * 0.3);
    // Manganese nodule texture
    h += Math.abs(noise2D(px * 0.3 * freq, py * 0.3 * freq)) * 1.0 * scale;

  } else if (style === 27) {
    // Grand erg — massive sand sea with complex dune systems
    // Primary star dune — huge radiating ridges
    const starAngle = Math.atan2(py, px);
    const starR = Math.sqrt(px * px + py * py) * 0.015 * freq;
    const starArms = Math.sin(starAngle * 3 + starR * 2) * Math.cos(starAngle * 2 - starR);
    h += (starArms * 0.5 + 0.5) * 18.0 * scale;
    // Barchan dune chains — crescent-shaped dunes marching in rows
    const barchan = Math.sin(px * 0.06 * freq + py * 0.02 * freq + noise2D(py * 0.01, 0.5) * 3);
    const barchanShape = Math.max(0, barchan);
    h += Math.pow(barchanShape, 1.5) * 12.0 * scale;
    // Seif / longitudinal dunes — long parallel ridges
    const seif = Math.sin(py * 0.08 * freq + noise2D(px * 0.008, py * 0.008) * 4);
    h += Math.abs(seif) * 6.0 * scale;
    // Wind ripples — fine detail
    const ripple1 = Math.sin(px * 0.5 * freq + py * 0.2 * freq) * 0.8 * scale;
    const ripple2 = Math.sin(px * 0.3 * freq - py * 0.4 * freq + 1.5) * 0.5 * scale;
    h += ripple1 + ripple2;
    // Interdune corridors — flat areas between dune systems
    const corridor = fbm(px * 0.03 * freq, py * 0.03 * freq, 2);
    if (corridor < -0.3) h *= 0.3;
    // Exposed bedrock in deflation hollows
    if (corridor < -0.4) h += noise2D(px * 0.2 * freq, py * 0.2 * freq) * 2.0 * scale;

  } else if (style === 28) {
    // Chimney rock / fairy chimneys — extreme hoodoo formations
    // Low base plain
    h += fbm(px * 0.02 * freq, py * 0.02 * freq, 3) * 5.0 * scale;
    // Dense chimney forest — tall narrow spires
    const chimneyField = noise2D(px * 0.08 * freq, py * 0.08 * freq);
    const chimneyField2 = noise2D(px * 0.12 * freq + 5, py * 0.12 * freq + 5);
    if (chimneyField > 0.15) {
      const spireH = Math.pow((chimneyField - 0.15) / 0.85, 0.25) * 35.0 * scale;
      h += spireH;
      // Cap rock — wider flat top
      if (chimneyField > 0.4) h += 3.0 * scale;
    }
    if (chimneyField2 > 0.2) {
      h += Math.pow((chimneyField2 - 0.2) / 0.8, 0.3) * 22.0 * scale;
    }
    // Erosion channels between chimneys
    const erosion = Math.sin(px * 0.05 * freq + noise2D(py * 0.01 + 7, px * 0.01 + 3) * 5);
    h -= smoothstepJS(0.1, 0.0, Math.abs(erosion)) * 8.0 * scale;
    // Wind-carved arches (rare)
    const arch = noise2D(px * 0.04 * freq + 20, py * 0.04 * freq + 20);
    if (arch > 0.65 && chimneyField > 0.3) {
      const archCut = Math.sin(px * 0.15 * freq) * 0.5 + 0.5;
      if (archCut > 0.6) h -= 6.0 * scale;
    }
    // Surface texture — layered sediment bands
    h += Math.sin(h * 0.3) * 1.5 * scale;
    h += noise2D(px * 0.3 * freq, py * 0.3 * freq) * 1.0 * scale;
  }
  return h;
}

// Displace a PlaneGeometry on the CPU — bulletproof, no GPU shader limits
// Returns { minH, maxH } for water level placement
function displaceTerrain(geometry, terrainStyle, terrainScale, terrainFreq) {
  const pos = geometry.attributes.position.array;
  const count = pos.length / 3;
  const elevations = new Float32Array(count);
  let minH = Infinity, maxH = -Infinity;

  for (let i = 0; i < count; i++) {
    const x = pos[i * 3];
    const y = pos[i * 3 + 1];

    let h = computeTerrainHeight(x, y, terrainStyle, terrainScale, terrainFreq);

    // Edge fade — prevent hard geometry cuts at plane borders
    // PlaneGeometry(300,150): x ∈ [-150,150], y ∈ [-75,75]
    let edgeFade = smoothstepJS(0, 35, Math.min(Math.abs(x + 100), Math.abs(x - 100)));
    edgeFade *= smoothstepJS(0, 25, 75 - y); // fade at far edge

    // Front fade — reduce height near camera so terrain doesn't block editor
    const frontFade = smoothstepJS(-60, -20, y);
    h *= edgeFade * frontFade;

    pos[i * 3 + 2] = h;   // displace local Z → world Y (up) after rotation
    elevations[i] = h;
    if (h < minH) minH = h;
    if (h > maxH) maxH = h;
  }

  geometry.attributes.position.needsUpdate = true;
  geometry.computeVertexNormals();
  geometry.setAttribute('aElevation', new THREE.BufferAttribute(elevations, 1));
  return { minH, maxH };
}

// ═══════════════════════════════════════════
// IndexedDB — lightweight auto-save store
// ═══════════════════════════════════════════
const IDB = {
  _db: null,
  _name: 'voyage-writer-db',
  _store: 'recovery',
  _ver: 1,
  open() {
    if (this._db) return Promise.resolve(this._db);
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(this._name, this._ver);
      req.onupgradeneeded = () => { req.result.createObjectStore(this._store); };
      req.onsuccess = () => { this._db = req.result; resolve(this._db); };
      req.onerror = () => reject(req.error);
    });
  },
  async get(key) {
    const db = await this.open();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(this._store, 'readonly');
      const req = tx.objectStore(this._store).get(key);
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  },
  async set(key, value) {
    const db = await this.open();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(this._store, 'readwrite');
      tx.objectStore(this._store).put(value, key);
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  },
  async del(key) {
    const db = await this.open();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(this._store, 'readwrite');
      tx.objectStore(this._store).delete(key);
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  }
};

// ─── State ───
const APP = {
  state: 'starfield', // starfield | system | landed
  camera: { x: 0, y: 0 },
  velocity: { x: 0, y: 0 },
  keys: {},
  stars: new Map(),
  currentStar: null,
  currentSystem: null,
  currentLocation: null,
  dayProgress: 0.5,
  dayPinned: null, // null = auto cycle, 'day' or 'night' = pinned
  textMode: 'light', // 'light', 'dark', or 'auto'
  focusMode: false,
  editorActive: false,
  editorFont: 'Cormorant Garamond',
  editorFontSize: 19,
  spellcheck: false,
  fileHandle: null,
  fileName: null,
  dirty: false,
  lastSavedText: '',
  autoSaveInterval: null,
  logbook: { visited: {}, transitFiles: [] },
  width: window.innerWidth,
  height: window.innerHeight,
  // Three.js state
  webglActive: false,
  three: null, // Will hold Three.js scene data
};

// ─── DOM refs ───
const $ = id => document.getElementById(id);
const canvas = $('starfield');
const ctx = canvas.getContext('2d');
const sysCanvas = $('system-canvas');
const sysCtx = sysCanvas.getContext('2d');
const logCanvas = $('logbook-canvas');
const logCtx = logCanvas.getContext('2d');

// ─── Resize ───
function resize() {
  APP.width = window.innerWidth;
  APP.height = window.innerHeight;
  canvas.width = APP.width;
  canvas.height = APP.height;
  sysCanvas.width = APP.width;
  sysCanvas.height = APP.height;
  logCanvas.width = APP.width;
  logCanvas.height = APP.height;
  // Invalidate offscreen caches
  APP._bgStarsCanvas = null;
  APP._sysStarsBg = null;
  // Resize Three.js
  if (APP.three && APP.three.renderer) {
    APP.three.renderer.setSize(APP.width, APP.height);
    APP.three.camera.aspect = APP.width / APP.height;
    APP.three.camera.updateProjectionMatrix();
  }
}
window.addEventListener('resize', resize);
resize();

// ═══════════════════════════════════════════
// THREE.JS 3D LANDSCAPE SYSTEM
// ═══════════════════════════════════════════

// GLSL noise functions for shaders
const NOISE_GLSL = `
  vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
  vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
  vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }
  
  float snoise(vec2 v) {
    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
    vec2 i = floor(v + dot(v, C.yy));
    vec2 x0 = v - i + dot(i, C.xx);
    vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    vec4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;
    i = mod289(i);
    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
    m = m*m; m = m*m;
    vec3 x = 2.0 * fract(p * C.www) - 1.0;
    vec3 h = abs(x) - 0.5;
    vec3 ox = floor(x + 0.5);
    vec3 a0 = x - ox;
    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
    vec3 g;
    g.x = a0.x * x0.x + h.x * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
  }
  
  float fbm(vec2 p, int octaves) {
    float val = 0.0, amp = 1.0, freq = 1.0, maxVal = 0.0;
    for (int i = 0; i < 6; i++) {
      if (i >= octaves) break;
      val += snoise(p * freq) * amp;
      maxVal += amp;
      amp *= 0.5;
      freq *= 2.0;
    }
    return val / maxVal;
  }
`;

// Initialize Three.js when loaded
window.initThreeJS = function() {
  if (!window.THREE || APP.three) return;
  
  const canvas3d = $('landscape-3d');
  
  const renderer = new THREE.WebGLRenderer({ canvas: canvas3d, antialias: true, alpha: false });
  renderer.setSize(APP.width, APP.height);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60, APP.width / APP.height, 0.1, 2000);
  camera.position.set(0, 12, 22);
  camera.lookAt(0, 5, -10);
  
  APP.three = {
    renderer, scene, camera,
    clock: new THREE.Clock(),
    objects: {},
    particles: null
  };
  
  console.log('Three.js scene initialized');
};

// Create sky dome shader material
function createSkyMaterial(palette) {
  const h = palette.hue / 360;
  const s = palette.sat / 100;
  const auroraH = (palette.auroraHue || ((palette.hue + 140) % 360)) / 360;
  
  // Use curated sky colors if available, with HSL-to-RGB conversion as vec3 uniforms
  function hslToRgbVec(hsl) {
    if (!hsl) return null;
    const hh = hsl[0] / 360, ss = hsl[1] / 100, ll = hsl[2] / 100;
    if (ss === 0) return new THREE.Vector3(ll, ll, ll);
    const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1; if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };
    const q = ll < 0.5 ? ll * (1 + ss) : ll + ss - ll * ss;
    const p = 2 * ll - q;
    return new THREE.Vector3(hue2rgb(p, q, hh + 1/3), hue2rgb(p, q, hh), hue2rgb(p, q, hh - 1/3));
  }
  
  const hasCurated = palette.skyDayZenith && palette.skyDayHorizon && palette.skyNightZenith && palette.skyNightHorizon;
  const dayZenith = hasCurated ? hslToRgbVec(palette.skyDayZenith) : new THREE.Vector3(0.3, 0.4, 0.7);
  const dayHorizon = hasCurated ? hslToRgbVec(palette.skyDayHorizon) : new THREE.Vector3(0.7, 0.5, 0.4);
  const nightZenith = hasCurated ? hslToRgbVec(palette.skyNightZenith) : new THREE.Vector3(0.02, 0.02, 0.06);
  const nightHorizon = hasCurated ? hslToRgbVec(palette.skyNightHorizon) : new THREE.Vector3(0.04, 0.04, 0.08);
  
  return new THREE.ShaderMaterial({
    uniforms: {
      uDayProgress: { value: 0.5 },
      uHue: { value: h },
      uSat: { value: s },
      uAuroraHue: { value: auroraH },
      uTime: { value: 0 },
      uDayZenith: { value: dayZenith },
      uDayHorizon: { value: dayHorizon },
      uNightZenith: { value: nightZenith },
      uNightHorizon: { value: nightHorizon }
    },
    vertexShader: `
      varying vec3 vWorldPosition;
      void main() {
        vec4 worldPos = modelMatrix * vec4(position, 1.0);
        vWorldPosition = worldPos.xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      ${NOISE_GLSL}
      uniform float uDayProgress;
      uniform float uHue;
      uniform float uSat;
      uniform float uAuroraHue;
      uniform float uTime;
      uniform vec3 uDayZenith;
      uniform vec3 uDayHorizon;
      uniform vec3 uNightZenith;
      uniform vec3 uNightHorizon;
      varying vec3 vWorldPosition;
      
      vec3 hsl2rgb(float h, float s, float l) {
        vec3 rgb = clamp(abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);
        return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));
      }
      
      void main() {
        float skyBright = sin(uDayProgress * 3.14159);
        float y = normalize(vWorldPosition).y;
        float heightFactor = clamp(y * 0.5 + 0.5, 0.0, 1.0);
        
        // Use curated palette colors for sky gradients
        vec3 dayTop = uDayZenith;
        vec3 dayHorizon = uDayHorizon;
        vec3 nightTop = uNightZenith;
        vec3 nightHorizon = uNightHorizon;
        
        vec3 topColor = mix(nightTop, dayTop, skyBright);
        vec3 horizonColor = mix(nightHorizon, dayHorizon, skyBright);
        vec3 skyColor = mix(horizonColor, topColor, pow(heightFactor, 0.7));
        
        // Golden hour — richer warm tints with color gradient
        float goldenMix = 0.0;
        if (uDayProgress > 0.04 && uDayProgress < 0.22) {
          goldenMix = uDayProgress < 0.12 ? (uDayProgress - 0.04) / 0.08 : (0.22 - uDayProgress) / 0.1;
        } else if (uDayProgress > 0.78 && uDayProgress < 0.96) {
          goldenMix = uDayProgress < 0.88 ? (uDayProgress - 0.78) / 0.1 : (0.96 - uDayProgress) / 0.08;
        }
        goldenMix = clamp(goldenMix, 0.0, 1.0) * 0.6;
        vec3 goldenLow = vec3(1.0, 0.55, 0.25);  // deep orange near horizon
        vec3 goldenHigh = vec3(1.0, 0.75, 0.50);  // softer peach higher up
        vec3 goldenTint = mix(goldenLow, goldenHigh, heightFactor);
        skyColor = mix(skyColor, skyColor * goldenTint * 1.3, goldenMix * (1.0 - heightFactor * 0.6));
        
        // Aurora effect at night — flowing curtains of color
        if (skyBright < 0.35 && heightFactor > 0.35) {
          float nightIntensity = 1.0 - skyBright / 0.35;
          float auroraWave = snoise(vec2(vWorldPosition.x * 0.008 + uTime * 0.04, vWorldPosition.z * 0.004));
          float auroraHeight = smoothstep(0.35, 0.7, heightFactor) * smoothstep(0.95, 0.7, heightFactor);
          float auroraCurtain = smoothstep(0.1, 0.6, auroraWave) * auroraHeight;
          auroraCurtain *= 0.5 + 0.5 * sin(vWorldPosition.x * 0.02 + uTime * 0.08);

          vec3 auroraColor1 = hsl2rgb(uAuroraHue, 0.85, 0.58);
          vec3 auroraColor2 = hsl2rgb(mod(uAuroraHue + 0.15, 1.0), 0.75, 0.52);
          float colorMix = sin(vWorldPosition.x * 0.01 + uTime * 0.03) * 0.5 + 0.5;
          vec3 aurora = mix(auroraColor1, auroraColor2, colorMix);
          skyColor += aurora * auroraCurtain * nightIntensity * 0.35;
        }
        
        // Night stars — brighter, more varied
        if (skyBright < 0.4 && heightFactor > 0.25) {
          float nightFactor = 1.0 - skyBright / 0.4;
          float starNoise = snoise(vWorldPosition.xz * 50.0 + uTime * 0.08);
          float stars = smoothstep(0.83, 0.96, starNoise) * nightFactor;
          // Colored stars — subtle tinting
          float starHue = fract(snoise(vWorldPosition.xz * 30.0) * 3.0);
          vec3 starColor = mix(vec3(1.0), hsl2rgb(starHue, 0.3, 0.9), 0.3);
          skyColor += starColor * stars * 0.9;
          // Dim background stars
          float dimStars = smoothstep(0.7, 0.85, snoise(vWorldPosition.xz * 80.0 + 100.0)) * nightFactor;
          skyColor += vec3(dimStars * 0.15);
        }
        
        gl_FragColor = vec4(skyColor, 1.0);
      }
    `,
    side: THREE.BackSide
  });
}

// Get terrain shape parameters for CPU-side displacement
// terrainStyle index:
// 0=rolling, 1=jagged, 2=dunes, 3=spires, 4=mesa, 5=bulbous,
// 6=glacier, 7=terraced, 8=angular, 9=volcanic cones, 10=river valley,
// 11=island archipelago, 12=fjord, 13=caldera, 14=stormy crags, 15=icefall cascade,
// 16=pillar forest, 17=sinkhole, 18=tide pools, 19=badlands, 20=floating mesa,
// 21=waterfall cascades, 22=grand plateau, 23=towering sea cliffs, 24=alien ruins,
// 25=cavern system, 26=abyssal deep sea, 27=grand erg (dunes), 28=chimney spires
//
// waterLevel: if set, a water plane is placed at that Y height (world space)
// waterType: 'water' (blue/teal), 'lava' (orange/red), 'toxic' (green)

function getTerrainParams(surface, locType) {
  let terrainStyle = 0, terrainScale = 1.0, terrainFreq = 1.0;
  let waterLevel = null, waterType = 'water';
  
  switch(surface) {
    case 'volcanic':
      terrainStyle = 9; terrainScale = 1.4; terrainFreq = 1.0; break;
    case 'canyon':
      terrainStyle = 4; terrainScale = 1.8; terrainFreq = 0.8; break;
    case 'crystal':
      terrainStyle = 3; terrainScale = 1.5; terrainFreq = 1.5; break;
    case 'desert':
      terrainStyle = 2; terrainScale = 0.9; terrainFreq = 0.7; break;
    case 'fungal':
      terrainStyle = 5; terrainScale = 1.0; terrainFreq = 1.3; break;
    case 'tundra':
      terrainStyle = 15; terrainScale = 0.8; terrainFreq = 0.7; break;
    case 'coral':
      terrainStyle = 11; terrainScale = 0.8; terrainFreq = 1.5;
      waterLevel = 0; waterType = 'water'; break;
    case 'metallic':
      terrainStyle = 8; terrainScale = 1.1; terrainFreq = 1.0; break;
    case 'ancient':
      terrainStyle = 7; terrainScale = 1.0; terrainFreq = 0.9; break;
    case 'glass':
      terrainStyle = 2; terrainScale = 0.4; terrainFreq = 0.5; break;
    case 'storm':
      terrainStyle = 14; terrainScale = 1.3; terrainFreq = 1.0; break;
    case 'moss':
      terrainStyle = 10; terrainScale = 0.7; terrainFreq = 0.8;
      waterLevel = -2; waterType = 'water'; break;
    case 'bioluminescent':
      terrainStyle = 5; terrainScale = 0.85; terrainFreq = 1.2; break;
    case 'sulphur':
      terrainStyle = 13; terrainScale = 0.7; terrainFreq = 1.0;
      waterLevel = 3; waterType = 'toxic'; break;
    case 'prismatic':
      terrainStyle = 3; terrainScale = 1.2; terrainFreq = 1.4; break;
    case 'magnetic':
      terrainStyle = 8; terrainScale = 1.3; terrainFreq = 0.9; break;
    case 'ocean':
      terrainStyle = 11; terrainScale = 1.0; terrainFreq = 1.0;
      waterLevel = 0; waterType = 'water'; break;
    case 'obsidian':
      terrainStyle = 1; terrainScale = 0.9; terrainFreq = 1.1; break;
    case 'salt':
      terrainStyle = 18; terrainScale = 0.5; terrainFreq = 0.6; break;
    case 'mycelium':
      terrainStyle = 5; terrainScale = 1.1; terrainFreq = 1.4; break;
    case 'plasma':
      terrainStyle = 14; terrainScale = 0.8; terrainFreq = 1.6; break;
    case 'bone':
      terrainStyle = 19; terrainScale = 0.9; terrainFreq = 0.8; break;
    case 'sandstone':
      terrainStyle = 28; terrainScale = 0.8; terrainFreq = 0.9; break;
    case 'cavern':
      terrainStyle = 25; terrainScale = 1.0; terrainFreq = 1.0; break;
    case 'abyssal':
      terrainStyle = 26; terrainScale = 1.0; terrainFreq = 0.8;
      waterLevel = 5; waterType = 'water'; break;
    case 'ruins':
      terrainStyle = 24; terrainScale = 0.9; terrainFreq = 0.8; break;
    case 'basalt':
      terrainStyle = 16; terrainScale = 1.2; terrainFreq = 1.0; break;
  }
  
  // Location type overrides — these take priority
  if (locType === 'Frozen Abyss') {
    terrainStyle = 15; terrainScale = 1.4; terrainFreq = 0.8;
  }
  if (locType === 'Crystalline Spire') {
    terrainStyle = 3; terrainScale = 2.2; terrainFreq = 1.8;
  }
  if (locType === 'Volcanic Forge') {
    terrainStyle = 9; terrainScale = 1.6; terrainFreq = 1.2;
    waterLevel = -3; waterType = 'lava';
  }
  if (locType === 'Bioluminescent Jungle') {
    terrainStyle = 5; terrainScale = 1.1; terrainFreq = 1.5;
  }
  if (locType === 'Coastal World') {
    terrainStyle = 12; terrainScale = 1.2; terrainFreq = 0.9;
    waterLevel = 2; waterType = 'water';
  }
  if (locType === 'River Delta') {
    terrainStyle = 10; terrainScale = 1.0; terrainFreq = 1.0;
    waterLevel = -1; waterType = 'water';
  }
  if (locType === 'Island Chain') {
    terrainStyle = 11; terrainScale = 1.2; terrainFreq = 1.1;
    waterLevel = 0; waterType = 'water';
  }
  if (locType === 'Caldera World') {
    terrainStyle = 13; terrainScale = 1.3; terrainFreq = 0.9;
    waterLevel = 4; waterType = 'lava';
  }
  if (locType === 'Storm Peaks') {
    terrainStyle = 14; terrainScale = 1.5; terrainFreq = 1.1;
  }
  if (locType === 'Glacial Shelf') {
    terrainStyle = 15; terrainScale = 1.3; terrainFreq = 0.8;
    waterLevel = -4; waterType = 'water';
  }
  if (locType === 'Pillar Forest') {
    terrainStyle = 16; terrainScale = 1.4; terrainFreq = 1.0;
  }
  if (locType === 'Sinkhole World') {
    terrainStyle = 17; terrainScale = 1.2; terrainFreq = 0.9;
    waterLevel = -8; waterType = 'water';
  }
  if (locType === 'Salt Flats') {
    terrainStyle = 18; terrainScale = 0.4; terrainFreq = 0.5;
  }
  if (locType === 'Geothermal Springs') {
    terrainStyle = 0; terrainScale = 0.8; terrainFreq = 0.9;
    waterLevel = -3; waterType = 'toxic';
  }
  if (locType === 'Badlands') {
    terrainStyle = 19; terrainScale = 1.3; terrainFreq = 1.0;
  }
  if (locType === 'Floating Mesa') {
    terrainStyle = 20; terrainScale = 1.5; terrainFreq = 0.8;
  }
  if (locType === 'Waterfall Cliffs') {
    terrainStyle = 21; terrainScale = 1.4; terrainFreq = 0.9;
    waterLevel = -5; waterType = 'water';
  }
  if (locType === 'Grand Plateau') {
    terrainStyle = 22; terrainScale = 1.5; terrainFreq = 0.7;
  }
  if (locType === 'Towering Cliffs') {
    terrainStyle = 23; terrainScale = 1.6; terrainFreq = 0.8;
    waterLevel = -2; waterType = 'water';
  }
  if (locType === 'Alien Necropolis') {
    terrainStyle = 24; terrainScale = 1.3; terrainFreq = 0.7;
  }
  if (locType === 'Crystal Cavern') {
    terrainStyle = 25; terrainScale = 1.2; terrainFreq = 1.1;
    waterLevel = -6; waterType = 'water';
  }
  if (locType === 'Abyssal Trench') {
    terrainStyle = 26; terrainScale = 1.4; terrainFreq = 0.9;
    waterLevel = 8; waterType = 'water';
  }
  if (locType === 'Dune Sea') {
    terrainStyle = 27; terrainScale = 1.3; terrainFreq = 0.8;
  }
  if (locType === 'Chimney Spires') {
    terrainStyle = 28; terrainScale = 1.5; terrainFreq = 1.0;
  }
  
  return { terrainStyle, terrainScale, terrainFreq, waterLevel, waterType };
}

// Create terrain shader material — lightweight vertex shader (displacement done on CPU)
function createTerrainMaterial(palette, surface, temperature, locType) {
  const h = palette.hue / 360;
  const s = palette.sat / 100;
  let emissive = 0.0, emissiveHue = h;
  
  // Surface-specific emissive properties
  if (surface === 'volcanic' || temperature === 'molten') {
    emissive = 0.35;
    emissiveHue = 0.05;
  } else if (surface === 'bioluminescent') {
    emissive = 0.2;
    emissiveHue = (h + 0.45) % 1.0;
  } else if (surface === 'crystal') {
    emissive = 0.12;
    emissiveHue = (h + 0.3) % 1.0;
  } else if (surface === 'fungal') {
    emissive = 0.1;
    emissiveHue = (h + 0.35) % 1.0;
  } else if (surface === 'prismatic') {
    emissive = 0.15;
    emissiveHue = h;
  } else if (surface === 'magnetic') {
    emissive = 0.08;
    emissiveHue = (h + 0.6) % 1.0;
  } else if (surface === 'cavern') {
    emissive = 0.12;
    emissiveHue = (h + 0.4) % 1.0; // phosphorescent cave glow
  } else if (surface === 'abyssal') {
    emissive = 0.18;
    emissiveHue = 0.05; // hydrothermal vent glow
  } else if (surface === 'ruins') {
    emissive = 0.06;
    emissiveHue = (h + 0.15) % 1.0; // faint alien power source
  }

  // Surface type flag passed to shader
  const surfaceFlag = {
    'volcanic': 1, 'bioluminescent': 2, 'crystal': 3, 'metallic': 4,
    'fungal': 5, 'storm': 6, 'prismatic': 7, 'glass': 8,
    'coral': 9, 'sulphur': 10, 'magnetic': 11,
    'cavern': 12, 'abyssal': 13, 'ruins': 14
  }[surface] || 0;

  return new THREE.ShaderMaterial({
    uniforms: {
      uDayProgress: { value: 0.5 },
      uHue: { value: h },
      uSat: { value: s },
      uEmissive: { value: emissive },
      uEmissiveHue: { value: emissiveHue },
      uTime: { value: 0 },
      uSurfaceType: { value: surfaceFlag },
      uFogColor: { value: new THREE.Color(0x000000) },
      uFogNear: { value: 40 },
      uFogFar: { value: 180 }
    },
    vertexShader: `
      // Terrain already displaced on CPU — simple passthrough
      attribute float aElevation;
      varying vec3 vWorldPosition;
      varying vec3 vNormal;
      varying float vElevation;
      varying float vFogDepth;
      
      void main() {
        vElevation = aElevation;
        vNormal = normalize(normalMatrix * normal);
        vec4 worldPos = modelMatrix * vec4(position, 1.0);
        vWorldPosition = worldPos.xyz;
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        vFogDepth = -mvPosition.z;
        gl_Position = projectionMatrix * mvPosition;
      }
    `,
    fragmentShader: `
      ${NOISE_GLSL}
      uniform float uDayProgress;
      uniform float uHue;
      uniform float uSat;
      uniform float uEmissive;
      uniform float uEmissiveHue;
      uniform float uTime;
      uniform float uSurfaceType;
      uniform vec3 uFogColor;
      uniform float uFogNear;
      uniform float uFogFar;
      
      varying vec3 vWorldPosition;
      varying vec3 vNormal;
      varying float vElevation;
      varying float vFogDepth;
      
      vec3 hsl2rgb(float h, float s, float l) {
        vec3 rgb = clamp(abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);
        return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));
      }
      
      void main() {
        float skyBright = sin(uDayProgress * 3.14159);
        float elevNorm = clamp(vElevation / 50.0, 0.0, 1.0);
        
        float baseL = mix(0.07, 0.30, skyBright);
        float peakL = mix(0.12, 0.42, skyBright);
        float l = mix(baseL, peakL, elevNorm);
        float h = mod(uHue + elevNorm * 0.05, 1.0);
        float s = uSat * mix(0.55, 0.8, skyBright);
        
        // Slope-based color variation — steeper = darker/different
        float slope = 1.0 - max(dot(vNormal, vec3(0.0, 1.0, 0.0)), 0.0);
        l -= slope * 0.06 * skyBright;
        h = mod(h + slope * 0.02, 1.0);
        
        // Surface-specific color variation
        if (uSurfaceType == 4.0) { // metallic — hue shift by angle
          float viewAngle = dot(vNormal, normalize(vec3(0.3, 1.0, 0.5)));
          h = mod(h + viewAngle * 0.08, 1.0);
          s *= 0.6;
          l += viewAngle * 0.08 * skyBright;
        } else if (uSurfaceType == 7.0) { // prismatic — rainbow bands
          float prismBand = sin(vWorldPosition.x * 0.12 + vWorldPosition.z * 0.08 + uTime * 0.1);
          h = mod(h + prismBand * 0.15 + uTime * 0.005, 1.0);
          s = max(s, 0.7);
        } else if (uSurfaceType == 9.0) { // coral — warm pinks and oranges
          h = mod(h + sin(vWorldPosition.x * 0.2) * 0.03, 1.0);
          s *= 1.1;
        } else if (uSurfaceType == 10.0) { // sulphur — acidic yellow-green striations
          float sulphurPattern = snoise(vWorldPosition.xz * 0.08 + vec2(uTime * 0.02, 0.0));
          h = mix(h, 0.14, smoothstep(-0.2, 0.4, sulphurPattern) * 0.5);
          s = max(s, 0.65);
        } else if (uSurfaceType == 8.0) { // glass — high specular, subtle hue
          s *= 0.4;
          l += 0.06 * skyBright;
        } else if (uSurfaceType == 12.0) { // cavern — luminescent mineral veins
          float veinPattern = snoise(vWorldPosition.xz * 0.3 + vec2(0.0, uTime * 0.03));
          float vein = smoothstep(0.6, 0.9, veinPattern);
          h = mix(h, mod(h + 0.35, 1.0), vein * 0.6);
          s = max(s, 0.5 + vein * 0.3);
          l += vein * 0.08 * (1.0 + (1.0 - skyBright) * 2.0);
        } else if (uSurfaceType == 13.0) { // abyssal — deep blue with vent glow patches
          h = mix(h, 0.58, 0.4); // push toward deep blue
          s = max(s, 0.35);
          l *= 0.7; // darker overall
          float ventGlow = snoise(vWorldPosition.xz * 0.05 + uTime * 0.02);
          if (ventGlow > 0.4) {
            float glow = (ventGlow - 0.4) / 0.6;
            h = mix(h, 0.04, glow * 0.5); // orange vent glow
            l += glow * 0.12;
            s += glow * 0.2;
          }
        } else if (uSurfaceType == 14.0) { // ruins — geometric patterns in stone
          float grid = sin(vWorldPosition.x * 0.4) * sin(vWorldPosition.z * 0.4);
          float ruinPattern = smoothstep(0.3, 0.8, grid);
          h = mix(h, mod(h + 0.08, 1.0), ruinPattern * 0.3);
          l += ruinPattern * 0.04 * (0.5 + (1.0 - skyBright) * 1.5);
          s *= 0.85 + ruinPattern * 0.15;
        }
        
        vec3 terrainColor = hsl2rgb(h, s, l);
        
        // Lighting
        vec3 lightDir = normalize(vec3(0.5, 0.8, 0.3));
        float diff = max(dot(vNormal, lightDir), 0.0) * skyBright;
        terrainColor *= 0.35 + diff * 0.65;
        
        // Ambient occlusion — adapted for taller terrain
        float ao = smoothstep(-8.0, 25.0, vElevation);
        terrainColor *= 0.5 + ao * 0.5;
        
        // Surface-specific emissive effects
        if (uEmissive > 0.0) {
          float emissivePattern;
          if (uSurfaceType == 3.0) { // crystal — sparkle points
            float crystalGlint = snoise(vWorldPosition.xz * 2.0 + uTime * 0.3);
            emissivePattern = smoothstep(0.75, 0.95, crystalGlint);
            emissivePattern += smoothstep(0.6, 0.8, snoise(vWorldPosition.xz * 0.5)) * 0.3;
          } else if (uSurfaceType == 5.0) { // fungal — pulsing patches
            emissivePattern = smoothstep(0.2, 0.6, snoise(vWorldPosition.xz * 0.12 + sin(uTime * 0.2) * 0.5));
            emissivePattern *= 0.5 + 0.5 * sin(uTime * 0.4 + vWorldPosition.x * 0.1);
          } else if (uSurfaceType == 7.0) { // prismatic — shifting glow
            emissivePattern = 0.3 + 0.3 * sin(vWorldPosition.x * 0.15 + uTime * 0.2);
          } else if (uSurfaceType == 11.0) { // magnetic — flowing lines
            float lines = sin(vWorldPosition.x * 0.3 + snoise(vWorldPosition.xz * 0.05 + uTime * 0.1) * 5.0);
            emissivePattern = smoothstep(0.7, 1.0, lines);
          } else if (uSurfaceType == 12.0) { // cavern — glowing crystal veins
            float vein = snoise(vWorldPosition.xz * 0.3 + vec2(0.0, uTime * 0.03));
            emissivePattern = smoothstep(0.55, 0.85, vein);
            emissivePattern *= 0.6 + 0.4 * sin(uTime * 0.3 + vWorldPosition.x * 0.15);
          } else if (uSurfaceType == 13.0) { // abyssal — hydrothermal vent plumes
            emissivePattern = smoothstep(0.3, 0.7, snoise(vWorldPosition.xz * 0.08 + uTime * 0.04));
            emissivePattern *= smoothstep(15.0, -5.0, vElevation); // glow near floor
          } else if (uSurfaceType == 14.0) { // ruins — pulsing alien power lines
            float gridGlow = sin(vWorldPosition.x * 0.4) * sin(vWorldPosition.z * 0.4);
            emissivePattern = smoothstep(0.6, 0.95, gridGlow);
            emissivePattern *= 0.4 + 0.6 * sin(uTime * 0.2 + vWorldPosition.x * 0.05 + vWorldPosition.z * 0.05);
          } else { // volcanic / bioluminescent default
            emissivePattern = smoothstep(0.3, 0.7, snoise(vWorldPosition.xz * 0.15 + uTime * 0.05));
            emissivePattern *= smoothstep(5.0, -5.0, vElevation);
          }
          vec3 emissiveColor = hsl2rgb(uEmissiveHue, 0.9, 0.6);
          terrainColor += emissiveColor * emissivePattern * uEmissive * (1.0 + (1.0 - skyBright) * 2.5);
        }
        
        // Fog
        float fogFactor = smoothstep(uFogNear, uFogFar, vFogDepth);
        vec3 fogColor = hsl2rgb(uHue, uSat * 0.35, mix(0.06, 0.35, skyBright));
        terrainColor = mix(terrainColor, fogColor, fogFactor * 0.7);
        
        gl_FragColor = vec4(terrainColor, 1.0);
      }
    `
  });
}

// Create water shader material
function createWaterMaterial(palette) {
  const h = palette.hue / 360;
  const s = palette.sat / 100;
  
  return new THREE.ShaderMaterial({
    uniforms: {
      uDayProgress: { value: 0.5 },
      uHue: { value: h },
      uSat: { value: s },
      uTime: { value: 0 },
      uSunPosition: { value: new THREE.Vector3(50, 30, -50) }
    },
    vertexShader: `
      ${NOISE_GLSL}
      uniform float uTime;
      varying vec3 vWorldPosition;
      varying vec3 vNormal;
      varying float vFogDepth;
      
      void main() {
        vec3 pos = position;
        // PlaneGeometry in XY plane; displace Z for world-Y (up) after rotation
        float wave1 = sin(pos.x * 0.3 + uTime * 0.8) * cos(pos.y * 0.2 + uTime * 0.6) * 0.4;
        float wave2 = sin(pos.x * 0.15 + pos.y * 0.1 + uTime * 0.4) * 0.6;
        float wave3 = snoise(pos.xy * 0.1 + uTime * 0.2) * 0.3;
        pos.z += wave1 + wave2 + wave3;
        
        float eps = 0.5;
        float hL = sin((pos.x - eps) * 0.3 + uTime * 0.8) * 0.4;
        float hR = sin((pos.x + eps) * 0.3 + uTime * 0.8) * 0.4;
        float hD = sin((pos.y - eps) * 0.2 + uTime * 0.6) * 0.4;
        float hU = sin((pos.y + eps) * 0.2 + uTime * 0.6) * 0.4;
        vNormal = normalize(vec3(hL - hR, hD - hU, 2.0));
        
        vec4 worldPos = modelMatrix * vec4(pos, 1.0);
        vWorldPosition = worldPos.xyz;
        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
        vFogDepth = -mvPosition.z;
        gl_Position = projectionMatrix * mvPosition;
      }
    `,
    fragmentShader: `
      uniform float uDayProgress;
      uniform float uHue;
      uniform float uSat;
      uniform float uTime;
      uniform vec3 uSunPosition;
      
      varying vec3 vWorldPosition;
      varying vec3 vNormal;
      varying float vFogDepth;
      
      vec3 hsl2rgb(float h, float s, float l) {
        vec3 rgb = clamp(abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);
        return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));
      }
      
      void main() {
        float skyBright = sin(uDayProgress * 3.14159);
        // Water color — always in the blue-teal-cyan range for beauty
        // Map palette hue into a constrained beautiful water hue range
        float rawWaterHue = mod(uHue + 0.55, 1.0);
        // Clamp water hue to always be in the beautiful aquatic range (0.45-0.65 = cyan-blue)
        // Avoid greens (0.25-0.42), reds, yellows, magentas
        float waterHue;
        if (rawWaterHue > 0.42 && rawWaterHue < 0.72) {
          waterHue = rawWaterHue; // Already in good range
        } else {
          // Remap to blue-teal: 0.48-0.62
          waterHue = 0.48 + fract(rawWaterHue * 3.7) * 0.14;
        }
        float waterSat = max(uSat + 0.2, 0.45); // Ensure always saturated enough
        float waterL = mix(0.08, 0.32, skyBright);
        vec3 waterColor = hsl2rgb(waterHue, waterSat, waterL);
        
        // Deep water color variation — darker in troughs, lighter on crests
        float waveHeight = vWorldPosition.y * 0.05;
        waterColor *= 0.9 + waveHeight * 0.2;
        
        vec3 viewDir = normalize(cameraPosition - vWorldPosition);
        float fresnel = pow(1.0 - max(dot(viewDir, vNormal), 0.0), 3.0);
        
        vec3 skyColor = hsl2rgb(waterHue - 0.02, waterSat * 0.5, mix(0.15, 0.5, skyBright));
        waterColor = mix(waterColor, skyColor, fresnel * 0.5);
        
        vec3 lightDir = normalize(uSunPosition - vWorldPosition);
        vec3 halfVec = normalize(lightDir + viewDir);
        float spec = pow(max(dot(vNormal, halfVec), 0.0), 64.0);
        waterColor += vec3(1.0, 0.97, 0.85) * spec * skyBright * 0.8;
        
        // Secondary specular — broader, softer highlight
        float spec2 = pow(max(dot(vNormal, halfVec), 0.0), 16.0);
        waterColor += vec3(0.7, 0.85, 1.0) * spec2 * skyBright * 0.15;
        
        float fogFactor = smoothstep(40.0, 180.0, vFogDepth);
        vec3 fogColor = hsl2rgb(waterHue, waterSat * 0.3, mix(0.06, 0.30, skyBright));
        waterColor = mix(waterColor, fogColor, fogFactor * 0.6);
        
        gl_FragColor = vec4(waterColor, 0.92);
      }
    `,
    transparent: true
  });
}

// Create composite water material — sits alongside terrain for rivers, fjords, islands, lava, etc.
// waterType: 'water', 'lava', 'toxic'
function createCompositeWaterMaterial(palette, waterType) {
  const h = palette.hue / 360;
  const s = palette.sat / 100;
  
  // Color config per water type
  let baseHueShift, baseSat, baseL, waveAmp, waveSpeed, specStrength, opacity, emissiveStr;
  if (waterType === 'lava') {
    baseHueShift = 0.03;  // orange-red
    baseSat = 0.9;
    baseL = 0.15;
    waveAmp = 0.15;       // slow heavy waves
    waveSpeed = 0.3;
    specStrength = 0.2;
    opacity = 0.95;
    emissiveStr = 0.5;    // lava glows
  } else if (waterType === 'toxic') {
    baseHueShift = 0.33;  // sickly green
    baseSat = 0.85;
    baseL = 0.12;
    waveAmp = 0.1;
    waveSpeed = 0.5;
    specStrength = 0.4;
    opacity = 0.88;
    emissiveStr = 0.25;
  } else {
    // Beautiful water — ensure hue always lands in cyan-blue-teal range
    // Instead of blindly shifting from palette hue, use a curated water hue
    const paletteH = palette.hue / 360;
    const rawWaterH = (paletteH + 0.55) % 1.0;
    // Clamp to 0.45-0.65 (cyan-blue range) — avoid greens, reds, yellows
    if (rawWaterH > 0.42 && rawWaterH < 0.72) {
      baseHueShift = 0.55;
    } else {
      // Remap to a safe beautiful water hue
      baseHueShift = 0.52 + (rawWaterH * 3.7 % 1) * 0.12;
    }
    baseSat = Math.max(s + 0.2, 0.45); // Ensure saturation
    baseL = 0.08;
    waveAmp = 0.4;
    waveSpeed = 0.8;
    specStrength = 0.8;
    opacity = 0.88;
    emissiveStr = 0.0;
  }
  
  return new THREE.ShaderMaterial({
    uniforms: {
      uDayProgress: { value: 0.5 },
      uHue: { value: h },
      uSat: { value: baseSat },
      uBaseHueShift: { value: baseHueShift },
      uBaseL: { value: baseL },
      uWaveAmp: { value: waveAmp },
      uWaveSpeed: { value: waveSpeed },
      uSpecStrength: { value: specStrength },
      uEmissive: { value: emissiveStr },
      uTime: { value: 0 },
      uSunPosition: { value: new THREE.Vector3(50, 30, -50) }
    },
    vertexShader: `
      ${NOISE_GLSL}
      uniform float uTime;
      uniform float uWaveAmp;
      uniform float uWaveSpeed;
      varying vec3 vWorldPosition;
      varying vec3 vNormal;
      varying float vFogDepth;
      
      void main() {
        vec3 pos = position;
        float spd = uWaveSpeed;
        float amp = uWaveAmp;
        float wave1 = sin(pos.x * 0.3 + uTime * spd) * cos(pos.y * 0.2 + uTime * spd * 0.75) * amp;
        float wave2 = sin(pos.x * 0.15 + pos.y * 0.1 + uTime * spd * 0.5) * amp * 1.5;
        float wave3 = snoise(pos.xy * 0.1 + uTime * spd * 0.25) * amp * 0.75;
        pos.z += wave1 + wave2 + wave3;
        
        float eps = 0.5;
        float hL = sin((pos.x - eps) * 0.3 + uTime * spd) * amp;
        float hR = sin((pos.x + eps) * 0.3 + uTime * spd) * amp;
        float hD = sin((pos.y - eps) * 0.2 + uTime * spd * 0.75) * amp;
        float hU = sin((pos.y + eps) * 0.2 + uTime * spd * 0.75) * amp;
        vNormal = normalize(vec3(hL - hR, hD - hU, 2.0));
        
        vec4 worldPos = modelMatrix * vec4(pos, 1.0);
        vWorldPosition = worldPos.xyz;
        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
        vFogDepth = -mvPosition.z;
        gl_Position = projectionMatrix * mvPosition;
      }
    `,
    fragmentShader: `
      uniform float uDayProgress;
      uniform float uHue;
      uniform float uSat;
      uniform float uBaseHueShift;
      uniform float uBaseL;
      uniform float uSpecStrength;
      uniform float uEmissive;
      uniform float uTime;
      uniform vec3 uSunPosition;
      
      varying vec3 vWorldPosition;
      varying vec3 vNormal;
      varying float vFogDepth;
      
      vec3 hsl2rgb(float h, float s, float l) {
        vec3 rgb = clamp(abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);
        return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));
      }
      
      void main() {
        float skyBright = sin(uDayProgress * 3.14159);
        float waterHue = mod(uHue + uBaseHueShift, 1.0);
        // For non-lava/toxic water, ensure hue stays in beautiful aquatic range
        if (uEmissive < 0.1) {
          if (waterHue < 0.42 || waterHue > 0.72) {
            waterHue = 0.48 + fract(waterHue * 3.7) * 0.14;
          }
        }
        float waterL = mix(uBaseL, uBaseL + 0.25, skyBright);
        vec3 waterColor = hsl2rgb(waterHue, uSat, waterL);
        
        // Emissive glow (lava, toxic)
        if (uEmissive > 0.0) {
          vec3 emissiveColor = hsl2rgb(waterHue, uSat, uBaseL + 0.3);
          waterColor += emissiveColor * uEmissive * (0.8 + sin(uTime * 0.5 + vWorldPosition.x * 0.1) * 0.2);
        }
        
        vec3 viewDir = normalize(cameraPosition - vWorldPosition);
        float fresnel = pow(1.0 - max(dot(viewDir, vNormal), 0.0), 3.0);
        
        vec3 skyColor = hsl2rgb(uHue, uSat * 0.6, mix(0.2, 0.55, skyBright));
        waterColor = mix(waterColor, skyColor, fresnel * 0.35);
        
        // Specular highlight
        vec3 lightDir = normalize(uSunPosition - vWorldPosition);
        vec3 halfVec = normalize(lightDir + viewDir);
        float spec = pow(max(dot(vNormal, halfVec), 0.0), 64.0);
        waterColor += vec3(1.0, 0.95, 0.8) * spec * skyBright * uSpecStrength;
        
        // Fog
        float fogFactor = smoothstep(40.0, 180.0, vFogDepth);
        vec3 fogColor = hsl2rgb(uHue, uSat * 0.3, mix(0.08, 0.35, skyBright));
        waterColor = mix(waterColor, fogColor, fogFactor * 0.6);
        
        gl_FragColor = vec4(waterColor, ${opacity.toFixed(2)});
      }
    `,
    transparent: true
  });
}
function createSun(starType) {
  const sunGroup = new THREE.Group();
  const sunColor = new THREE.Color(starType.color);
  
  // Just use a billboard sprite with radial gradient - no solid sphere needed
  const glowCanvas = document.createElement('canvas');
  glowCanvas.width = 128;
  glowCanvas.height = 128;
  const ctx = glowCanvas.getContext('2d');
  const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
  // Bright white/yellow core fading to star color then transparent
  gradient.addColorStop(0, '#ffffff');
  gradient.addColorStop(0.1, `rgba(${Math.floor(sunColor.r*255)}, ${Math.floor(sunColor.g*255)}, ${Math.floor(sunColor.b*255)}, 1.0)`);
  gradient.addColorStop(0.4, `rgba(${Math.floor(sunColor.r*255)}, ${Math.floor(sunColor.g*255)}, ${Math.floor(sunColor.b*255)}, 0.4)`);
  gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, 128, 128);
  
  const glowTexture = new THREE.CanvasTexture(glowCanvas);
  const glowMat = new THREE.SpriteMaterial({ 
    map: glowTexture, 
    transparent: true, 
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });
  const glowSprite = new THREE.Sprite(glowMat);
  glowSprite.scale.set(30, 30, 1);
  sunGroup.add(glowSprite);
  
  return sunGroup;
}

// Create particle systems
function createParticles(locationType, surface, temperature, palette, rng) {
  const particles = new THREE.Group();
  
  // Snow for frozen/tundra
  if (temperature === 'frozen' || surface === 'tundra') {
    const snowCount = 500;
    const snowGeo = new THREE.BufferGeometry();
    const snowPos = new Float32Array(snowCount * 3);
    const snowVel = new Float32Array(snowCount * 3);
    for (let i = 0; i < snowCount; i++) {
      snowPos[i * 3] = (rng() - 0.5) * 200;
      snowPos[i * 3 + 1] = rng() * 80;
      snowPos[i * 3 + 2] = (rng() - 0.5) * 100 - 20;
      snowVel[i * 3] = (rng() - 0.5) * 0.5;
      snowVel[i * 3 + 1] = -0.5 - rng() * 0.5;
      snowVel[i * 3 + 2] = (rng() - 0.5) * 0.3;
    }
    snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
    snowGeo.setAttribute('velocity', new THREE.BufferAttribute(snowVel, 3));
    const snowMat = new THREE.PointsMaterial({ color: 0xddeeff, size: 0.3, transparent: true, opacity: 0.7, blending: THREE.AdditiveBlending });
    const snow = new THREE.Points(snowGeo, snowMat);
    snow.userData.type = 'snow';
    particles.add(snow);
  }
  
  // Ash for volcanic
  if (surface === 'volcanic' || temperature === 'molten') {
    const ashCount = 300;
    const ashGeo = new THREE.BufferGeometry();
    const ashPos = new Float32Array(ashCount * 3);
    const ashVel = new Float32Array(ashCount * 3);
    for (let i = 0; i < ashCount; i++) {
      ashPos[i * 3] = (rng() - 0.5) * 200;
      ashPos[i * 3 + 1] = rng() * 60;
      ashPos[i * 3 + 2] = (rng() - 0.5) * 100 - 20;
      ashVel[i * 3] = (rng() - 0.5) * 0.8;
      ashVel[i * 3 + 1] = 0.3 + rng() * 0.5;
      ashVel[i * 3 + 2] = (rng() - 0.5) * 0.4;
    }
    ashGeo.setAttribute('position', new THREE.BufferAttribute(ashPos, 3));
    ashGeo.setAttribute('velocity', new THREE.BufferAttribute(ashVel, 3));
    const ashMat = new THREE.PointsMaterial({ color: 0xff6633, size: 0.4, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending });
    const ash = new THREE.Points(ashGeo, ashMat);
    ash.userData.type = 'ash';
    particles.add(ash);
  }
  
  // Bioluminescent particles
  if (surface === 'bioluminescent') {
    const bioCount = 300;
    const bioGeo = new THREE.BufferGeometry();
    const bioPos = new Float32Array(bioCount * 3);
    for (let i = 0; i < bioCount; i++) {
      bioPos[i * 3] = (rng() - 0.5) * 150;
      bioPos[i * 3 + 1] = rng() * 25 + 1;
      bioPos[i * 3 + 2] = (rng() - 0.5) * 80 - 10;
    }
    bioGeo.setAttribute('position', new THREE.BufferAttribute(bioPos, 3));
    const bioH = ((palette.hue + 160) % 360) / 360;
    const bioColor = new THREE.Color().setHSL(bioH, 0.85, 0.6);
    const bioMat = new THREE.PointsMaterial({ color: bioColor, size: 0.9, transparent: true, opacity: 0.85, blending: THREE.AdditiveBlending });
    const bio = new THREE.Points(bioGeo, bioMat);
    bio.userData.type = 'bio';
    particles.add(bio);
  }
  
  // Crystal sparkle particles
  if (surface === 'crystal' || surface === 'prismatic' || surface === 'glass') {
    const crystalCount = 250;
    const crystalGeo = new THREE.BufferGeometry();
    const crystalPos = new Float32Array(crystalCount * 3);
    for (let i = 0; i < crystalCount; i++) {
      crystalPos[i * 3] = (rng() - 0.5) * 160;
      crystalPos[i * 3 + 1] = rng() * 35 + 1;
      crystalPos[i * 3 + 2] = (rng() - 0.5) * 90 - 10;
    }
    crystalGeo.setAttribute('position', new THREE.BufferAttribute(crystalPos, 3));
    const sparkH = surface === 'prismatic' ? rng() : (palette.hue + 120) % 360 / 360;
    const sparkColor = new THREE.Color().setHSL(sparkH, 0.7, 0.85);
    const crystalMat = new THREE.PointsMaterial({ color: sparkColor, size: 0.5, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending });
    const crystal = new THREE.Points(crystalGeo, crystalMat);
    crystal.userData.type = 'crystal';
    particles.add(crystal);
  }
  
  // Rain for temperate/ocean worlds with moderate/dense atmosphere
  if ((temperature === 'temperate' || temperature === 'warm') && 
      (surface === 'moss' || surface === 'ocean' || surface === 'fungal' || surface === 'coral') &&
      locationType !== 'Asteroid Field') {
    const rainCount = 600;
    const rainGeo = new THREE.BufferGeometry();
    const rainPos = new Float32Array(rainCount * 3);
    const rainVel = new Float32Array(rainCount * 3);
    for (let i = 0; i < rainCount; i++) {
      rainPos[i * 3] = (rng() - 0.5) * 200;
      rainPos[i * 3 + 1] = rng() * 80;
      rainPos[i * 3 + 2] = (rng() - 0.5) * 100 - 20;
      rainVel[i * 3] = (rng() - 0.5) * 0.2;
      rainVel[i * 3 + 1] = -2.0 - rng() * 1.5;
      rainVel[i * 3 + 2] = (rng() - 0.5) * 0.1;
    }
    rainGeo.setAttribute('position', new THREE.BufferAttribute(rainPos, 3));
    rainGeo.setAttribute('velocity', new THREE.BufferAttribute(rainVel, 3));
    const rainMat = new THREE.PointsMaterial({ color: 0x99aabb, size: 0.15, transparent: true, opacity: 0.35 });
    const rain = new THREE.Points(rainGeo, rainMat);
    rain.userData.type = 'rain';
    particles.add(rain);
  }
  
  // Desert dust / sand particles
  if (surface === 'desert' || surface === 'sulphur' || surface === 'canyon') {
    const dustCount = 200;
    const dustGeo = new THREE.BufferGeometry();
    const dustPos = new Float32Array(dustCount * 3);
    const dustVel = new Float32Array(dustCount * 3);
    for (let i = 0; i < dustCount; i++) {
      dustPos[i * 3] = (rng() - 0.5) * 200;
      dustPos[i * 3 + 1] = rng() * 15 + 0.5;
      dustPos[i * 3 + 2] = (rng() - 0.5) * 100 - 10;
      dustVel[i * 3] = 0.5 + rng() * 1.0;
      dustVel[i * 3 + 1] = (rng() - 0.5) * 0.3;
      dustVel[i * 3 + 2] = (rng() - 0.5) * 0.5;
    }
    dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPos, 3));
    dustGeo.setAttribute('velocity', new THREE.BufferAttribute(dustVel, 3));
    const dustH = surface === 'sulphur' ? 0.14 : palette.hue / 360;
    const dustColor = new THREE.Color().setHSL(dustH, 0.4, 0.5);
    const dustMat = new THREE.PointsMaterial({ color: dustColor, size: 0.3, transparent: true, opacity: 0.25 });
    const dust = new THREE.Points(dustGeo, dustMat);
    dust.userData.type = 'dust';
    particles.add(dust);
  }
  
  // Fungal spores — rising gently
  if (surface === 'fungal') {
    const sporeCount = 180;
    const sporeGeo = new THREE.BufferGeometry();
    const sporePos = new Float32Array(sporeCount * 3);
    const sporeVel = new Float32Array(sporeCount * 3);
    for (let i = 0; i < sporeCount; i++) {
      sporePos[i * 3] = (rng() - 0.5) * 160;
      sporePos[i * 3 + 1] = rng() * 30;
      sporePos[i * 3 + 2] = (rng() - 0.5) * 80 - 10;
      sporeVel[i * 3] = (rng() - 0.5) * 0.15;
      sporeVel[i * 3 + 1] = 0.1 + rng() * 0.2;
      sporeVel[i * 3 + 2] = (rng() - 0.5) * 0.15;
    }
    sporeGeo.setAttribute('position', new THREE.BufferAttribute(sporePos, 3));
    sporeGeo.setAttribute('velocity', new THREE.BufferAttribute(sporeVel, 3));
    const sporeH = ((palette.hue + 100) % 360) / 360;
    const sporeColor = new THREE.Color().setHSL(sporeH, 0.5, 0.65);
    const sporeMat = new THREE.PointsMaterial({ color: sporeColor, size: 0.6, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending });
    const spore = new THREE.Points(sporeGeo, sporeMat);
    spore.userData.type = 'spore';
    particles.add(spore);
  }
  
  // Magnetic field lines — slowly orbiting points
  if (surface === 'magnetic') {
    const magCount = 120;
    const magGeo = new THREE.BufferGeometry();
    const magPos = new Float32Array(magCount * 3);
    for (let i = 0; i < magCount; i++) {
      const angle = (i / magCount) * Math.PI * 2;
      const radius = 30 + rng() * 20;
      magPos[i * 3] = Math.cos(angle) * radius;
      magPos[i * 3 + 1] = 20 + Math.sin(angle * 2) * 15 + rng() * 5;
      magPos[i * 3 + 2] = Math.sin(angle) * radius * 0.5 - 20;
    }
    magGeo.setAttribute('position', new THREE.BufferAttribute(magPos, 3));
    const magH = ((palette.hue + 180) % 360) / 360;
    const magColor = new THREE.Color().setHSL(magH, 0.7, 0.6);
    const magMat = new THREE.PointsMaterial({ color: magColor, size: 0.6, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending });
    const mag = new THREE.Points(magGeo, magMat);
    mag.userData.type = 'magnetic';
    particles.add(mag);
  }
  
  // Nebula particles
  if (locationType === 'Nebula Pocket') {
    const nebCount = 150;
    const nebGeo = new THREE.BufferGeometry();
    const nebPos = new Float32Array(nebCount * 3);
    const nebColors = new Float32Array(nebCount * 3);
    for (let i = 0; i < nebCount; i++) {
      nebPos[i * 3] = (rng() - 0.5) * 300;
      nebPos[i * 3 + 1] = rng() * 100;
      nebPos[i * 3 + 2] = (rng() - 0.5) * 200 - 50;
      const col = new THREE.Color().setHSL((palette.hue / 360 + (rng() - 0.5) * 0.3 + 1) % 1, 0.6, 0.5);
      nebColors[i * 3] = col.r;
      nebColors[i * 3 + 1] = col.g;
      nebColors[i * 3 + 2] = col.b;
    }
    nebGeo.setAttribute('position', new THREE.BufferAttribute(nebPos, 3));
    nebGeo.setAttribute('color', new THREE.BufferAttribute(nebColors, 3));
    const nebMat = new THREE.PointsMaterial({ size: 5, transparent: true, opacity: 0.3, vertexColors: true, blending: THREE.AdditiveBlending });
    const neb = new THREE.Points(nebGeo, nebMat);
    neb.userData.type = 'nebula';
    particles.add(neb);
  }
  
  // Asteroids
  if (locationType === 'Asteroid Field') {
    for (let i = 0; i < 40; i++) {
      const size = 1 + rng() * 4;
      const rockGeo = new THREE.DodecahedronGeometry(size, 0);
      const positions = rockGeo.attributes.position.array;
      for (let j = 0; j < positions.length; j += 3) {
        positions[j] *= 0.7 + rng() * 0.6;
        positions[j + 1] *= 0.7 + rng() * 0.6;
        positions[j + 2] *= 0.7 + rng() * 0.6;
      }
      rockGeo.computeVertexNormals();
      const rockMat = new THREE.MeshStandardMaterial({
        color: new THREE.Color().setHSL(palette.hue / 360, palette.sat / 100 * 0.4, 0.2),
        roughness: 0.9, metalness: 0.1
      });
      const rock = new THREE.Mesh(rockGeo, rockMat);
      rock.position.set((rng() - 0.5) * 200, rng() * 60 + 5, (rng() - 0.5) * 150 - 30);
      rock.rotation.set(rng() * Math.PI * 2, rng() * Math.PI * 2, rng() * Math.PI * 2);
      rock.userData.rotSpeed = { x: (rng() - 0.5) * 0.01, y: (rng() - 0.5) * 0.01, z: (rng() - 0.5) * 0.01 };
      rock.userData.type = 'asteroid';
      particles.add(rock);
    }
  }
  
  // Comet tail
  if (locationType === 'Comet') {
    const tailCount = 400;
    const tailGeo = new THREE.BufferGeometry();
    const tailPos = new Float32Array(tailCount * 3);
    for (let i = 0; i < tailCount; i++) {
      const t = rng();
      tailPos[i * 3] = 50 + t * 200 + (rng() - 0.5) * (20 + t * 40);
      tailPos[i * 3 + 1] = 30 + (rng() - 0.5) * (5 + t * 15);
      tailPos[i * 3 + 2] = (rng() - 0.5) * (5 + t * 20) - 30;
    }
    tailGeo.setAttribute('position', new THREE.BufferAttribute(tailPos, 3));
    const tailColor = new THREE.Color().setHSL((palette.hue / 360 + 0.5) % 1, 0.6, 0.7);
    const tailMat = new THREE.PointsMaterial({ color: tailColor, size: 0.6, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending });
    const tail = new THREE.Points(tailGeo, tailMat);
    tail.userData.type = 'cometTail';
    particles.add(tail);
  }
  
  // Ring system
  if (locationType === 'Ring System') {
    const ringCount = 800;
    const ringGeo = new THREE.BufferGeometry();
    const ringPos = new Float32Array(ringCount * 3);
    for (let i = 0; i < ringCount; i++) {
      const angle = rng() * Math.PI * 2;
      const radius = 40 + rng() * 30;
      ringPos[i * 3] = 80 + Math.cos(angle) * radius;
      ringPos[i * 3 + 1] = 35 + Math.sin(angle * 0.1) * 5 + (rng() - 0.5) * 3;
      ringPos[i * 3 + 2] = -60 + Math.sin(angle) * radius * 0.3;
    }
    ringGeo.setAttribute('position', new THREE.BufferAttribute(ringPos, 3));
    const ringMat = new THREE.PointsMaterial({ color: 0xccddff, size: 0.4, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending });
    const ring = new THREE.Points(ringGeo, ringMat);
    ring.userData.type = 'ring';
    particles.add(ring);
  }
  
  // Geothermal steam — slow rising wisps
  if (locationType === 'Geothermal Springs' || surface === 'sulphur') {
    const steamCount = 200;
    const steamGeo = new THREE.BufferGeometry();
    const steamPos = new Float32Array(steamCount * 3);
    const steamVel = new Float32Array(steamCount * 3);
    for (let i = 0; i < steamCount; i++) {
      steamPos[i * 3] = (rng() - 0.5) * 120;
      steamPos[i * 3 + 1] = rng() * 40;
      steamPos[i * 3 + 2] = (rng() - 0.5) * 60 - 15;
      steamVel[i * 3] = (rng() - 0.5) * 0.15;
      steamVel[i * 3 + 1] = 0.15 + rng() * 0.25;
      steamVel[i * 3 + 2] = (rng() - 0.5) * 0.15;
    }
    steamGeo.setAttribute('position', new THREE.BufferAttribute(steamPos, 3));
    steamGeo.setAttribute('velocity', new THREE.BufferAttribute(steamVel, 3));
    const steamMat = new THREE.PointsMaterial({ color: 0xccccdd, size: 1.2, transparent: true, opacity: 0.12, blending: THREE.AdditiveBlending });
    const steam = new THREE.Points(steamGeo, steamMat);
    steam.userData.type = 'steam';
    particles.add(steam);
  }
  
  // Floating debris for anti-gravity worlds
  if (locationType === 'Floating Mesa') {
    for (let i = 0; i < 25; i++) {
      const size = 0.5 + rng() * 2;
      const rockGeo = new THREE.DodecahedronGeometry(size, 0);
      const positions = rockGeo.attributes.position.array;
      for (let j = 0; j < positions.length; j += 3) {
        positions[j] *= 0.6 + rng() * 0.8;
        positions[j + 1] *= 0.4 + rng() * 0.3;
        positions[j + 2] *= 0.6 + rng() * 0.8;
      }
      rockGeo.computeVertexNormals();
      const rockMat = new THREE.MeshStandardMaterial({
        color: new THREE.Color().setHSL(palette.hue / 360, palette.sat / 100 * 0.3, 0.2),
        roughness: 0.85, metalness: 0.1
      });

  // Waterfall mist particles
  if (locationType === 'Waterfall Cliffs') {
    const mistCount = 400;
    const mistGeo = new THREE.BufferGeometry();
    const mistPos = new Float32Array(mistCount * 3);
    const mistVel = new Float32Array(mistCount * 3);
    for (let i = 0; i < mistCount; i++) {
      mistPos[i * 3] = (rng() - 0.5) * 120;
      mistPos[i * 3 + 1] = rng() * 30 + 2;
      mistPos[i * 3 + 2] = (rng() - 0.5) * 60 - 10;
      mistVel[i * 3] = (rng() - 0.5) * 0.3;
      mistVel[i * 3 + 1] = 0.1 + rng() * 0.3;
      mistVel[i * 3 + 2] = (rng() - 0.5) * 0.2;
    }
    mistGeo.setAttribute('position', new THREE.BufferAttribute(mistPos, 3));
    mistGeo.setAttribute('velocity', new THREE.BufferAttribute(mistVel, 3));
    const mistMat = new THREE.PointsMaterial({ color: 0xccddee, size: 1.5, transparent: true, opacity: 0.12, blending: THREE.AdditiveBlending });
    const mist = new THREE.Points(mistGeo, mistMat);
    mist.userData.type = 'steam';
    particles.add(mist);
    // Falling water droplets
    const dropCount = 300;
    const dropGeo = new THREE.BufferGeometry();
    const dropPos = new Float32Array(dropCount * 3);
    const dropVel = new Float32Array(dropCount * 3);
    for (let i = 0; i < dropCount; i++) {
      dropPos[i * 3] = (rng() - 0.5) * 80;
      dropPos[i * 3 + 1] = rng() * 60;
      dropPos[i * 3 + 2] = (rng() - 0.5) * 40 - 15;
      dropVel[i * 3] = (rng() - 0.5) * 0.1;
      dropVel[i * 3 + 1] = -1.5 - rng() * 2.0;
      dropVel[i * 3 + 2] = (rng() - 0.5) * 0.1;
    }
    dropGeo.setAttribute('position', new THREE.BufferAttribute(dropPos, 3));
    dropGeo.setAttribute('velocity', new THREE.BufferAttribute(dropVel, 3));
    const dropMat = new THREE.PointsMaterial({ color: 0xaabbcc, size: 0.2, transparent: true, opacity: 0.4 });
    const drops = new THREE.Points(dropGeo, dropMat);
    drops.userData.type = 'rain';
    particles.add(drops);
  }

  // Cavern crystal sparkle and dripping water
  if (locationType === 'Crystal Cavern' || surface === 'cavern') {
    const sparkCount = 350;
    const sparkGeo = new THREE.BufferGeometry();
    const sparkPos = new Float32Array(sparkCount * 3);
    for (let i = 0; i < sparkCount; i++) {
      sparkPos[i * 3] = (rng() - 0.5) * 140;
      sparkPos[i * 3 + 1] = rng() * 45 + 1;
      sparkPos[i * 3 + 2] = (rng() - 0.5) * 70 - 10;
    }
    sparkGeo.setAttribute('position', new THREE.BufferAttribute(sparkPos, 3));
    const sparkH = ((palette.hue + 140) % 360) / 360;
    const sparkColor = new THREE.Color().setHSL(sparkH, 0.75, 0.7);
    const sparkMat = new THREE.PointsMaterial({ color: sparkColor, size: 0.4, transparent: true, opacity: 0.85, blending: THREE.AdditiveBlending });
    const sparkles = new THREE.Points(sparkGeo, sparkMat);
    sparkles.userData.type = 'crystal';
    particles.add(sparkles);
  }

  // Abyssal bioluminescent particles + vent smoke
  if (locationType === 'Abyssal Trench' || surface === 'abyssal') {
    const abyssCount = 200;
    const abyssGeo = new THREE.BufferGeometry();
    const abyssPos = new Float32Array(abyssCount * 3);
    for (let i = 0; i < abyssCount; i++) {
      abyssPos[i * 3] = (rng() - 0.5) * 160;
      abyssPos[i * 3 + 1] = rng() * 20 + 1;
      abyssPos[i * 3 + 2] = (rng() - 0.5) * 80 - 10;
    }
    abyssGeo.setAttribute('position', new THREE.BufferAttribute(abyssPos, 3));
    const abyssColor = new THREE.Color().setHSL(0.55, 0.6, 0.5);
    const abyssMat = new THREE.PointsMaterial({ color: abyssColor, size: 0.7, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending });
    const abyssP = new THREE.Points(abyssGeo, abyssMat);
    abyssP.userData.type = 'bio';
    particles.add(abyssP);
    // Vent smoke rising
    const smokeCount = 150;
    const smokeGeo = new THREE.BufferGeometry();
    const smokePos = new Float32Array(smokeCount * 3);
    const smokeVel = new Float32Array(smokeCount * 3);
    for (let i = 0; i < smokeCount; i++) {
      smokePos[i * 3] = (rng() - 0.5) * 80;
      smokePos[i * 3 + 1] = rng() * 25;
      smokePos[i * 3 + 2] = (rng() - 0.5) * 40 - 15;
      smokeVel[i * 3] = (rng() - 0.5) * 0.1;
      smokeVel[i * 3 + 1] = 0.2 + rng() * 0.3;
      smokeVel[i * 3 + 2] = (rng() - 0.5) * 0.1;
    }
    smokeGeo.setAttribute('position', new THREE.BufferAttribute(smokePos, 3));
    smokeGeo.setAttribute('velocity', new THREE.BufferAttribute(smokeVel, 3));
    const smokeMat = new THREE.PointsMaterial({ color: 0x332222, size: 1.8, transparent: true, opacity: 0.08 });
    const smoke = new THREE.Points(smokeGeo, smokeMat);
    smoke.userData.type = 'steam';
    particles.add(smoke);
  }

  // Alien ruin energy motes
  if (locationType === 'Alien Necropolis' || surface === 'ruins') {
    const moteCount = 180;
    const moteGeo = new THREE.BufferGeometry();
    const motePos = new Float32Array(moteCount * 3);
    for (let i = 0; i < moteCount; i++) {
      motePos[i * 3] = (rng() - 0.5) * 140;
      motePos[i * 3 + 1] = rng() * 30 + 2;
      motePos[i * 3 + 2] = (rng() - 0.5) * 70 - 10;
    }
    moteGeo.setAttribute('position', new THREE.BufferAttribute(motePos, 3));
    const moteH = ((palette.hue + 60) % 360) / 360;
    const moteColor = new THREE.Color().setHSL(moteH, 0.6, 0.65);
    const moteMat = new THREE.PointsMaterial({ color: moteColor, size: 0.5, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending });
    const motes = new THREE.Points(moteGeo, moteMat);
    motes.userData.type = 'bio';
    particles.add(motes);
  }

  // Dune sand blown in wind
  if (locationType === 'Dune Sea') {
    const sandCount = 400;
    const sandGeo = new THREE.BufferGeometry();
    const sandPos = new Float32Array(sandCount * 3);
    const sandVel = new Float32Array(sandCount * 3);
    for (let i = 0; i < sandCount; i++) {
      sandPos[i * 3] = (rng() - 0.5) * 250;
      sandPos[i * 3 + 1] = rng() * 10 + 0.3;
      sandPos[i * 3 + 2] = (rng() - 0.5) * 120 - 10;
      sandVel[i * 3] = 0.8 + rng() * 1.5;
      sandVel[i * 3 + 1] = (rng() - 0.5) * 0.2;
      sandVel[i * 3 + 2] = (rng() - 0.5) * 0.3;
    }
    sandGeo.setAttribute('position', new THREE.BufferAttribute(sandPos, 3));
    sandGeo.setAttribute('velocity', new THREE.BufferAttribute(sandVel, 3));
    const sandH = palette.hue / 360;
    const sandColor = new THREE.Color().setHSL(sandH, 0.35, 0.55);
    const sandMat = new THREE.PointsMaterial({ color: sandColor, size: 0.2, transparent: true, opacity: 0.3 });
    const sand = new THREE.Points(sandGeo, sandMat);
    sand.userData.type = 'dust';
    particles.add(sand);
  }
      const rock = new THREE.Mesh(rockGeo, rockMat);
      rock.position.set((rng() - 0.5) * 140, 5 + rng() * 40, (rng() - 0.5) * 80 - 20);
      rock.rotation.set(rng() * Math.PI * 2, rng() * Math.PI * 2, rng() * Math.PI * 2);
      rock.userData.rotSpeed = { x: (rng() - 0.5) * 0.003, y: (rng() - 0.5) * 0.005, z: (rng() - 0.5) * 0.003 };
      rock.userData.type = 'floatingDebris';
      rock.userData.bobSpeed = 0.3 + rng() * 0.5;
      rock.userData.bobPhase = rng() * Math.PI * 2;
      rock.userData.baseY = rock.position.y;
      particles.add(rock);
    }
  }
  
  // Plasma energy motes
  if (surface === 'plasma') {
    const plasmaCount = 200;
    const plasmaGeo = new THREE.BufferGeometry();
    const plasmaPos = new Float32Array(plasmaCount * 3);
    const plasmaColors = new Float32Array(plasmaCount * 3);
    for (let i = 0; i < plasmaCount; i++) {
      plasmaPos[i * 3] = (rng() - 0.5) * 160;
      plasmaPos[i * 3 + 1] = rng() * 35 + 1;
      plasmaPos[i * 3 + 2] = (rng() - 0.5) * 80 - 10;
      const col = new THREE.Color().setHSL((palette.hue / 360 + rng() * 0.4) % 1, 0.8, 0.55 + rng() * 0.25);
      plasmaColors[i * 3] = col.r;
      plasmaColors[i * 3 + 1] = col.g;
      plasmaColors[i * 3 + 2] = col.b;
    }
    plasmaGeo.setAttribute('position', new THREE.BufferAttribute(plasmaPos, 3));
    plasmaGeo.setAttribute('color', new THREE.BufferAttribute(plasmaColors, 3));
    const plasmaMat = new THREE.PointsMaterial({ size: 0.7, transparent: true, opacity: 0.65, vertexColors: true, blending: THREE.AdditiveBlending });
    const plasma = new THREE.Points(plasmaGeo, plasmaMat);
    plasma.userData.type = 'plasma';
    particles.add(plasma);
  }
  
  // Mycelium spores — similar to fungal but denser and slower
  if (surface === 'mycelium') {
    const mycCount = 250;
    const mycGeo = new THREE.BufferGeometry();
    const mycPos = new Float32Array(mycCount * 3);
    const mycVel = new Float32Array(mycCount * 3);
    for (let i = 0; i < mycCount; i++) {
      mycPos[i * 3] = (rng() - 0.5) * 160;
      mycPos[i * 3 + 1] = rng() * 20;
      mycPos[i * 3 + 2] = (rng() - 0.5) * 80 - 10;
      mycVel[i * 3] = (rng() - 0.5) * 0.08;
      mycVel[i * 3 + 1] = 0.05 + rng() * 0.12;
      mycVel[i * 3 + 2] = (rng() - 0.5) * 0.08;
    }
    mycGeo.setAttribute('position', new THREE.BufferAttribute(mycPos, 3));
    mycGeo.setAttribute('velocity', new THREE.BufferAttribute(mycVel, 3));
    const mycH = ((palette.hue + 80) % 360) / 360;
    const mycColor = new THREE.Color().setHSL(mycH, 0.4, 0.55);
    const mycMat = new THREE.PointsMaterial({ color: mycColor, size: 0.4, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending });
    const myc = new THREE.Points(mycGeo, mycMat);
    myc.userData.type = 'spore';
    particles.add(myc);
  }
  
  // Salt crystal glints
  if (locationType === 'Salt Flats' || surface === 'salt') {
    const saltCount = 150;
    const saltGeo = new THREE.BufferGeometry();
    const saltPos = new Float32Array(saltCount * 3);
    for (let i = 0; i < saltCount; i++) {
      saltPos[i * 3] = (rng() - 0.5) * 200;
      saltPos[i * 3 + 1] = 0.3 + rng() * 2;
      saltPos[i * 3 + 2] = (rng() - 0.5) * 100 - 10;
    }
    saltGeo.setAttribute('position', new THREE.BufferAttribute(saltPos, 3));
    const saltMat = new THREE.PointsMaterial({ color: 0xfff8ee, size: 0.3, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending });
    const salt = new THREE.Points(saltGeo, saltMat);
    salt.userData.type = 'crystal';
    particles.add(salt);
  }
  
  return particles;
}

// Create gas giant for moons
function createGasGiant(palette, rng) {
  const giantGroup = new THREE.Group();
  const giantH = ((palette.hue + 40) % 360) / 360;
  
  const giantGeo = new THREE.SphereGeometry(60, 64, 48);
  const giantMat = new THREE.ShaderMaterial({
    uniforms: { uHue: { value: giantH }, uTime: { value: 0 } },
    vertexShader: `
      varying vec2 vUv;
      varying vec3 vNormal;
      void main() {
        vUv = uv;
        vNormal = normalize(normalMatrix * normal);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      ${NOISE_GLSL}
      uniform float uHue;
      uniform float uTime;
      varying vec2 vUv;
      varying vec3 vNormal;
      
      vec3 hsl2rgb(float h, float s, float l) {
        vec3 rgb = clamp(abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);
        return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));
      }
      
      void main() {
        float bands = sin(vUv.y * 30.0 + snoise(vec2(vUv.x * 3.0, vUv.y * 10.0 + uTime * 0.02)) * 2.0);
        bands = smoothstep(-0.3, 0.3, bands);
        float h = mix(uHue, mod(uHue + 0.05, 1.0), bands);
        vec3 color = hsl2rgb(h, 0.35 + bands * 0.1, 0.2 + bands * 0.1);
        float limb = dot(vNormal, vec3(0.0, 0.0, 1.0));
        color *= 0.5 + limb * 0.5;
        gl_FragColor = vec4(color, 1.0);
      }
    `
  });
  
  const giant = new THREE.Mesh(giantGeo, giantMat);
  giant.position.set(100, 40, -120);
  giantGroup.add(giant);
  return giantGroup;
}

// Initialize 3D landscape
function initLandscape3D(location, system) {
  if (!APP.three || !window.THREE_LOADED) {
    console.log('Three.js not available, using CSS fallback');
    return false;
  }
  
  const { scene, camera } = APP.three;
  
  // Clear previous scene
  while (scene.children.length > 0) {
    const obj = scene.children[0];
    if (obj.geometry) obj.geometry.dispose();
    if (obj.material) {
      if (obj.material.map) obj.material.map.dispose();
      obj.material.dispose();
    }
    scene.remove(obj);
  }
  APP.three.objects = {};
  APP.three.particles = null;
  
  const p = location.palette;
  const locType = location.type.name;
  const rng = mulberry32(location.seed + 12345);
  
  // Sky dome
  const skyGeo = new THREE.SphereGeometry(500, 32, 32);
  const skyMat = createSkyMaterial(p);
  const sky = new THREE.Mesh(skyGeo, skyMat);
  scene.add(sky);
  APP.three.objects.sky = sky;
  
  // Sun
  const sun = createSun(system.star.type);
  sun.position.set(60, 40, -100);
  scene.add(sun);
  APP.three.objects.sun = sun;
  
  // Terrain based on location type
  if (locType === 'Ocean World' || locType === 'Drifting Liquid Body') {
    // Pure ocean — no land
    const waterGeo = new THREE.PlaneGeometry(400, 200, 128, 64);
    const waterMat = createWaterMaterial(p);
    const water = new THREE.Mesh(waterGeo, waterMat);
    water.rotation.x = -Math.PI / 2;
    water.position.set(0, 0, -20);
    scene.add(water);
    APP.three.objects.water = water;
  } else if (locType !== 'Nebula Pocket') {
    // Get terrain params (may include water level for composite scenes)
    const tp = getTerrainParams(location.surface, locType);
    
    // Create terrain
    const terrainGeo = new THREE.PlaneGeometry(300, 150, 192, 96);
    const { minH, maxH } = displaceTerrain(terrainGeo, tp.terrainStyle, tp.terrainScale, tp.terrainFreq);
    const terrainMat = createTerrainMaterial(p, location.surface, location.temperature, locType);
    const terrain = new THREE.Mesh(terrainGeo, terrainMat);
    terrain.rotation.x = -Math.PI / 2;
    terrain.position.set(0, 0, -30);
    scene.add(terrain);
    APP.three.objects.terrain = terrain;
    
    // Gas Giant Moon — add the gas giant backdrop
    if (locType === 'Gas Giant Moon') {
      const giant = createGasGiant(p, rng);
      scene.add(giant);
      APP.three.objects.gasGiant = giant;
    }
    
    // Composite water plane — rivers, oceans, lava, toxic pools alongside terrain
    if (tp.waterLevel !== null) {
      const waterGeo = new THREE.PlaneGeometry(350, 180, 96, 48);
      const waterMat = createCompositeWaterMaterial(p, tp.waterType);
      const water = new THREE.Mesh(waterGeo, waterMat);
      water.rotation.x = -Math.PI / 2;
      // Position water at the specified level (in world Y, which is local Z)
      water.position.set(0, tp.waterLevel, -25);
      water.renderOrder = 1; // render water after terrain for correct transparency
      scene.add(water);
      APP.three.objects.water = water;
      
      console.log(`Composite water: type=${tp.waterType}, level=${tp.waterLevel}, terrain range=[${minH.toFixed(1)}, ${maxH.toFixed(1)}]`);
    }
  }
  
  // Particles
  const particles = createParticles(locType, location.surface, location.temperature, p, rng);
  scene.add(particles);
  APP.three.particles = particles;
  
  // Lighting
  const ambientColor = new THREE.Color().setHSL(p.hue / 360, p.sat / 100 * 0.3, 0.15);
  const ambient = new THREE.AmbientLight(ambientColor, 0.4);
  scene.add(ambient);
  APP.three.objects.ambient = ambient;
  
  const sunLight = new THREE.DirectionalLight(new THREE.Color(system.star.type.color), 1.0);
  sunLight.position.set(60, 40, -100);
  scene.add(sunLight);
  APP.three.objects.sunLight = sunLight;
  
  const hemiLight = new THREE.HemisphereLight(
    new THREE.Color().setHSL(p.hue / 360, p.sat / 100 * 0.5, 0.5),
    new THREE.Color().setHSL(p.hue / 360, p.sat / 100 * 0.3, 0.1),
    0.3
  );
  scene.add(hemiLight);
  APP.three.objects.hemiLight = hemiLight;
  
  // Fog
  const fogColor = new THREE.Color().setHSL(p.hue / 360, p.sat / 100 * 0.3, 0.1);
  scene.fog = new THREE.Fog(fogColor, 50, 280);
  
  // Activate 3D view
  APP.webglActive = true;
  document.body.classList.add('webgl-active');
  $('landscape-3d').classList.add('visible');
  $('landscape-3d').classList.remove('launching');
  $('landscape-3d').classList.add('landing-in');
  
  console.log(`3D Landscape initialized: ${locType}`);
  return true;
}

// Update 3D landscape
function updateLandscape3D() {
  if (!APP.webglActive || !APP.three) return;
  
  const { renderer, scene, camera, clock, objects, particles } = APP.three;
  const delta = clock.getDelta();
  const elapsed = clock.getElapsedTime();
  const dayP = APP.dayProgress;
  const skyBright = Math.sin(dayP * Math.PI);
  
  // Update sky
  if (objects.sky) {
    objects.sky.material.uniforms.uDayProgress.value = dayP;
    objects.sky.material.uniforms.uTime.value = elapsed;
  }
  
  // Update sun position - goes below horizon at night
  if (objects.sun) {
    const sunY = -30 + skyBright * 80; // Below horizon when skyBright=0, high when skyBright=1
    const sunX = 40 + dayP * 40;
    objects.sun.position.set(sunX, sunY, -100);
    objects.sun.children.forEach(child => {
      if (child.material.uniforms && child.material.uniforms.uTime) {
        child.material.uniforms.uTime.value = elapsed;
      }
    });
    // Fade out completely at night
    const sunOpacity = Math.max(0, skyBright * 1.2 - 0.1);
    // Fade the glow sprite
    if (objects.sun.children[0] && objects.sun.children[0].material) {
      objects.sun.children[0].material.opacity = sunOpacity;
    }
    objects.sun.visible = skyBright > 0.05;
  }
  
  if (objects.sunLight) {
    objects.sunLight.intensity = 0.2 + skyBright * 0.8;
    objects.sunLight.position.copy(objects.sun.position);
  }
  
  // Update terrain
  if (objects.terrain && objects.terrain.material.uniforms) {
    objects.terrain.material.uniforms.uDayProgress.value = dayP;
    objects.terrain.material.uniforms.uTime.value = elapsed;
    
    const p = APP.currentLocation.palette;
    const fogColor = new THREE.Color().setHSL(p.hue / 360, p.sat / 100 * 0.3, 0.05 + skyBright * 0.15);
    objects.terrain.material.uniforms.uFogColor.value = fogColor;
    scene.fog.color = fogColor;
  }
  
  if (objects.water && objects.water.material.uniforms) {
    objects.water.material.uniforms.uDayProgress.value = dayP;
    objects.water.material.uniforms.uTime.value = elapsed;
    objects.water.material.uniforms.uSunPosition.value.copy(objects.sun.position);
  }
  
  if (objects.gasGiant) {
    objects.gasGiant.children.forEach(child => {
      if (child.material.uniforms && child.material.uniforms.uTime) {
        child.material.uniforms.uTime.value = elapsed;
      }
    });
  }
  
  // Update particles
  if (particles) {
    particles.children.forEach(p => {
      if (p.userData.type === 'snow' || p.userData.type === 'ash' || p.userData.type === 'rain' || p.userData.type === 'dust' || p.userData.type === 'spore' || p.userData.type === 'steam') {
        const positions = p.geometry.attributes.position.array;
        const velocities = p.geometry.attributes.velocity ? p.geometry.attributes.velocity.array : null;
        if (velocities) {
          for (let i = 0; i < positions.length; i += 3) {
            positions[i] += velocities[i] * delta * 20;
            positions[i + 1] += velocities[i + 1] * delta * 20;
            positions[i + 2] += velocities[i + 2] * delta * 20;
            // Wrap around
            if (p.userData.type === 'rain') {
              if (positions[i + 1] < -2) {
                positions[i] = (Math.random() - 0.5) * 200;
                positions[i + 1] = 80;
                positions[i + 2] = (Math.random() - 0.5) * 100 - 20;
              }
            } else if (p.userData.type === 'dust') {
              if (positions[i] > 100) positions[i] = -100;
              if (positions[i + 1] < 0) positions[i + 1] = 0.5;
              if (positions[i + 1] > 16) positions[i + 1] = 0.5;
            } else if (p.userData.type === 'spore') {
              if (positions[i + 1] > 35) {
                positions[i] = (Math.random() - 0.5) * 160;
                positions[i + 1] = 0;
                positions[i + 2] = (Math.random() - 0.5) * 80 - 10;
              }
            } else if (p.userData.type === 'steam') {
              if (positions[i + 1] > 45) {
                positions[i] = (Math.random() - 0.5) * 120;
                positions[i + 1] = 0;
                positions[i + 2] = (Math.random() - 0.5) * 60 - 15;
              }
            } else if (positions[i + 1] < -5 || positions[i + 1] > 80) {
              positions[i] = (Math.random() - 0.5) * 200;
              positions[i + 1] = p.userData.type === 'snow' ? 80 : 0;
              positions[i + 2] = (Math.random() - 0.5) * 100 - 20;
            }
          }
          p.geometry.attributes.position.needsUpdate = true;
        }
      }
      if (p.userData.type === 'bio') {
        p.material.opacity = (0.4 + Math.sin(elapsed * 2) * 0.45) * (1 - skyBright);
      }
      if (p.userData.type === 'crystal') {
        // Sparkle effect — gentle during day, more visible at night
        const crystalNight = 1 - skyBright;
        // Slow gentle shimmer during day, more pronounced at night
        const dayOpacity = 0.12 + Math.sin(elapsed * 0.8) * 0.06;
        const nightOpacity = 0.3 + Math.abs(Math.sin(elapsed * 2.5)) * 0.5;
        p.material.opacity = dayOpacity * skyBright + nightOpacity * crystalNight;
        const daySize = 0.25 + Math.sin(elapsed * 0.6) * 0.05;
        const nightSize = 0.3 + Math.abs(Math.sin(elapsed * 3.0)) * 0.35;
        p.material.size = daySize * skyBright + nightSize * crystalNight;
      }
      if (p.userData.type === 'magnetic') {
        // Slow orbit
        p.rotation.y += delta * 0.15;
        p.material.opacity = 0.3 + Math.sin(elapsed * 1.5) * 0.3;
      }
      if (p.userData.type === 'rain') {
        // Rain more visible at day, less at night
        p.material.opacity = 0.15 + skyBright * 0.25;
      }
      if (p.userData.type === 'asteroid') {
        p.rotation.x += p.userData.rotSpeed.x;
        p.rotation.y += p.userData.rotSpeed.y;
        p.rotation.z += p.userData.rotSpeed.z;
      }
      if (p.userData.type === 'floatingDebris') {
        p.rotation.x += p.userData.rotSpeed.x;
        p.rotation.y += p.userData.rotSpeed.y;
        p.rotation.z += p.userData.rotSpeed.z;
        // Gentle bobbing
        p.position.y = p.userData.baseY + Math.sin(elapsed * p.userData.bobSpeed + p.userData.bobPhase) * 2;
      }
      if (p.userData.type === 'plasma') {
        // Plasma pulses — subtle during day, vivid at night
        const plasmaNight = 1 - skyBright;
        const dayPlasma = 0.1 + Math.sin(elapsed * 1.0) * 0.04;
        const nightPlasma = 0.3 + Math.sin(elapsed * 3.0) * 0.2 + Math.sin(elapsed * 5.5) * 0.12;
        p.material.opacity = dayPlasma * skyBright + nightPlasma * plasmaNight;
        const daySz = 0.4;
        const nightSz = 0.5 + Math.abs(Math.sin(elapsed * 2.5)) * 0.35;
        p.material.size = daySz * skyBright + nightSz * plasmaNight;
      }
      if (p.userData.type === 'steam') {
        // Steam fades more during day, slightly visible at night
        p.material.opacity = 0.06 + skyBright * 0.08;
      }
    });
  }
  
  if (objects.ambient) {
    objects.ambient.intensity = 0.2 + skyBright * 0.3;
  }
  
  renderer.render(scene, camera);
}

// Cleanup 3D landscape
function cleanupLandscape3D() {
  if (!APP.three) return;
  
  APP.webglActive = false;
  document.body.classList.remove('webgl-active');
  
  $('landscape-3d').classList.remove('landing-in', 'visible');
  $('landscape-3d').classList.add('launching');
  
  setTimeout(() => {
    $('landscape-3d').classList.remove('launching');
  }, 1300);
}

// ═══════════════════════════════════════════
// STAR TYPES
// ═══════════════════════════════════════════
const STAR_TYPES = [
  { name:'Red Dwarf', color:'#ff6644', glow:'rgba(255,80,40,0.3)', temp:'warm', planets:[1,3], weight:35 },
  { name:'Yellow Star', color:'#ffe088', glow:'rgba(255,224,120,0.25)', temp:'balanced', planets:[3,7], weight:28 },
  { name:'Blue Giant', color:'#88bbff', glow:'rgba(100,160,255,0.3)', temp:'intense', planets:[2,5], weight:12 },
  { name:'White Dwarf', color:'#ddeeff', glow:'rgba(200,220,255,0.2)', temp:'cold', planets:[1,3], weight:9 },
  { name:'Binary System', color:'#ffcc77', glow:'rgba(255,180,100,0.25)', temp:'shifting', planets:[2,5], weight:5 },
  { name:'Orange Giant', color:'#ffaa55', glow:'rgba(255,160,60,0.3)', temp:'warm', planets:[3,6], weight:7 },
  { name:'Neutron Star', color:'#ccddff', glow:'rgba(180,200,255,0.4)', temp:'extreme', planets:[1,2], weight:4 },
];

function pickStarType(rng) {
  const r = rng() * 100;
  let acc = 0;
  for (const t of STAR_TYPES) {
    acc += t.weight;
    if (r < acc) return t;
  }
  return STAR_TYPES[0];
}

// ═══════════════════════════════════════════
// LOCATION TYPES
// ═══════════════════════════════════════════
const SURFACE_TYPES = [
  'desert', 'crystal', 'volcanic', 'tundra', 'fungal', 'canyon', 'ocean',
  'bioluminescent', 'metallic', 'glass', 'moss', 'storm', 'ancient',
  'coral', 'prismatic', 'sulphur', 'magnetic',
  'obsidian', 'salt', 'mycelium', 'plasma', 'bone',
  'sandstone', 'cavern', 'abyssal', 'ruins', 'basalt'
];

const LOCATION_TYPES = [
  { name:'Terrestrial World', scanner:'Terrestrial world', weight:30, rare:false },
  { name:'Gas Giant Moon', scanner:'Gas giant moon', weight:12, rare:false },
  { name:'Ocean World', scanner:'Unbound liquid body', weight:9, rare:false },
  { name:'Asteroid Field', scanner:'Asteroid cluster', weight:10, rare:false },
  { name:'Tidally Locked World', scanner:'Tidally locked world', weight:7, rare:false },
  { name:'Ancient Ruins', scanner:'Anomalous structure — origin unknown', weight:5, rare:true },
  { name:'Nebula Pocket', scanner:'Nebula pocket — suspended gas cloud', weight:4, rare:true },
  { name:'Ring System', scanner:'Ring system — ice and dust', weight:5, rare:false },
  { name:'Comet', scanner:'Active comet — perihelion approach', weight:3, rare:true },
  { name:'Drifting Liquid Body', scanner:'Unbound liquid body — low gravity', weight:3, rare:true },
  { name:'Crystalline Spire', scanner:'Crystalline megastructure — resonance detected', weight:3, rare:true },
  { name:'Volcanic Forge', scanner:'Hyperactive volcanic body — extreme tidal stress', weight:5, rare:false },
  { name:'Frozen Abyss', scanner:'Deep ice body — subsurface ocean probable', weight:4, rare:false },
  { name:'Bioluminescent Jungle', scanner:'Dense bioluminescent canopy — complex organics', weight:3, rare:true },
  { name:'Coastal World', scanner:'Coastal terrain — fjords and sea cliffs detected', weight:7, rare:false },
  { name:'River Delta', scanner:'River system — active hydrology', weight:6, rare:false },
  { name:'Island Chain', scanner:'Archipelago — volcanic island formation', weight:5, rare:false },
  { name:'Caldera World', scanner:'Massive caldera — magma chamber active', weight:3, rare:true },
  { name:'Storm Peaks', scanner:'Extreme topography — violent atmospheric activity', weight:4, rare:false },
  { name:'Glacial Shelf', scanner:'Glacial cascade — crevasse network detected', weight:4, rare:false },
  { name:'Pillar Forest', scanner:'Stone pillar formation — extreme vertical erosion', weight:4, rare:false },
  { name:'Sinkhole World', scanner:'Karst terrain — subsurface cavities detected', weight:3, rare:true },
  { name:'Salt Flats', scanner:'Evaporite basin — crystalline mineral plain', weight:5, rare:false },
  { name:'Geothermal Springs', scanner:'Hydrothermal activity — mineral-rich outflow', weight:4, rare:false },
  { name:'Badlands', scanner:'Eroded strata — layered sediment exposed', weight:5, rare:false },
  { name:'Floating Mesa', scanner:'Anomalous geology — anti-gravity mineral deposits', weight:2, rare:true },
  { name:'Waterfall Cliffs', scanner:'Cascade system — massive vertical hydrology', weight:5, rare:false },
  { name:'Grand Plateau', scanner:'Elevated plateau — sheer cliff perimeter', weight:5, rare:false },
  { name:'Towering Cliffs', scanner:'Vertical sea cliffs — extreme coastal erosion', weight:4, rare:false },
  { name:'Alien Necropolis', scanner:'⚠ Megastructure ruins — non-natural geometry confirmed', weight:2, rare:true },
  { name:'Crystal Cavern', scanner:'Subsurface void — crystalline resonance detected', weight:3, rare:true },
  { name:'Abyssal Trench', scanner:'Deep submarine rift — hydrothermal activity', weight:3, rare:true },
  { name:'Dune Sea', scanner:'Massive erg — complex dune morphology', weight:5, rare:false },
  { name:'Chimney Spires', scanner:'Hoodoo formation — extreme differential erosion', weight:4, rare:false },
];

function pickLocationType(rng, isVoid) {
  // In voids, rare locations slightly more common
  const types = LOCATION_TYPES.map(t => ({
    ...t,
    weight: t.rare && isVoid ? t.weight * 2 : t.weight
  }));
  const total = types.reduce((s, t) => s + t.weight, 0);
  const r = rng() * total;
  let acc = 0;
  for (const t of types) {
    acc += t.weight;
    if (r < acc) return t;
  }
  return types[0];
}

// ═══════════════════════════════════════════
// STAR GENERATION
// ═══════════════════════════════════════════
const CELL_SIZE = 400;

function getStarsInView() {
  const cx = APP.camera.x, cy = APP.camera.y;
  const hw = APP.width / 2 + CELL_SIZE;
  const hh = APP.height / 2 + CELL_SIZE;

  const minCellX = Math.floor((cx - hw) / CELL_SIZE);
  const maxCellX = Math.floor((cx + hw) / CELL_SIZE);
  const minCellY = Math.floor((cy - hh) / CELL_SIZE);
  const maxCellY = Math.floor((cy + hh) / CELL_SIZE);

  const visible = [];
  for (let cellX = minCellX; cellX <= maxCellX; cellX++) {
    for (let cellY = minCellY; cellY <= maxCellY; cellY++) {
      const key = `${cellX},${cellY}`;
      if (!APP.stars.has(key)) {
        APP.stars.set(key, generateCellStars(cellX, cellY));
      }
      visible.push(...APP.stars.get(key));
    }
  }

  // Prune distant cells to cap memory (~500 cells max)
  if (APP.stars.size > 500) {
    const camCellX = Math.floor(cx / CELL_SIZE);
    const camCellY = Math.floor(cy / CELL_SIZE);
    for (const key of APP.stars.keys()) {
      const [kx, ky] = key.split(',').map(Number);
      if (Math.abs(kx - camCellX) > 15 || Math.abs(ky - camCellY) > 15) {
        APP.stars.delete(key);
      }
    }
  }

  return visible;
}

function generateCellStars(cellX, cellY) {
  const worldX = cellX * CELL_SIZE;
  const worldY = cellY * CELL_SIZE;

  // Large-scale density from noise
  const density = (fbm(cellX * 0.008, cellY * 0.008, 3) + 1) / 2;
  const nebulaVal = (fbm(cellX * 0.005 + 100, cellY * 0.005 + 100, 2) + 1) / 2;
  const isVoid = density < 0.25;
  const isNebula = nebulaVal > 0.65;
  const isDense = density > 0.7;

  const seed = hashCoords(cellX, cellY);
  const rng = mulberry32(seed);

  // Number of stars based on density
  const baseCount = isDense ? 4 : isVoid ? 0 : 2;
  const count = Math.max(0, baseCount + (rng() < density ? 1 : 0));

  const stars = [];
  for (let i = 0; i < count; i++) {
    const sx = worldX + rng() * CELL_SIZE;
    const sy = worldY + rng() * CELL_SIZE;
    const starSeed = hashCoords(Math.round(sx), Math.round(sy));
    const starRng = mulberry32(starSeed);
    const type = pickStarType(starRng);
    const brightness = 0.5 + starRng() * 0.5;
    const size = type.name === 'Blue Giant' ? 2.5 + starRng() * 1.5 :
                 type.name === 'Red Dwarf' ? 1 + starRng() * 0.8 :
                 1.5 + starRng() * 1;

    stars.push({
      x: sx, y: sy,
      seed: starSeed,
      type, brightness, size,
      isVoid, isNebula,
      cellX, cellY
    });
  }
  return stars;
}

// ═══════════════════════════════════════════
// SYSTEM GENERATION
// ═══════════════════════════════════════════
function generateSystem(star) {
  const rng = mulberry32(star.seed + 7777);
  const type = star.type;
  const [minP, maxP] = type.planets;
  const numLocations = minP + Math.floor(rng() * (maxP - minP + 1));

  const locations = [];
  for (let i = 0; i < numLocations; i++) {
    const locSeed = hashCoords(star.seed, i + 1);
    const locRng = mulberry32(locSeed);
    const locType = pickLocationType(locRng, star.isVoid);

    // Orbital distance
    const orbit = 0.2 + (i / numLocations) * 0.7 + locRng() * 0.08;
    // Temperature from orbit
    const tempClasses = ['molten','warm','temperate','cold','frozen'];
    const tempIdx = Math.min(4, Math.floor(orbit * 5));
    const temperature = tempClasses[tempIdx];
    // Atmosphere
    const atmos = ['none','thin','moderate','dense','exotic'];
    const atmosType = atmos[Math.floor(locRng() * atmos.length)];
    // Surface
    const surface = SURFACE_TYPES[Math.floor(locRng() * SURFACE_TYPES.length)];
    // Age
    const age = locRng(); // 0=young, 1=ancient

    // Scanner description
    const atmosDesc = atmosType === 'none' ? 'no atmosphere' :
                      atmosType === 'exotic' ? 'exotic atmosphere' :
                      `${atmosType} atmosphere`;
    const scannerDesc = `${locType.scanner} — ${temperature} — ${atmosDesc}`;

    // Orbital parameters for system view
    const orbitAngle = locRng() * Math.PI * 2;
    const orbitSpeed = 0.0002 + locRng() * 0.0005;
    const orbitEcc = 0.05 + locRng() * 0.15;

    // Visual size in system view
    const visualSize = locType.name.includes('Moon') || locType.name === 'Comet' ? 6 + locRng() * 4 :
                       locType.name === 'Asteroid Field' ? 5 + locRng() * 3 :
                       locType.name.includes('Ruins') ? 4 + locRng() * 3 :
                       8 + locRng() * 8;

    // Color palette for this location
    const palette = generatePalette(locRng, temperature, surface, atmosType, star.type);
    
    // Add modifier info to scanner description for rare worlds
    const modSuffix = palette.modifier ? ` — ⟡ ${palette.modifier.desc}` : '';
    const fullScannerDesc = scannerDesc + modSuffix;

    const catalogId = `${String.fromCharCode(65 + (star.seed % 26))}${String.fromCharCode(65 + ((star.seed >> 5) % 26))}-${(star.seed % 9000) + 1000}${String.fromCharCode(97 + i)}`;

    locations.push({
      seed: locSeed,
      type: locType,
      orbit, temperature, atmosphere: atmosType, surface, age,
      scannerDesc: fullScannerDesc, catalogId,
      orbitAngle, orbitSpeed, orbitEcc, visualSize,
      palette,
      name: null, // user names it
      file: null,
    });
  }

  return {
    star,
    locations,
    key: `${star.seed}`
  };
}

// ═══════════════════════════════════════════
// CURATED PALETTE INGREDIENTS
// ═══════════════════════════════════════════

// Sky Families — curated zenith/horizon day+night gradients
// Each: { name, day: {zenith:[h,s,l], horizon:[h,s,l]}, night: {zenith:[h,s,l], horizon:[h,s,l]} }
const SKY_FAMILIES = [
  { name:'Cerulean Classic', tags:['temperate','ocean','moss'],
    day: { zenith:[215,62,58], horizon:[25,55,72] },
    night: { zenith:[220,45,6], horizon:[200,30,10] } },
  { name:'Lavender Haze', tags:['crystal','glass','ancient'],
    day: { zenith:[268,38,62], horizon:[340,42,68] },
    night: { zenith:[280,35,5], horizon:[310,25,8] } },
  { name:'Burnt Atmosphere', tags:['desert','canyon','volcanic'],
    day: { zenith:[28,48,52], horizon:[15,58,58] },
    night: { zenith:[350,30,6], horizon:[10,25,9] } },
  { name:'Polar Clarity', tags:['tundra','frozen','glass'],
    day: { zenith:[200,30,75], horizon:[205,35,62] },
    night: { zenith:[215,50,3], horizon:[210,35,6] } },
  { name:'Emerald Canopy', tags:['fungal','moss','bioluminescent'],
    day: { zenith:[155,32,45], horizon:[165,35,50] },
    night: { zenith:[155,40,4], horizon:[130,30,7] } },
  { name:'Rose Gold Dusk', tags:['coral','ancient','desert'],
    day: { zenith:[210,35,60], horizon:[5,50,65] },
    night: { zenith:[240,30,5], horizon:[330,20,8] } },
  { name:'Arctic Steel', tags:['metallic','tundra','storm'],
    day: { zenith:[210,18,62], horizon:[215,22,52] },
    night: { zenith:[215,25,4], horizon:[220,20,7] } },
  { name:'Amber Furnace', tags:['volcanic','sulphur','molten'],
    day: { zenith:[35,55,45], horizon:[15,65,50] },
    night: { zenith:[15,40,5], horizon:[25,35,8] } },
  { name:'Twilight Orchid', tags:['magnetic','crystal','prismatic'],
    day: { zenith:[270,45,55], horizon:[300,50,58] },
    night: { zenith:[275,50,4], horizon:[290,35,7] } },
  { name:'Sage Steppe', tags:['moss','ancient','canyon'],
    day: { zenith:[192,22,52], horizon:[35,32,58] },
    night: { zenith:[195,25,5], horizon:[180,18,8] } },
  { name:'Cobalt Deep', tags:['ocean','storm','metallic'],
    day: { zenith:[225,55,48], horizon:[210,45,55] },
    night: { zenith:[230,55,3], horizon:[225,40,6] } },
  { name:'Peach Cloud', tags:['coral','glass','temperate'],
    day: { zenith:[200,30,65], horizon:[15,45,72] },
    night: { zenith:[225,28,5], horizon:[350,22,8] } },
  { name:'Chalk & Thistle', tags:['tundra','crystal','ancient'],
    day: { zenith:[250,18,72], horizon:[280,25,65] },
    night: { zenith:[260,22,5], horizon:[270,18,8] } },
  { name:'Monsoon Jade', tags:['fungal','ocean','bioluminescent'],
    day: { zenith:[178,42,43], horizon:[190,40,48] },
    night: { zenith:[180,45,4], horizon:[165,35,7] } },
  { name:'Bleached Expanse', tags:['salt','bone','desert'],
    day: { zenith:[200,15,78], horizon:[40,25,75] },
    night: { zenith:[210,18,5], horizon:[200,12,8] } },
  { name:'Obsidian Veil', tags:['obsidian','volcanic','metallic'],
    day: { zenith:[275,22,40], horizon:[300,18,35] },
    night: { zenith:[280,30,3], horizon:[290,25,5] } },
  { name:'Living Network', tags:['mycelium','fungal','moss'],
    day: { zenith:[175,30,42], horizon:[195,28,48] },
    night: { zenith:[170,22,5], horizon:[185,18,7] } },
  { name:'Ion Storm', tags:['plasma','magnetic','storm'],
    day: { zenith:[240,50,52], horizon:[280,55,48] },
    night: { zenith:[250,60,5], horizon:[275,45,8] } },
  { name:'Sunken Depths', tags:['abyssal','cavern','ocean'],
    day: { zenith:[210,55,28], horizon:[195,50,32] },
    night: { zenith:[215,60,3], horizon:[200,45,5] } },
  { name:'Ruin Amber', tags:['ruins','ancient','sandstone'],
    day: { zenith:[220,28,55], horizon:[32,48,58] },
    night: { zenith:[230,25,5], horizon:[20,20,8] } },
  { name:'Cavern Glow', tags:['cavern','crystal','bioluminescent'],
    day: { zenith:[260,30,22], horizon:[280,35,28] },
    night: { zenith:[265,40,4], horizon:[275,30,6] } },
  { name:'Dune Gold', tags:['sandstone','desert','canyon'],
    day: { zenith:[35,42,58], horizon:[20,55,62] },
    night: { zenith:[30,28,5], horizon:[15,22,8] } },
  { name:'Columnar Basalt', tags:['basalt','volcanic','storm'],
    day: { zenith:[218,25,48], horizon:[225,30,42] },
    night: { zenith:[222,32,4], horizon:[228,25,6] } },
];

// Ground Families — terrain color progressions [far, mid, near] as [h,s,l]
const GROUND_FAMILIES = [
  { name:'Red Sandstone', tags:['desert','canyon','ancient'],
    day: { far:[15,52,35], mid:[12,48,28], near:[10,42,22] },
    night: { far:[15,35,8], mid:[12,28,6], near:[10,22,4] } },
  { name:'Obsidian Shore', tags:['volcanic','metallic','storm'],
    day: { far:[250,18,22], mid:[260,22,16], near:[255,15,12] },
    night: { far:[250,25,5], mid:[255,20,3], near:[260,15,2] } },
  { name:'Pale Dunes', tags:['desert','glass','tundra'],
    day: { far:[38,35,55], mid:[35,30,45], near:[32,25,38] },
    night: { far:[38,20,10], mid:[35,15,7], near:[32,12,5] } },
  { name:'Living Stone', tags:['moss','fungal','ancient'],
    day: { far:[130,22,28], mid:[125,25,22], near:[120,20,18] },
    night: { far:[130,18,6], mid:[125,15,4], near:[120,12,3] } },
  { name:'Volcanic Glass', tags:['volcanic','sulphur','metallic'],
    day: { far:[8,35,18], mid:[5,40,14], near:[2,30,10] },
    night: { far:[8,50,5], mid:[5,55,4], near:[0,45,3] } },
  { name:'Ivory Coast', tags:['coral','ocean','glass'],
    day: { far:[42,28,50], mid:[38,32,40], near:[35,25,32] },
    night: { far:[42,18,9], mid:[38,15,6], near:[35,12,4] } },
  { name:'Frozen Slate', tags:['tundra','crystal','storm'],
    day: { far:[210,20,38], mid:[215,25,30], near:[218,18,24] },
    night: { far:[210,28,6], mid:[215,22,4], near:[218,18,3] } },
  { name:'Deep Moss', tags:['moss','fungal','bioluminescent'],
    day: { far:[115,35,22], mid:[120,40,17], near:[125,30,13] },
    night: { far:[115,30,5], mid:[120,25,3], near:[125,20,2] } },
  { name:'Rust Iron', tags:['metallic','canyon','desert'],
    day: { far:[18,42,28], mid:[15,38,22], near:[12,35,17] },
    night: { far:[18,30,6], mid:[15,25,4], near:[12,20,3] } },
  { name:'Crystal Field', tags:['crystal','prismatic','glass'],
    day: { far:[260,25,35], mid:[265,30,28], near:[270,22,22] },
    night: { far:[260,35,6], mid:[265,30,4], near:[270,25,3] } },
  { name:'Warm Basalt', tags:['volcanic','ancient','canyon'],
    day: { far:[25,30,24], mid:[20,35,19], near:[18,28,15] },
    night: { far:[25,22,5], mid:[20,18,4], near:[18,15,3] } },
  { name:'Emerald Depths', tags:['ocean','bioluminescent','fungal'],
    day: { far:[175,40,28], mid:[180,45,22], near:[185,35,18] },
    night: { far:[175,35,5], mid:[180,30,4], near:[185,25,3] } },
  { name:'Salt Basin', tags:['salt','bone','desert'],
    day: { far:[40,12,62], mid:[38,10,55], near:[35,8,48] },
    night: { far:[40,10,10], mid:[38,8,7], near:[35,6,5] } },
  { name:'Dark Glass', tags:['obsidian','volcanic','crystal'],
    day: { far:[280,15,16], mid:[285,18,12], near:[275,12,9] },
    night: { far:[280,22,4], mid:[285,18,3], near:[275,15,2] } },
  { name:'Web Floor', tags:['mycelium','fungal','ancient'],
    day: { far:[45,22,26], mid:[50,28,20], near:[55,20,16] },
    night: { far:[45,16,5], mid:[50,14,4], near:[55,12,3] } },
  { name:'Charged Ground', tags:['plasma','magnetic','storm'],
    day: { far:[250,30,22], mid:[260,35,18], near:[245,25,14] },
    night: { far:[250,45,5], mid:[260,40,4], near:[245,35,3] } },
  { name:'Ossuary', tags:['bone','ancient','desert'],
    day: { far:[35,18,38], mid:[30,15,32], near:[28,12,26] },
    night: { far:[35,12,7], mid:[30,10,5], near:[28,8,4] } },
  { name:'Ruin Foundation', tags:['ruins','ancient','sandstone'],
    day: { far:[32,22,30], mid:[28,25,24], near:[25,20,20] },
    night: { far:[32,15,6], mid:[28,12,4], near:[25,10,3] } },
  { name:'Cave Floor', tags:['cavern','crystal','abyssal'],
    day: { far:[250,18,18], mid:[255,22,14], near:[248,15,11] },
    night: { far:[250,25,5], mid:[255,20,3], near:[248,18,2] } },
  { name:'Abyssal Silt', tags:['abyssal','ocean','storm'],
    day: { far:[195,20,14], mid:[200,24,11], near:[205,18,8] },
    night: { far:[195,28,4], mid:[200,22,3], near:[205,18,2] } },
  { name:'Warm Sandstone', tags:['sandstone','desert','canyon'],
    day: { far:[25,45,42], mid:[20,42,35], near:[18,38,28] },
    night: { far:[25,28,8], mid:[20,22,5], near:[18,18,4] } },
  { name:'Basalt Column', tags:['basalt','volcanic','metallic'],
    day: { far:[220,15,20], mid:[225,18,16], near:[218,12,13] },
    night: { far:[220,22,5], mid:[225,18,3], near:[218,15,2] } },
];

// Night Signatures — what makes night *special* on this world
const NIGHT_SIGNATURES = [
  { name:'Ember Glow', tags:['volcanic','desert','canyon','sulphur','molten'],
    groundLightBoost: 0.08, groundHueShift: -5,
    groundSatBoost: 12, skyWarmth: 0.12,
    glowColor:[15,55,30], glowIntensity: 0.15,
    frostTint:[30,20,12] },
  { name:'Bioluminescent Bloom', tags:['bioluminescent','fungal','moss','coral','ocean'],
    groundLightBoost: 0.02, groundHueShift: 0,
    groundSatBoost: 20, skyWarmth: 0,
    glowColor:[160,70,45], glowIntensity: 0.2,
    frostTint:[10,18,22] },
  { name:'Crystal Frost', tags:['crystal','tundra','glass','prismatic','frozen'],
    groundLightBoost: 0.06, groundHueShift: 10,
    groundSatBoost: 15, skyWarmth: -0.04,
    glowColor:[200,50,55], glowIntensity: 0.12,
    frostTint:[12,14,25] },
  { name:'Deep Velvet', tags:['storm','magnetic','ancient','ocean'],
    groundLightBoost: 0.01, groundHueShift: 0,
    groundSatBoost: 25, skyWarmth: 0,
    glowColor:[270,45,35], glowIntensity: 0.08,
    frostTint:[14,12,22] },
  { name:'Aurora Crown', tags:['magnetic','tundra','crystal','thin','none'],
    groundLightBoost: 0, groundHueShift: 0,
    groundSatBoost: 5, skyWarmth: 0,
    glowColor:[140,65,50], glowIntensity: 0.1,
    frostTint:[10,14,20] },
  { name:'Warm Dark', tags:['desert','ancient','canyon','fungal','moss'],
    groundLightBoost: 0.03, groundHueShift: -10,
    groundSatBoost: 8, skyWarmth: 0.15,
    glowColor:[30,40,35], glowIntensity: 0.1,
    frostTint:[22,18,14] },
  { name:'Silver Mirror', tags:['glass','metallic','ocean','tundra'],
    groundLightBoost: 0.05, groundHueShift: 0,
    groundSatBoost: -15, skyWarmth: -0.02,
    glowColor:[210,12,55], glowIntensity: 0.08,
    frostTint:[16,16,18] },
  { name:'Phosphor Sea', tags:['ocean','bioluminescent','coral','glass'],
    groundLightBoost: 0.04, groundHueShift: 5,
    groundSatBoost: 18, skyWarmth: 0,
    glowColor:[175,60,42], glowIntensity: 0.18,
    frostTint:[10,16,20] },
  { name:'Volcanic Ember', tags:['volcanic','sulphur','metallic','molten'],
    groundLightBoost: 0.1, groundHueShift: -8,
    groundSatBoost: 22, skyWarmth: 0.08,
    glowColor:[8,65,35], glowIntensity: 0.22,
    frostTint:[25,16,12] },
  { name:'Starlit Silence', tags:['storm','ancient','desert','canyon'],
    groundLightBoost: 0, groundHueShift: 0,
    groundSatBoost: 0, skyWarmth: 0,
    glowColor:[220,25,30], glowIntensity: 0.03,
    frostTint:[12,12,18] },
  { name:'Bone Pale', tags:['bone','salt','desert','ancient'],
    groundLightBoost: 0.04, groundHueShift: 5,
    groundSatBoost: -10, skyWarmth: 0.05,
    glowColor:[40,15,45], glowIntensity: 0.05,
    frostTint:[18,16,14] },
  { name:'Plasma Crackle', tags:['plasma','magnetic','storm'],
    groundLightBoost: 0.06, groundHueShift: 15,
    groundSatBoost: 30, skyWarmth: 0,
    glowColor:[260,70,50], glowIntensity: 0.2,
    frostTint:[14,10,24] },
  { name:'Dark Mirror', tags:['obsidian','glass','metallic','salt'],
    groundLightBoost: 0.03, groundHueShift: 0,
    groundSatBoost: -5, skyWarmth: -0.02,
    glowColor:[280,20,40], glowIntensity: 0.06,
    frostTint:[14,12,20] },
  { name:'Ruin Whisper', tags:['ruins','ancient','sandstone','bone'],
    groundLightBoost: 0.04, groundHueShift: -3,
    groundSatBoost: 8, skyWarmth: 0.06,
    glowColor:[42,35,38], glowIntensity: 0.1,
    frostTint:[20,16,14] },
  { name:'Cavern Phosphor', tags:['cavern','crystal','abyssal','bioluminescent'],
    groundLightBoost: 0.06, groundHueShift: 10,
    groundSatBoost: 25, skyWarmth: 0,
    glowColor:[180,55,40], glowIntensity: 0.2,
    frostTint:[10,16,22] },
  { name:'Abyssal Pressure', tags:['abyssal','ocean','storm','volcanic'],
    groundLightBoost: 0.02, groundHueShift: -5,
    groundSatBoost: 15, skyWarmth: 0.03,
    glowColor:[200,45,30], glowIntensity: 0.12,
    frostTint:[8,12,20] },
  { name:'Dune Starlight', tags:['sandstone','desert','salt','canyon'],
    groundLightBoost: 0.02, groundHueShift: 0,
    groundSatBoost: -5, skyWarmth: 0.08,
    glowColor:[35,28,45], glowIntensity: 0.06,
    frostTint:[18,14,12] },
  { name:'Basalt Ember', tags:['basalt','volcanic','metallic','obsidian'],
    groundLightBoost: 0.05, groundHueShift: -8,
    groundSatBoost: 18, skyWarmth: 0.05,
    glowColor:[10,55,32], glowIntensity: 0.14,
    frostTint:[22,14,12] },
  { name:'Mycelial Pulse', tags:['mycelium','fungal','moss','bioluminescent'],
    groundLightBoost: 0.02, groundHueShift: -5,
    groundSatBoost: 12, skyWarmth: 0.03,
    glowColor:[65,45,40], glowIntensity: 0.12,
    frostTint:[18,16,12] },
];

// Accent Pool — curated jewel tones [h, s, l]
const ACCENT_POOL = [
  { name:'Warm Amber', hsl:[38,72,58], tags:['desert','volcanic','ancient'] },
  { name:'Seafoam', hsl:[165,55,55], tags:['ocean','glass','tundra'] },
  { name:'Rose Quartz', hsl:[340,48,62], tags:['coral','crystal','ancient'] },
  { name:'Electric Teal', hsl:[178,68,48], tags:['metallic','ocean','bioluminescent'] },
  { name:'Soft Gold', hsl:[45,60,58], tags:['desert','canyon','ancient'] },
  { name:'Deep Coral', hsl:[12,65,52], tags:['volcanic','coral','canyon'] },
  { name:'Icy Violet', hsl:[270,45,62], tags:['crystal','tundra','magnetic'] },
  { name:'Jade', hsl:[155,50,45], tags:['moss','fungal','ocean'] },
  { name:'Copper', hsl:[22,62,48], tags:['metallic','volcanic','desert'] },
  { name:'Moonstone', hsl:[215,35,68], tags:['glass','tundra','ocean'] },
  { name:'Crimson Ember', hsl:[355,60,45], tags:['volcanic','sulphur','storm'] },
  { name:'Sage Green', hsl:[135,30,52], tags:['moss','fungal','ancient'] },
  { name:'Amethyst', hsl:[280,50,55], tags:['crystal','magnetic','prismatic'] },
  { name:'Burnt Sienna', hsl:[18,55,42], tags:['canyon','desert','ancient'] },
  { name:'Aquamarine', hsl:[185,52,55], tags:['ocean','glass','coral'] },
  { name:'Champagne', hsl:[40,40,68], tags:['desert','glass','ancient'] },
  { name:'Storm Indigo', hsl:[235,48,42], tags:['storm','magnetic','metallic'] },
  { name:'Peridot', hsl:[85,55,48], tags:['fungal','moss','bioluminescent'] },
  { name:'Bleached Bone', hsl:[38,15,72], tags:['bone','salt','desert'] },
  { name:'Obsidian Edge', hsl:[285,25,35], tags:['obsidian','volcanic','metallic'] },
  { name:'Spore Gold', hsl:[52,42,50], tags:['mycelium','fungal','ancient'] },
  { name:'Arc Plasma', hsl:[245,65,58], tags:['plasma','magnetic','storm'] },
  { name:'Salt Crystal', hsl:[195,18,75], tags:['salt','glass','tundra'] },
  { name:'Ruin Gold', hsl:[42,58,48], tags:['ruins','ancient','sandstone'] },
  { name:'Cavern Teal', hsl:[182,52,42], tags:['cavern','abyssal','crystal'] },
  { name:'Abyssal Blue', hsl:[222,55,38], tags:['abyssal','ocean','storm'] },
  { name:'Dune Ochre', hsl:[32,55,52], tags:['sandstone','desert','canyon'] },
  { name:'Basalt Iron', hsl:[215,22,38], tags:['basalt','metallic','volcanic'] },
  { name:'Hydrothermal Orange', hsl:[18,68,45], tags:['abyssal','volcanic','sulphur'] },
  { name:'Cascade Mist', hsl:[198,38,62], tags:['ocean','moss','tundra'] },
];

// Rare modifiers — special world behaviors (~8-12% chance each)
const RARE_MODIFIERS = [
  { name:'Eternal Twilight', chance: 0.06, desc:'perpetual golden hour' },
  { name:'Monochrome World', chance: 0.04, desc:'single hue explored in depth' },
  { name:'Inverse Horizon', chance: 0.05, desc:'ground brighter than sky at night' },
  { name:'Double Shadow', chance: 0.06, desc:'two-toned lighting from binary influence' },
  { name:'Ring Light', chance: 0.05, desc:'planetary ring casts faint band across sky' },
];

// ═══════════════════════════════════════════
// PALETTE COMPOSITION ENGINE
// ═══════════════════════════════════════════

function hslStr(h, s, l) { return `hsl(${Math.round(h)}, ${Math.round(s)}%, ${Math.round(l)}%)`; }
function hslaStr(h, s, l, a) { return `hsla(${Math.round(h)}, ${Math.round(s)}%, ${Math.round(l)}%, ${a.toFixed(3)})`; }
function lerpHSL(a, b, t) { return [a[0]+(b[0]-a[0])*t, a[1]+(b[1]-a[1])*t, a[2]+(b[2]-a[2])*t]; }

function scoreIngredient(ingredient, surface, temperature, atmosphere) {
  let score = 0;
  const tags = ingredient.tags;
  if (tags.includes(surface)) score += 3;
  if (tags.includes(temperature)) score += 2;
  if (tags.includes(atmosphere)) score += 1;
  return score;
}

function pickWeighted(pool, surface, temperature, atmosphere, rng) {
  // Score each ingredient, then use scores as weights with randomness
  const scored = pool.map(item => {
    const base = scoreIngredient(item, surface, temperature, atmosphere);
    // Add randomness so non-matching items still have a chance
    const noise = rng() * 2.5;
    return { item, weight: base + noise + 0.5 };
  });
  scored.sort((a, b) => b.weight - a.weight);
  // Weighted random from top candidates (not just the best — preserves variety)
  const top = scored.slice(0, Math.min(5, scored.length));
  const totalW = top.reduce((s, t) => s + t.weight, 0);
  let r = rng() * totalW, acc = 0;
  for (const t of top) {
    acc += t.weight;
    if (r <= acc) return t.item;
  }
  return top[0].item;
}

function pickSecondary(pool, primary, surface, temperature, atmosphere, rng) {
  // Pick a second ingredient for blending — avoid exact duplicate
  const candidates = pool.filter(p => p.name !== primary.name);
  return pickWeighted(candidates.length ? candidates : pool, surface, temperature, atmosphere, rng);
}

function generatePalette(rng, temperature, surface, atmosphere, starType) {
  // ── Pick curated ingredients ──
  const sky1 = pickWeighted(SKY_FAMILIES, surface, temperature, atmosphere, rng);
  const sky2 = pickSecondary(SKY_FAMILIES, sky1, surface, temperature, atmosphere, rng);
  const skyBlend = 0.15 + rng() * 0.35; // how much sky2 influences (15-50%)

  const gnd1 = pickWeighted(GROUND_FAMILIES, surface, temperature, atmosphere, rng);
  const gnd2 = pickSecondary(GROUND_FAMILIES, gnd1, surface, temperature, atmosphere, rng);
  const gndBlend = 0.1 + rng() * 0.3;

  const nightSig = pickWeighted(NIGHT_SIGNATURES, surface, temperature, atmosphere, rng);
  const accent1 = pickWeighted(ACCENT_POOL, surface, temperature, atmosphere, rng);
  const accent2pick = pickSecondary(ACCENT_POOL, accent1, surface, temperature, atmosphere, rng);

  // ── Blend sky colors ──
  const skyDayZenith = lerpHSL(sky1.day.zenith, sky2.day.zenith, skyBlend);
  const skyDayHorizon = lerpHSL(sky1.day.horizon, sky2.day.horizon, skyBlend);
  const skyNightZenith = lerpHSL(sky1.night.zenith, sky2.night.zenith, skyBlend);
  const skyNightHorizon = lerpHSL(sky1.night.horizon, sky2.night.horizon, skyBlend);

  // ── Blend ground colors ──
  const gndDayFar = lerpHSL(gnd1.day.far, gnd2.day.far, gndBlend);
  const gndDayMid = lerpHSL(gnd1.day.mid, gnd2.day.mid, gndBlend);
  const gndDayNear = lerpHSL(gnd1.day.near, gnd2.day.near, gndBlend);
  const gndNightFar = lerpHSL(gnd1.night.far, gnd2.night.far, gndBlend);
  const gndNightMid = lerpHSL(gnd1.night.mid, gnd2.night.mid, gndBlend);
  const gndNightNear = lerpHSL(gnd1.night.near, gnd2.night.near, gndBlend);

  // ── Add per-world noise to prevent exact matches ──
  const hueNoise = (rng() - 0.5) * 12; // ±6 degree hue drift
  const satNoise = (rng() - 0.5) * 8;  // ±4% saturation drift
  const lightNoise = (rng() - 0.5) * 6; // ±3% lightness drift

  function jitter(hsl) {
    return [(hsl[0] + hueNoise + 360) % 360,
            Math.max(5, Math.min(100, hsl[1] + satNoise)),
            Math.max(2, Math.min(90, hsl[2] + lightNoise))];
  }

  const jSkyDZ = jitter(skyDayZenith);
  const jSkyDH = jitter(skyDayHorizon);
  const jSkyNZ = jitter(skyNightZenith);
  const jSkyNH = jitter(skyNightHorizon);
  const jGndDF = jitter(gndDayFar);
  const jGndDM = jitter(gndDayMid);
  const jGndDN = jitter(gndDayNear);
  const jGndNF = jitter(gndNightFar);

  // ── Star type influence — tint everything slightly ──
  const starHue = starType.name === 'Red Dwarf' ? 8 :
                  starType.name === 'Blue Giant' ? 225 :
                  starType.name === 'White Dwarf' ? 212 : 48;
  const starTintStr = starType.name === 'Red Dwarf' ? 0.12 :
                      starType.name === 'Blue Giant' ? 0.08 : 0.02;
  // Nudge sky hues toward star color
  jSkyDZ[0] = (jSkyDZ[0] * (1 - starTintStr) + starHue * starTintStr + 360) % 360;
  jSkyNZ[0] = (jSkyNZ[0] * (1 - starTintStr * 0.5) + starHue * starTintStr * 0.5 + 360) % 360;

  // ── Exotic atmosphere boost ──
  if (atmosphere === 'exotic') {
    jSkyDZ[1] = Math.min(90, jSkyDZ[1] + 15);
    jSkyDH[1] = Math.min(90, jSkyDH[1] + 12);
    jSkyDZ[0] = (jSkyDZ[0] + 15 + rng() * 20) % 360; // hue shift for alien feel
  }

  // ── Sky hue correction — prevent ugly olive/yellow-green skies ──
  // Hues in ~50-150° look muddy as sky colors. Push them toward
  // either blue-teal (>170) or warm amber (<45).
  function correctSkyHue(hsl) {
    let h = hsl[0];
    if (h > 50 && h < 150) {
      // How deep into the ugly zone (0 at edges, 1 at center ~100)
      const center = 100, halfWidth = 50;
      const depth = 1 - Math.abs(h - center) / halfWidth;
      // Push toward nearest good boundary — more aggressively
      if (h <= center) {
        // Closer to warm side — push toward 42 (amber)
        hsl[0] = h - depth * (h - 42) * 0.85;
      } else {
        // Closer to cool side — push toward 175 (teal)
        hsl[0] = h + depth * (175 - h) * 0.85;
      }
      // Desaturate to avoid vivid lime — more aggressive
      hsl[1] = Math.max(5, hsl[1] - depth * 15);
    }
    // Also prevent very low-saturation/low-lightness "mud" colors
    // that look grey-brown and lifeless
    if (hsl[1] < 15 && hsl[2] > 30 && hsl[2] < 60) {
      hsl[1] = Math.max(hsl[1], 18); // minimum saturation for visible color
    }
  }
  correctSkyHue(jSkyDZ);
  correctSkyHue(jSkyDH);
  // Leave night sky alone — muted greens are fine at very low lightness

  // ── Ensure day sky has minimum vibrancy ──
  // Some blends can produce very desaturated daytime skies — boost them
  if (jSkyDZ[1] < 20) jSkyDZ[1] = 20 + (jSkyDZ[1] * 0.5);
  if (jSkyDH[1] < 18) jSkyDH[1] = 18 + (jSkyDH[1] * 0.5);

  // ── Rare modifiers ──
  let modifier = null;
  for (const mod of RARE_MODIFIERS) {
    if (rng() < mod.chance) { modifier = mod; break; }
  }

  // Monochrome world: collapse everything toward one hue
  if (modifier && modifier.name === 'Monochrome World') {
    const monoH = jSkyDZ[0];
    [jSkyDH, jSkyNZ, jSkyNH, jGndDF, jGndDM, jGndDN, jGndNF].forEach(c => {
      c[0] = (monoH + (c[0] - monoH) * 0.15 + 360) % 360; // pull all hues toward monoH
    });
  }

  // ── Derive canonical hue and sat (used by downstream systems) ──
  const h = jSkyDZ[0]; // primary hue from zenith
  const s = jSkyDZ[1]; // primary saturation

  // ── Aurora from night signature or accent ──
  const auroraH = nightSig.glowColor[0];
  const auroraHue = auroraH;

  // ── Golden hour hue ──
  const goldenHue = (h + 340 + rng() * 25) % 360;

  // ── Night signature glow color ──
  const nsGlow = nightSig.glowColor;
  const nsFrost = nightSig.frostTint;

  // ── Accent colors ──
  const a1 = accent1.hsl;
  const a2 = accent2pick.hsl;

  return {
    // Named string colors (used by some legacy consumers)
    skyDay: hslStr(jSkyDZ[0], jSkyDZ[1], jSkyDZ[2]),
    skyNight: hslStr(jSkyNZ[0], jSkyNZ[1], jSkyNZ[2]),
    horizonDay: hslStr(jSkyDH[0], jSkyDH[1], jSkyDH[2]),
    horizonNight: hslStr(jSkyNH[0], jSkyNH[1], jSkyNH[2]),
    groundDay: hslStr(jGndDF[0], jGndDF[1], jGndDF[2]),
    groundNight: hslStr(jGndNF[0], jGndNF[1], jGndNF[2]),
    groundFar: hslStr(jGndDF[0], jGndDF[1] * 0.7, jGndDF[2] * 0.85),
    accent: hslStr(a1[0], a1[1], a1[2]),
    accent2: hslStr(a2[0], a2[1], a2[2]),
    starLight: `hsl(${starHue}, 72%, 84%)`,
    fog: hslaStr(jSkyDH[0], jSkyDH[1] * 0.35, 35, 0.05 + rng() * 0.12),
    aurora: hslStr(auroraH, 70 + rng() * 20, 52 + rng() * 18),
    golden: hslStr(goldenHue, 60 + rng() * 20, 55 + rng() * 12),
    glow: hslaStr(nsGlow[0], nsGlow[1], nsGlow[2], 0.08 + rng() * 0.12),

    // Raw HSL arrays for the lighting system
    skyDayZenith: jSkyDZ, skyDayHorizon: jSkyDH,
    skyNightZenith: jSkyNZ, skyNightHorizon: jSkyNH,
    gndDay: { far: jGndDF, mid: jGndDM, near: jGndDN },
    gndNight: { far: jGndNF, mid: jitter(gndNightMid), near: jitter(gndNightNear) },
    accentHSL: a1, accent2HSL: a2,

    // Night signature
    nightSignature: nightSig,
    nightGlow: nsGlow,
    nightFrost: nsFrost,

    // Modifier
    modifier,

    // Canonical values for legacy consumers
    auroraHue, goldenHue,
    hue: h, sat: s,
    starWarmth: starTintStr,
  };
}

// ═══════════════════════════════════════════
// LANDSCAPE GENERATION
// ═══════════════════════════════════════════
function renderLandscape(location, system) {
  // Legacy wrapper — redirects to new split architecture
  initLandscape(location, system);
}

// ── Landscape helper functions ──
function lerp(a, b, t) { return a + (b - a) * t; }

function getSurfaceTextureCSS(surface) {
  switch(surface) {
    case 'volcanic': return 'repeating-linear-gradient(0deg, transparent, transparent 18px, rgba(255,80,20,0.18) 18px, rgba(255,80,20,0.18) 19px), radial-gradient(ellipse 4px 10px at 40% 70%, rgba(255,120,30,0.12), transparent)';
    case 'crystal': return 'repeating-linear-gradient(60deg, transparent, transparent 8px, rgba(200,220,255,0.15) 8px, rgba(200,220,255,0.15) 9px), repeating-linear-gradient(-30deg, transparent, transparent 12px, rgba(180,200,255,0.08) 12px, rgba(180,200,255,0.08) 13px)';
    case 'tundra': return 'repeating-linear-gradient(0deg, transparent, transparent 8px, rgba(180,200,220,0.1) 8px, rgba(180,200,220,0.1) 9px)';
    case 'fungal': return 'radial-gradient(circle 20px at 20% 50%, rgba(120,200,80,0.1) 0%, transparent 100%), radial-gradient(circle 15px at 55% 60%, rgba(100,180,120,0.08) 0%, transparent 100%), radial-gradient(circle 25px at 80% 45%, rgba(80,200,140,0.09) 0%, transparent 100%)';
    case 'metallic': return 'repeating-linear-gradient(45deg, transparent, transparent 6px, rgba(180,190,200,0.1) 6px, rgba(180,190,200,0.1) 7px), repeating-linear-gradient(90deg, transparent, transparent 20px, rgba(160,180,200,0.06) 20px, rgba(160,180,200,0.06) 21px)';
    case 'glass': return 'linear-gradient(135deg, rgba(200,220,240,0.08) 25%, transparent 25%, transparent 50%, rgba(200,220,240,0.08) 50%, rgba(200,220,240,0.08) 75%, transparent 75%)';
    case 'storm': return 'repeating-linear-gradient(170deg, transparent, transparent 6px, rgba(100,120,200,0.08) 6px, rgba(100,120,200,0.08) 7px)';
    case 'moss': return 'radial-gradient(circle 2px at 15% 40%, rgba(80,160,80,0.1) 0%, transparent 100%), radial-gradient(circle 3px at 45% 60%, rgba(80,160,80,0.08) 0%, transparent 100%), radial-gradient(circle 2px at 75% 35%, rgba(80,160,80,0.1) 0%, transparent 100%)';
    case 'ancient': return 'repeating-linear-gradient(90deg, transparent, transparent 30px, rgba(180,160,120,0.08) 30px, rgba(180,160,120,0.08) 31px), repeating-linear-gradient(0deg, transparent, transparent 30px, rgba(180,160,120,0.06) 30px, rgba(180,160,120,0.06) 31px)';
    case 'coral': return 'radial-gradient(circle 12px at 25% 65%, rgba(255,120,140,0.1), transparent), radial-gradient(circle 18px at 60% 50%, rgba(255,150,100,0.08), transparent), radial-gradient(circle 10px at 80% 70%, rgba(255,100,120,0.09), transparent)';
    case 'prismatic': return 'linear-gradient(45deg, rgba(255,100,100,0.06), rgba(255,200,50,0.06), rgba(100,255,100,0.06), rgba(100,150,255,0.06), rgba(200,100,255,0.06))';
    case 'sulphur': return 'radial-gradient(ellipse 30px 10px at 40% 70%, rgba(220,200,50,0.12), transparent), radial-gradient(ellipse 20px 8px at 70% 60%, rgba(200,220,60,0.08), transparent)';
    case 'magnetic': return 'repeating-conic-gradient(from 0deg at 50% 120%, transparent 0deg, rgba(140,100,255,0.05) 3deg, transparent 6deg)';
    case 'obsidian': return 'repeating-linear-gradient(135deg, transparent, transparent 4px, rgba(40,20,60,0.12) 4px, rgba(40,20,60,0.12) 5px), linear-gradient(45deg, rgba(80,60,120,0.06) 25%, transparent 25%, transparent 75%, rgba(80,60,120,0.06) 75%)';
    case 'salt': return 'repeating-linear-gradient(0deg, transparent, transparent 20px, rgba(240,235,220,0.06) 20px, rgba(240,235,220,0.06) 21px), repeating-linear-gradient(90deg, transparent, transparent 20px, rgba(240,235,220,0.04) 20px, rgba(240,235,220,0.04) 21px), radial-gradient(circle 3px at 30% 50%, rgba(255,255,240,0.08), transparent)';
    case 'mycelium': return 'radial-gradient(circle 8px at 20% 55%, rgba(180,160,120,0.08), transparent), radial-gradient(circle 12px at 60% 45%, rgba(170,150,110,0.06), transparent), repeating-linear-gradient(30deg, transparent, transparent 6px, rgba(160,140,100,0.05) 6px, rgba(160,140,100,0.05) 7px)';
    case 'plasma': return 'radial-gradient(circle 15px at 35% 50%, rgba(120,180,255,0.1), transparent), radial-gradient(circle 20px at 65% 40%, rgba(200,120,255,0.08), transparent), radial-gradient(circle 12px at 50% 65%, rgba(100,220,200,0.07), transparent)';
    case 'bone': return 'repeating-linear-gradient(0deg, transparent, transparent 12px, rgba(220,200,170,0.08) 12px, rgba(220,200,170,0.08) 13px), radial-gradient(circle 5px at 40% 55%, rgba(200,180,150,0.06), transparent), radial-gradient(circle 4px at 70% 45%, rgba(200,180,150,0.05), transparent)';
    case 'sandstone': return 'repeating-linear-gradient(2deg, transparent, transparent 6px, rgba(210,170,120,0.1) 6px, rgba(210,170,120,0.1) 7px), repeating-linear-gradient(178deg, transparent, transparent 8px, rgba(200,160,110,0.06) 8px, rgba(200,160,110,0.06) 9px)';
    case 'cavern': return 'radial-gradient(circle 15px at 30% 40%, rgba(120,180,200,0.08), transparent), radial-gradient(circle 20px at 65% 60%, rgba(100,160,220,0.06), transparent), repeating-linear-gradient(85deg, transparent, transparent 10px, rgba(80,120,160,0.04) 10px, rgba(80,120,160,0.04) 11px)';
    case 'abyssal': return 'radial-gradient(circle 25px at 35% 55%, rgba(20,80,120,0.1), transparent), radial-gradient(circle 18px at 70% 45%, rgba(40,100,140,0.07), transparent), radial-gradient(circle 8px at 50% 70%, rgba(200,100,50,0.06), transparent)';
    case 'ruins': return 'repeating-linear-gradient(0deg, transparent, transparent 24px, rgba(180,160,100,0.06) 24px, rgba(180,160,100,0.06) 25px), repeating-linear-gradient(90deg, transparent, transparent 24px, rgba(180,160,100,0.04) 24px, rgba(180,160,100,0.04) 25px), radial-gradient(circle 3px at 50% 50%, rgba(200,180,80,0.05), transparent)';
    case 'basalt': return 'repeating-conic-gradient(from 0deg at 50% 50%, transparent 0deg, rgba(60,70,80,0.08) 60deg, transparent 120deg), repeating-linear-gradient(120deg, transparent, transparent 8px, rgba(70,80,90,0.06) 8px, rgba(70,80,90,0.06) 9px)';
    default: return 'none';
  }
}

function generateForegroundSilhouettes(rng, surface, p, count) {
  // Returns array of clip-path polygon shapes for foreground objects
  const silhouettes = [];
  const grammar = (surface === 'volcanic' || surface === 'crystal' || surface === 'sulphur') ? 'spiky' :
                   (surface === 'fungal' || surface === 'moss' || surface === 'coral' || surface === 'mycelium') ? 'rounded' :
                   (surface === 'metallic' || surface === 'ancient' || surface === 'magnetic' || surface === 'ruins') ? 'angular' :
                   (surface === 'bioluminescent' || surface === 'prismatic' || surface === 'plasma' || surface === 'cavern') ? 'branching' :
                   (surface === 'canyon' || surface === 'tundra' || surface === 'basalt') ? 'monolithic' :
                   (surface === 'obsidian' || surface === 'bone' || surface === 'sandstone') ? 'columnar' :
                   (surface === 'salt' || surface === 'abyssal') ? 'flat' : 'mixed';

  for (let i = 0; i < count; i++) {
    const x = 3 + rng() * 90;
    const baseH = 20 + rng() * 50;
    const baseW = 4 + rng() * 12;

    let points = [];
    if (grammar === 'spiky') {
      const spikes = 3 + Math.floor(rng() * 4);
      points.push(`${x - baseW/2}% 100%`);
      for (let s = 0; s < spikes; s++) {
        const sx = x - baseW/2 + (s/(spikes-1)) * baseW;
        const sh = baseH * (0.4 + rng() * 0.6);
        points.push(`${sx}% ${100 - sh * 0.3}%`);
        points.push(`${sx + baseW/(spikes*2)}% ${100 - sh}%`);
        points.push(`${sx + baseW/spikes}% ${100 - sh * 0.4}%`);
      }
      points.push(`${x + baseW/2}% 100%`);
    } else if (grammar === 'rounded') {
      const bulges = 2 + Math.floor(rng() * 3);
      points.push(`${x - baseW/2}% 100%`);
      for (let s = 0; s <= 10; s++) {
        const t = s / 10;
        const sx = x - baseW/2 + t * baseW;
        const envelope = Math.sin(t * Math.PI);
        const bulge = Math.sin(t * Math.PI * bulges) * 0.3 + 0.7;
        points.push(`${sx}% ${100 - baseH * envelope * bulge * 0.6}%`);
      }
      points.push(`${x + baseW/2}% 100%`);
    } else if (grammar === 'angular') {
      const h = baseH * 0.7;
      points.push(`${x - baseW/2}% 100%`);
      points.push(`${x - baseW*0.3}% ${100 - h*0.4}%`);
      points.push(`${x - baseW*0.15}% ${100 - h*0.35}%`);
      points.push(`${x}% ${100 - h}%`);
      points.push(`${x + baseW*0.1}% ${100 - h*0.85}%`);
      points.push(`${x + baseW*0.3}% ${100 - h*0.5}%`);
      points.push(`${x + baseW/2}% 100%`);
    } else if (grammar === 'branching') {
      const h = baseH * 0.8;
      points.push(`${x - 1}% 100%`);
      points.push(`${x - 1.5}% ${100 - h*0.5}%`);
      points.push(`${x - baseW*0.3}% ${100 - h*0.7}%`);
      points.push(`${x - 1}% ${100 - h*0.55}%`);
      points.push(`${x}% ${100 - h}%`);
      points.push(`${x + 1}% ${100 - h*0.6}%`);
      points.push(`${x + baseW*0.25}% ${100 - h*0.75}%`);
      points.push(`${x + 1.5}% ${100 - h*0.45}%`);
      points.push(`${x + 1}% 100%`);
    } else if (grammar === 'monolithic') {
      const h = baseH * (0.6 + rng() * 0.4);
      const taper = 0.3 + rng() * 0.4;
      points.push(`${x - baseW/2}% 100%`);
      points.push(`${x - baseW*taper/2}% ${100 - h}%`);
      points.push(`${x + baseW*taper/2}% ${100 - h}%`);
      points.push(`${x + baseW/2}% 100%`);
    } else if (grammar === 'columnar') {
      // Hexagonal column clusters (basalt-like)
      const cols = 2 + Math.floor(rng() * 3);
      const colW = baseW / cols;
      points.push(`${x - baseW/2}% 100%`);
      for (let c = 0; c < cols; c++) {
        const cx = x - baseW/2 + c * colW;
        const ch = baseH * (0.5 + rng() * 0.5);
        points.push(`${cx}% ${100 - ch}%`);
        points.push(`${cx + colW * 0.4}% ${100 - ch - 2}%`);
        points.push(`${cx + colW * 0.6}% ${100 - ch - 2}%`);
        points.push(`${cx + colW}% ${100 - ch}%`);
        if (c < cols - 1) points.push(`${cx + colW}% ${100 - ch * 0.6}%`);
      }
      points.push(`${x + baseW/2}% 100%`);
    } else if (grammar === 'flat') {
      // Low flat formations — salt crust ridges
      const h = baseH * 0.2;
      const segments = 4 + Math.floor(rng() * 4);
      points.push(`${x - baseW/2}% 100%`);
      for (let s = 0; s <= segments; s++) {
        const sx = x - baseW/2 + (s / segments) * baseW;
        const sh = h * (0.6 + rng() * 0.4);
        points.push(`${sx}% ${100 - sh}%`);
      }
      points.push(`${x + baseW/2}% 100%`);
    } else { // mixed
      const h = baseH * (0.5 + rng() * 0.5);
      const taper = 0.3 + rng() * 0.4;
      points.push(`${x - baseW/2}% 100%`);
      points.push(`${x - baseW*taper/2}% ${100 - h}%`);
      points.push(`${x + baseW*taper/2}% ${100 - h}%`);
      points.push(`${x + baseW/2}% 100%`);
    }

    silhouettes.push({ points: `polygon(${points.join(', ')})`, x, h: baseH });
  }
  return silhouettes;
}

function generateLandmark(rng, surface, p) {
  // Returns a landmark HTML string or empty string
  const roll = rng();
  if (roll > 0.45) return ''; // 45% chance of landmark (was 30%)

  const type = Math.floor(rng() * 12);
  const h = p.hue;
  const s = p.sat;
  switch(type) {
    case 0: // Stone arch
      return `<div style="position:absolute;bottom:30%;left:${25+rng()*40}%;width:18vw;height:12vw;
        border:${6+rng()*4}px solid hsl(${h},${s*0.3}%,18%);border-bottom:none;border-radius:50% 50% 0 0;
        opacity:0.35;filter:blur(1px)"></div>`;
    case 1: // Crystal spire
      return `<div style="position:absolute;bottom:15%;left:${30+rng()*35}%;width:0;height:0;
        border-left:${8+rng()*6}px solid transparent;border-right:${8+rng()*6}px solid transparent;
        border-bottom:${80+rng()*60}px solid hsla(${(h+180)%360},${s}%,30%,0.3);
        filter:blur(0.5px)"></div>`;
    case 2: // Floating monolith
      return `<div style="position:absolute;bottom:${35+rng()*15}%;left:${35+rng()*25}%;
        width:${15+rng()*10}px;height:${50+rng()*40}px;
        background:linear-gradient(to bottom, hsl(${h},${s*0.2}%,25%), hsl(${h},${s*0.3}%,15%));
        opacity:0.3;box-shadow:0 8px 20px rgba(0,0,0,0.3);transform:rotate(${-3+rng()*6}deg)"></div>`;
    case 3: // Massive tree silhouette (bio/fungal)
      return `<div style="position:absolute;bottom:15%;left:${20+rng()*50}%;width:4px;height:${60+rng()*40}px;
        background:hsl(${h},${s*0.4}%,15%);opacity:0.35"></div>
        <div style="position:absolute;bottom:${50+rng()*15}%;left:${18+rng()*50}%;width:${50+rng()*30}px;height:${30+rng()*20}px;
        background:radial-gradient(ellipse, hsla(${(h+120)%360},40%,20%,0.3), transparent);border-radius:50%;
        filter:blur(3px)"></div>`;
    case 4: // Crashed structure
      return `<div style="position:absolute;bottom:10%;left:${25+rng()*40}%;
        width:${40+rng()*30}px;height:${15+rng()*12}px;
        background:hsl(${h},${s*0.2}%,18%);opacity:0.3;transform:rotate(${5+rng()*15}deg);
        clip-path:polygon(0% 100%, 10% 30%, 30% 0%, 60% 10%, 90% 40%, 100% 100%)"></div>`;
    case 5: { // Geyser vent — steaming plume rising from ground
      const gx = 20 + rng() * 55;
      return `<div style="position:absolute;bottom:12%;left:${gx}%;width:${6+rng()*4}px;height:${3+rng()*2}px;
        background:hsl(${h},${s*0.3}%,22%);border-radius:50%;opacity:0.4"></div>
        <div style="position:absolute;bottom:13%;left:${gx-1}%;width:${15+rng()*10}px;height:${40+rng()*30}px;
        background:linear-gradient(to top, hsla(${h},20%,70%,0.12), hsla(${h},15%,80%,0.04), transparent);
        filter:blur(6px);animation:spore-rise ${8+rng()*6}s ease-in-out infinite"></div>`;
    }
    case 6: { // Double stone arch bridge
      const ax = 15 + rng() * 35;
      return `<div style="position:absolute;bottom:28%;left:${ax}%;width:14vw;height:9vw;
        border:${5+rng()*3}px solid hsl(${h},${s*0.25}%,16%);border-bottom:none;border-radius:50% 50% 0 0;
        opacity:0.3;filter:blur(0.5px)"></div>
        <div style="position:absolute;bottom:25%;left:${ax+18}%;width:10vw;height:7vw;
        border:${4+rng()*3}px solid hsl(${h},${s*0.2}%,14%);border-bottom:none;border-radius:50% 50% 0 0;
        opacity:0.25;filter:blur(0.5px)"></div>`;
    }
    case 7: { // Obelisk — tall thin standing stone
      const ox = 30 + rng() * 35;
      const oh = 80 + rng() * 50;
      return `<div style="position:absolute;bottom:14%;left:${ox}%;width:${6+rng()*4}px;height:${oh}px;
        background:linear-gradient(to top, hsl(${h},${s*0.25}%,14%), hsl(${h},${s*0.15}%,22%));
        clip-path:polygon(15% 100%, 0% 3%, 50% 0%, 100% 3%, 85% 100%);
        opacity:0.35;filter:blur(0.3px)"></div>`;
    }
    case 8: { // Impact crater rim (viewed from side)
      const cx = 10 + rng() * 50;
      const cw = 25 + rng() * 20;
      return `<div style="position:absolute;bottom:10%;left:${cx}%;width:${cw}vw;height:${cw*0.3}vw;
        border:${3+rng()*2}px solid hsl(${h},${s*0.2}%,16%);border-bottom:none;border-radius:50% 50% 0 0;
        opacity:0.25;transform:scaleY(0.5)"></div>
        <div style="position:absolute;bottom:9%;left:${cx+2}%;width:${cw-4}vw;height:${cw*0.08}vw;
        background:hsla(${h},${s*0.3}%,12%,0.2);border-radius:50%;filter:blur(2px)"></div>`;
    }
    case 9: { // Petrified tree / dead giant
      const tx = 25 + rng() * 45;
      const th = 70 + rng() * 50;
      const lean = -8 + rng() * 16;
      return `<div style="position:absolute;bottom:12%;left:${tx}%;width:${5+rng()*4}px;height:${th}px;
        background:hsl(${h},${s*0.15}%,18%);opacity:0.3;transform:rotate(${lean}deg);transform-origin:bottom center"></div>
        <div style="position:absolute;bottom:${12 + th*0.08}%;left:${tx-3}%;width:${20+rng()*15}px;height:${3+rng()*2}px;
        background:hsl(${h},${s*0.12}%,16%);opacity:0.25;transform:rotate(${-25+rng()*50}deg)"></div>
        <div style="position:absolute;bottom:${12 + th*0.05}%;left:${tx+1}%;width:${15+rng()*10}px;height:${3+rng()*2}px;
        background:hsl(${h},${s*0.12}%,16%);opacity:0.2;transform:rotate(${10+rng()*40}deg)"></div>`;
    }
    case 10: { // Bioluminescent pool
      const bx = 20 + rng() * 50;
      const bw = 8 + rng() * 10;
      const bioH = (h + 160) % 360;
      return `<div style="position:absolute;bottom:8%;left:${bx}%;width:${bw}vw;height:${bw*0.3}vw;
        background:radial-gradient(ellipse, hsla(${bioH},65%,50%,0.2), hsla(${bioH},60%,40%,0.08), transparent);
        border-radius:50%;filter:blur(4px);
        animation:pulse-glow ${4+rng()*4}s ease infinite"></div>
        <div style="position:absolute;bottom:7%;left:${bx+1}%;width:${bw-2}vw;height:${bw*0.12}vw;
        background:hsla(${bioH},70%,55%,0.1);border-radius:50%;filter:blur(2px);
        box-shadow:0 0 ${bw}px hsla(${bioH},70%,55%,0.15)"></div>`;
    }
    case 11: { // Ice pillar / frozen geyser
      const ix = 25 + rng() * 40;
      const ih = 60 + rng() * 50;
      return `<div style="position:absolute;bottom:13%;left:${ix}%;width:${8+rng()*6}px;height:${ih}px;
        background:linear-gradient(to top, hsla(${(h+180)%360},30%,55%,0.25), hsla(${(h+180)%360},25%,75%,0.15), transparent);
        clip-path:polygon(20% 100%, 0% 15%, 25% 0%, 75% 0%, 100% 15%, 80% 100%);
        filter:blur(0.5px);opacity:0.4"></div>
        <div style="position:absolute;bottom:${13+ih*0.07}%;left:${ix-2}%;width:${18+rng()*8}px;height:${ih*0.5}px;
        background:radial-gradient(ellipse at center bottom, hsla(${(h+180)%360},40%,70%,0.08), transparent);
        filter:blur(4px)"></div>`;
    }
  }
  return '';
}

// ═════════════════════════════════════════
// INIT LANDSCAPE — Called once on landing
// ═════════════════════════════════════════
function initLandscape(location, system) {
  // Try 3D first
  const has3D = initLandscape3D(location, system);
  
  // If 3D unavailable, build CSS fallback
  if (!has3D) {
    initLandscapeCSS(location, system);
  }
}

function initLandscapeCSS(location, system) {
  const layer = $('landscape-layer');
  const sky = layer.querySelector('.land-sky');
  const celestial = layer.querySelector('.land-celestial');
  const far = layer.querySelector('.land-far');
  const far2 = layer.querySelector('.land-far2');
  const mid = layer.querySelector('.land-mid');
  const near = layer.querySelector('.land-near');
  const foreground = layer.querySelector('.land-foreground');
  const atmos = layer.querySelector('.land-atmosphere');
  const weather = layer.querySelector('.land-weather');

  const p = location.palette;
  const rng = mulberry32(location.seed + 999);
  const locType = location.type.name;

  // ── Store refs for dynamic updates ──
  APP._landEls = { sky, celestial, far, far2, mid, near, foreground, atmos, weather, layer };
  APP._landData = { palette: p, locType, surface: location.surface, temperature: location.temperature, atmosphere: location.atmosphere, starType: system.star.type, starSeed: system.star.seed, age: location.age, seed: location.seed };

  // ── CELESTIAL — build once, store refs for dynamic position updates ──
  celestial.innerHTML = '';
  const sunSize = system.star.type.name === 'Blue Giant' ? 60 :
                  system.star.type.name === 'Orange Giant' ? 55 :
                  system.star.type.name === 'Red Dwarf' ? 25 :
                  system.star.type.name === 'Neutron Star' ? 15 : 40;

  // Sun element
  const sunEl = document.createElement('div');
  sunEl.className = 'land-sun';
  sunEl.style.cssText = `position:absolute;width:${sunSize}px;height:${sunSize}px;
    border-radius:50%;background:${system.star.type.color};
    box-shadow:0 0 ${sunSize}px ${system.star.type.glow}, 0 0 ${sunSize * 3}px ${system.star.type.glow};
    transform:translate(-50%,-50%);transition:opacity 2s ease`;
  celestial.appendChild(sunEl);
  APP._landEls.sun = sunEl;

  // Binary system second star
  if (system.star.type.name === 'Binary System') {
    const sun2Size = sunSize * 0.7;
    const sun2El = document.createElement('div');
    sun2El.className = 'land-sun2';
    sun2El.style.cssText = `position:absolute;width:${sun2Size}px;height:${sun2Size}px;
      border-radius:50%;background:#aaccff;
      box-shadow:0 0 ${sun2Size}px rgba(150,180,255,0.3), 0 0 ${sun2Size * 3}px rgba(150,180,255,0.2);
      transform:translate(-50%,-50%);transition:opacity 2s ease`;
    celestial.appendChild(sun2El);
    APP._landEls.sun2 = sun2El;
    // Binary light overlays
    const warmOverlay = document.createElement('div');
    warmOverlay.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;transition:background 3s ease';
    celestial.appendChild(warmOverlay);
    const coolOverlay = document.createElement('div');
    coolOverlay.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;transition:background 3s ease';
    celestial.appendChild(coolOverlay);
    APP._landEls.binaryWarm = warmOverlay;
    APP._landEls.binaryCool = coolOverlay;
  }

  // Gas giant (for moons)
  if (locType === 'Gas Giant Moon') {
    const giantH = (p.hue + 40) % 360;
    const giantEl = document.createElement('div');
    giantEl.style.cssText = `position:absolute;top:20%;right:-10%;width:50vw;height:50vw;border-radius:50%;
      background:linear-gradient(135deg, hsl(${giantH},40%,30%) 0%, hsl(${giantH+20},50%,20%) 50%, hsl(${giantH},30%,15%) 100%);
      opacity:0.7;box-shadow:inset -20px -10px 60px rgba(0,0,0,0.4)`;
    celestial.appendChild(giantEl);
    // Gas giant bands (slow drift animation)
    for (let b = 0; b < 3; b++) {
      const band = document.createElement('div');
      const bandY = 28 + b * 8;
      const bandAlpha = 0.08 + rng() * 0.06;
      band.style.cssText = `position:absolute;top:${bandY}%;right:-8%;width:48vw;height:${3+rng()*3}px;
        background:hsla(${giantH+10+b*15},30%,${40+b*10}%,${bandAlpha});filter:blur(1px);
        animation:gas-band-drift ${40+b*20}s linear infinite alternate`;
      celestial.appendChild(band);
    }
    // Storm spot
    const stormEl = document.createElement('div');
    const stormH = (giantH + 20) % 360;
    stormEl.style.cssText = `position:absolute;top:${30+rng()*8}%;right:${5+rng()*10}%;width:${30+rng()*20}px;height:${18+rng()*12}px;
      border-radius:50%;background:hsla(${stormH},40%,35%,0.25);box-shadow:0 0 8px hsla(${stormH},40%,35%,0.1)`;
    celestial.appendChild(stormEl);
  }

  // Night stars container (visibility toggled dynamically)
  const nightStarsEl = document.createElement('div');
  nightStarsEl.className = 'land-night-stars';
  nightStarsEl.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;transition:opacity 3s ease';
  const nightRng = mulberry32(location.seed + 5555);
  let starsHtml = '';
  for (let i = 0; i < 80; i++) {
    const sx = nightRng() * 100, sy = nightRng() * 60;
    const ss = 0.5 + nightRng() * 1.5;
    const so = 0.3 + nightRng() * 0.7;
    starsHtml += `<div style="position:absolute;top:${sy}%;left:${sx}%;width:${ss}px;height:${ss}px;border-radius:50%;background:#fff;opacity:${so}"></div>`;
  }
  nightStarsEl.innerHTML = starsHtml;
  celestial.appendChild(nightStarsEl);
  APP._landEls.nightStars = nightStarsEl;

  // Sun reflection for water worlds (hidden initially, shown dynamically)
  if (locType === 'Ocean World' || locType === 'Drifting Liquid Body') {
    const reflEl = document.createElement('div');
    reflEl.className = 'land-sun-reflection';
    reflEl.style.cssText = `position:absolute;width:${sunSize*1.2}px;height:${sunSize*0.6}px;
      border-radius:50%;background:${system.star.type.color};
      box-shadow:0 0 ${sunSize*2}px ${system.star.type.glow};
      filter:blur(6px);transform:translate(-50%,-50%) scaleY(0.4);transition:opacity 2s ease`;
    celestial.appendChild(reflEl);
    APP._landEls.sunReflection = reflEl;
  }

  // ── FAR TERRAIN — build once ──
  far.innerHTML = '';
  far.style.clipPath = 'none';
  far.style.background = 'none';
  far.style.backgroundColor = '';
  far.style.height = '45%';
  far2.innerHTML = '';
  far2.style.clipPath = 'none';
  far2.style.background = 'none';
  far2.style.height = '38%';
  mid.innerHTML = '';
  mid.style.clipPath = 'none';
  mid.style.background = 'none';
  near.innerHTML = '';
  near.style.clipPath = 'none';
  near.style.background = 'none';
  foreground.innerHTML = '';
  foreground.style.clipPath = 'none';
  foreground.style.background = 'none';

  // Store the terrain type for dynamic color updates
  APP._landData.hasStandardTerrain = false;

  if (locType === 'Ocean World' || locType === 'Drifting Liquid Body') {
    far.style.height = '40%';
    APP._landData.isWater = true;
    // Wave elements
    let waveHtml = '';
    for (let w = 0; w < 3; w++) {
      const wY = 50 + w * 18;
      const dur = 4 + w * 1.5;
      waveHtml += `<div class="land-wave" style="position:absolute;bottom:${w*5}%;left:-5%;width:110%;height:${30-w*6}%;
        background:linear-gradient(to bottom, transparent 40%, currentColor 100%);opacity:${0.12-w*0.03};
        animation:wave-bob${w === 0 ? '' : w === 1 ? '2' : '3'} ${dur}s ease-in-out infinite;
        animation-delay:${w*-1.3}s"></div>`;
    }
    far.innerHTML = waveHtml;
    // Bioluminescent water patches at night
    if (location.surface === 'bioluminescent' || locType === 'Drifting Liquid Body') {
      const bioRng = mulberry32(location.seed + 8888);
      let bioHtml = '';
      for (let i = 0; i < 8; i++) {
        const bx = bioRng() * 90 + 5;
        const by = bioRng() * 40 + 50;
        const bs = 15 + bioRng() * 25;
        bioHtml += `<div class="water-bio" style="position:absolute;left:${bx}%;top:${by}%;width:${bs}px;height:${bs*0.6}px;
          border-radius:50%;background:hsla(${(p.hue+160)%360},70%,50%,0.12);
          box-shadow:0 0 ${bs}px hsla(${(p.hue+160)%360},70%,50%,0.08);filter:blur(4px);
          animation:pulse-glow ${3+bioRng()*4}s ease infinite;animation-delay:${bioRng()*-4}s"></div>`;
      }
      far.innerHTML += bioHtml;
    }
  } else if (locType === 'Nebula Pocket') {
    far.style.background = 'transparent';
    APP._landData.isNebula = true;
    // Proto-star knots
    const nebulaRng = mulberry32(location.seed + 6666);
    let knotHtml = '';
    for (let i = 0; i < 6; i++) {
      const kx = nebulaRng() * 80 + 10, ky = nebulaRng() * 50 + 10;
      const ks = 2 + nebulaRng() * 3;
      knotHtml += `<div style="position:absolute;left:${kx}%;top:${ky}%;width:${ks}px;height:${ks}px;
        border-radius:50%;background:hsla(${(p.hue+rng()*60)%360},60%,80%,${0.3+nebulaRng()*0.4});
        box-shadow:0 0 ${ks*3}px hsla(${(p.hue+rng()*60)%360},60%,70%,0.2);
        animation:shimmer ${4+nebulaRng()*6}s ease infinite"></div>`;
    }
    far.innerHTML = knotHtml;
  } else if (locType === 'Ancient Ruins') {
    // Jagged structures
    const shapes = [];
    for (let i = 0; i < 8; i++) {
      const xp = 5 + i * 12 + rng() * 5;
      const h = 30 + rng() * 50;
      const w = 3 + rng() * 8;
      shapes.push(`linear-gradient(to top, hsl(${p.hue},${p.sat * 0.3}%,18%) 0%, transparent ${h}%) ${xp}% 100% / ${w}% 100% no-repeat`);
    }
    far.style.background = shapes.join(', ');
    // Glowing glyphs
    const glyphRng = mulberry32(location.seed + 7700);
    let glyphHtml = '';
    for (let i = 0; i < 5; i++) {
      const gx = 10 + glyphRng() * 75, gy = 30 + glyphRng() * 50;
      const gs = 2 + glyphRng() * 3;
      glyphHtml += `<div style="position:absolute;left:${gx}%;top:${gy}%;width:${gs}px;height:${gs}px;
        border-radius:50%;background:hsla(${(p.hue+60)%360},60%,55%,0.2);
        box-shadow:0 0 ${gs*4}px hsla(${(p.hue+60)%360},60%,55%,0.15);
        animation:shimmer ${3+glyphRng()*5}s ease infinite;animation-delay:${glyphRng()*-4}s"></div>`;
    }
    far.innerHTML = glyphHtml;
    // Broken geometric foreground
    const fgRng = mulberry32(location.seed + 7701);
    let ruinFgHtml = '';
    for (let i = 0; i < 3; i++) {
      const rx = 10 + fgRng() * 70, rw = 20 + fgRng() * 40, rh = 5 + fgRng() * 15;
      ruinFgHtml += `<div style="position:absolute;bottom:${fgRng()*5}%;left:${rx}%;
        width:${rw}px;height:${rh}px;border:1px solid hsla(${p.hue},${p.sat*0.2}%,25%,0.15);
        transform:rotate(${-10+fgRng()*20}deg)"></div>`;
    }
    foreground.innerHTML = ruinFgHtml;
  } else if (locType === 'Asteroid Field') {
    far.style.background = 'transparent';
    far.style.height = '45%';
    let rocks = '';
    for (let i = 0; i < 12; i++) {
      const rx = 5 + rng() * 85, ry = 10 + rng() * 70, rs = 15 + rng() * 40;
      const rot = rng() * 360;
      const rAlpha = 0.4 + rng() * 0.4;
      const drift = 40 + rng() * 60;
      rocks += `<div style="position:absolute;left:${rx}%;top:${ry}%;width:${rs}px;height:${rs * (0.6 + rng() * 0.6)}px;
        background:hsl(${p.hue},${p.sat*0.4}%,20%);border-radius:${rng()*40}% ${rng()*50}% ${rng()*40}% ${rng()*50}%;
        transform:rotate(${rot}deg);opacity:${rAlpha};
        animation:drift-left ${drift}s linear infinite;animation-delay:${rng()*-drift}s"></div>`;
    }
    far.innerHTML = rocks;
  } else if (locType === 'Ring System') {
    far.style.background = 'transparent';
    far.style.clipPath = 'none';
    far.style.height = '100%';
    const giantH = (p.hue + 30) % 360;
    let ringContent = '';
    ringContent += `<div style="position:absolute;top:10%;left:55%;width:45vw;height:45vw;border-radius:50%;
      background:linear-gradient(150deg, hsl(${giantH},35%,25%) 0%, hsl(${giantH+15},40%,15%) 50%, hsl(${giantH},25%,10%) 100%);
      opacity:0.6;box-shadow:inset -15px -8px 40px rgba(0,0,0,0.5)"></div>`;
    ringContent += `<div style="position:absolute;top:30%;left:45%;width:60vw;height:8px;
      background:linear-gradient(90deg, transparent 5%, hsla(${giantH+10},20%,55%,0.3) 20%, hsla(${giantH},30%,50%,0.4) 50%, hsla(${giantH+10},20%,55%,0.3) 80%, transparent 95%);
      transform:rotate(-5deg);filter:blur(1px)"></div>`;
    for (let i = 0; i < 18; i++) {
      const ix = rng() * 100, iy = 20 + rng() * 60, isize = 2 + rng() * 12;
      const ialpha = 0.2 + rng() * 0.5;
      const drift = 30 + rng() * 50;
      const shimmerDur = 3 + rng() * 5;
      ringContent += `<div style="position:absolute;left:${ix}%;top:${iy}%;width:${isize}px;height:${isize * (0.5+rng()*0.8)}px;
        background:hsla(${(giantH+180)%360},15%,70%,${ialpha});border-radius:${rng()*30}% ${rng()*40}%;
        animation:drift-left ${drift}s linear infinite, shimmer ${shimmerDur}s ease infinite;
        animation-delay:${rng()*-drift}s"></div>`;
    }
    far.innerHTML = ringContent;
  } else if (locType === 'Comet') {
    far.style.background = 'transparent';
    far.style.clipPath = 'none';
    far.style.height = '100%';
    let cometContent = '';
    const tailH = (p.hue + 180) % 360;
    cometContent += `<div style="position:absolute;top:25%;right:-10%;width:80vw;height:20vh;
      background:linear-gradient(to left, hsla(${tailH},50%,60%,0.15) 0%, hsla(${tailH+20},40%,50%,0.06) 50%, transparent 100%);
      filter:blur(15px);transform:skewY(-3deg)"></div>`;
    cometContent += `<div style="position:absolute;top:30%;right:-5%;width:60vw;height:8vh;
      background:linear-gradient(to left, hsla(${tailH},60%,70%,0.1) 0%, transparent 80%);
      filter:blur(8px);transform:skewY(-2deg)"></div>`;
    const surfPoints = ['100% 100%', '0% 100%'];
    for (let i = 0; i <= 20; i++) {
      const x = (i / 20) * 100;
      const h = 15 + Math.sin(i * 0.8 + rng() * 5) * 12 + rng() * 8;
      surfPoints.push(`${x}% ${100 - h}%`);
    }
    cometContent += `<div style="position:absolute;bottom:0;left:0;width:100%;height:25%;
      background:linear-gradient(to bottom, hsl(${p.hue},${p.sat*0.3}%,18%) 0%, hsl(${p.hue},${p.sat*0.2}%,12%) 100%);
      clip-path:polygon(${surfPoints.join(', ')})"></div>`;
    for (let i = 0; i < 10; i++) {
      const px = 10 + rng() * 80;
      const dur = 3 + rng() * 5;
      cometContent += `<div style="position:absolute;bottom:${10+rng()*15}%;left:${px}%;width:${1+rng()*2}px;height:${8+rng()*15}px;
        background:hsla(${tailH},40%,70%,${0.15+rng()*0.2});border-radius:50%;filter:blur(2px);
        animation:fall-down ${dur}s linear infinite reverse;animation-delay:${rng()*-dur}s"></div>`;
    }
    far.innerHTML = cometContent;
  } else if (locType === 'Crystalline Spire') {
    // Massive crystal formations jutting from the surface
    APP._landData.hasStandardTerrain = false;
    far.style.background = 'transparent';
    far.style.height = '55%';
    const crystalRng = mulberry32(location.seed + 1111);
    let crystalHtml = '';
    const crystH = p.hue;
    // Towering spires — tall thin polygons with refraction glow
    for (let i = 0; i < 9; i++) {
      const cx = 5 + crystalRng() * 85;
      const cw = 3 + crystalRng() * 6;
      const ch = 35 + crystalRng() * 50;
      const tilt = -8 + crystalRng() * 16;
      const cAlpha = 0.35 + crystalRng() * 0.4;
      const facetH = (crystH + crystalRng() * 40) % 360;
      const glowS = 10 + crystalRng() * 20;
      crystalHtml += `<div style="position:absolute;bottom:0;left:${cx}%;width:${cw}%;height:${ch}%;
        background:linear-gradient(170deg, hsla(${facetH},${p.sat+15}%,55%,${cAlpha}) 0%, hsla(${facetH+20},${p.sat}%,25%,${cAlpha*0.6}) 60%, hsla(${facetH},${p.sat*0.6}%,12%,${cAlpha*0.8}) 100%);
        clip-path:polygon(${30+crystalRng()*15}% 0%, ${55+crystalRng()*20}% 0%, 85% 100%, 15% 100%);
        transform:rotate(${tilt}deg);transform-origin:bottom center;
        box-shadow:0 0 ${glowS}px hsla(${facetH},60%,60%,0.15);filter:brightness(1.1)"></div>`;
      // Inner refraction light
      if (crystalRng() > 0.4) {
        crystalHtml += `<div style="position:absolute;bottom:${ch*0.3}%;left:${cx+cw*0.2}%;width:${cw*0.4}%;height:${ch*0.5}%;
          background:linear-gradient(to top, transparent, hsla(${(facetH+180)%360},70%,70%,${0.08+crystalRng()*0.12}), transparent);
          filter:blur(3px);pointer-events:none"></div>`;
      }
    }
    // Ground crystal field
    const groundPoints = ['100% 100%', '0% 100%'];
    for (let i = 0; i <= 20; i++) {
      const x = (i / 20) * 100;
      const gh = 8 + crystalRng() * 12 + (crystalRng() > 0.7 ? 15 : 0);
      groundPoints.push(`${x}% ${100 - gh}%`);
    }
    crystalHtml += `<div style="position:absolute;bottom:0;left:0;width:100%;height:25%;
      background:linear-gradient(to bottom, hsl(${crystH},${p.sat*0.5}%,16%) 0%, hsl(${crystH},${p.sat*0.3}%,10%) 100%);
      clip-path:polygon(${groundPoints.join(', ')})"></div>`;
    // Ambient prismatic sparkles
    for (let i = 0; i < 15; i++) {
      const sx = crystalRng() * 100, sy = crystalRng() * 80;
      const sparkH = (crystH + crystalRng() * 120) % 360;
      crystalHtml += `<div style="position:absolute;left:${sx}%;top:${sy}%;width:${1+crystalRng()*2}px;height:${1+crystalRng()*2}px;
        border-radius:50%;background:hsla(${sparkH},80%,75%,${0.2+crystalRng()*0.5});
        box-shadow:0 0 ${4+crystalRng()*6}px hsla(${sparkH},80%,70%,0.3);
        animation:shimmer ${2+crystalRng()*4}s ease infinite;animation-delay:${crystalRng()*-4}s"></div>`;
    }
    far.innerHTML = crystalHtml;
  } else if (locType === 'Volcanic Forge') {
    // Extreme volcanic landscape with lava rivers and erupting vents
    APP._landData.hasStandardTerrain = true;
    APP._landData.isVolcanic = true;
    far.style.height = '50%';
    let volcHtml = '';
    const volcRng = mulberry32(location.seed + 2222);
    // Lava rivers glowing from below
    for (let i = 0; i < 4; i++) {
      const lx = 5 + volcRng() * 70;
      const lw = 1 + volcRng() * 3;
      const curve = volcRng() * 40 - 20;
      volcHtml += `<div style="position:absolute;bottom:0;left:${lx}%;width:${lw}%;height:${30+volcRng()*35}%;
        background:linear-gradient(to top, rgba(255,120,20,0.7) 0%, rgba(255,80,10,0.4) 30%, rgba(255,50,0,0.1) 70%, transparent 100%);
        filter:blur(2px);transform:skewX(${curve}deg);
        animation:lava-pulse ${3+volcRng()*3}s ease-in-out infinite;animation-delay:${volcRng()*-3}s"></div>`;
    }
    // Eruption plumes
    for (let i = 0; i < 2; i++) {
      const ex = 15 + volcRng() * 65;
      volcHtml += `<div style="position:absolute;bottom:${35+volcRng()*15}%;left:${ex}%;width:${12+volcRng()*15}px;height:${40+volcRng()*30}px;
        background:radial-gradient(ellipse at bottom, rgba(255,100,20,0.25) 0%, rgba(200,60,10,0.1) 40%, transparent 70%);
        filter:blur(4px);animation:eruption-drift ${6+volcRng()*4}s ease infinite;animation-delay:${volcRng()*-5}s"></div>`;
    }
    // Volcanic mountain silhouettes
    const farPoints = ['100% 100%', '0% 100%'];
    for (let i = 0; i <= 30; i++) {
      const x = (i / 30) * 100;
      const baseH = 25 + Math.sin(i * 0.35 + volcRng() * 5) * 20;
      const peak = volcRng() > 0.85 ? 25 : 0; // occasional sharp volcanic peaks
      const fh = baseH + volcRng() * 12 + peak;
      farPoints.push(`${x}% ${100 - fh}%`);
    }
    far.style.clipPath = `polygon(${farPoints.join(', ')})`;
    far.innerHTML = volcHtml;
    // Ember glow across near terrain
    near.style.height = '15%';
    near.innerHTML = `<div style="position:absolute;bottom:0;left:0;width:100%;height:100%;
      background:linear-gradient(to top, rgba(255,80,20,0.1) 0%, transparent 60%);pointer-events:none"></div>`;
  } else if (locType === 'Frozen Abyss') {
    // Deep ice crevasses with eerie blue glow from subsurface ocean
    APP._landData.hasStandardTerrain = true;
    APP._landData.isFrozen = true;
    far.style.height = '45%';
    const iceRng = mulberry32(location.seed + 3344);
    let iceHtml = '';
    // Ice ridge silhouette
    const farPoints = ['100% 100%', '0% 100%'];
    for (let i = 0; i <= 35; i++) {
      const x = (i / 35) * 100;
      const baseH = 28 + Math.sin(i * 0.3 + iceRng() * 4) * 15 + Math.cos(i * 0.7 + iceRng() * 3) * 8;
      const h = baseH + iceRng() * 6;
      farPoints.push(`${x}% ${100 - h}%`);
    }
    far.style.clipPath = `polygon(${farPoints.join(', ')})`;
    // Subsurface glow crevasses
    for (let i = 0; i < 5; i++) {
      const gx = 8 + iceRng() * 75;
      const gw = 0.5 + iceRng() * 2;
      const gh = 20 + iceRng() * 40;
      const glowH = (p.hue + 180 + iceRng() * 30) % 360;
      iceHtml += `<div style="position:absolute;bottom:0;left:${gx}%;width:${gw}%;height:${gh}%;
        background:linear-gradient(to top, hsla(${glowH},70%,55%,0.3) 0%, hsla(${glowH},60%,45%,0.1) 50%, transparent 100%);
        filter:blur(3px);animation:pulse-glow ${5+iceRng()*4}s ease infinite;animation-delay:${iceRng()*-5}s"></div>`;
    }
    // Frost haze
    iceHtml += `<div style="position:absolute;bottom:0;left:0;width:100%;height:20%;
      background:linear-gradient(to top, hsla(${p.hue},30%,80%,0.08) 0%, transparent 100%);
      pointer-events:none"></div>`;
    far.innerHTML = iceHtml;
  } else if (locType === 'Bioluminescent Jungle') {
    // Dense canopy with brilliant glowing organisms
    APP._landData.hasStandardTerrain = true;
    APP._landData.isBioJungle = true;
    far.style.height = '55%';
    const jungleRng = mulberry32(location.seed + 4455);
    let jungleHtml = '';
    // Canopy layers — overlapping rounded shapes
    for (let layer = 0; layer < 3; layer++) {
      const layerY = 15 + layer * 12;
      let canopyPoints = [`100% 100%`, `0% 100%`];
      for (let i = 0; i <= 20; i++) {
        const x = (i / 20) * 100;
        const ch = layerY + Math.sin(i * 0.5 + jungleRng() * 5) * 12 + Math.sin(i * 1.2 + jungleRng() * 3) * 6 + jungleRng() * 5;
        canopyPoints.push(`${x}% ${100 - ch}%`);
      }
      const layerAlpha = 0.7 - layer * 0.15;
      const layerH = (p.hue + layer * 12) % 360;
      jungleHtml += `<div style="position:absolute;bottom:0;left:0;width:100%;height:${55+layer*8}%;
        background:hsla(${layerH},${p.sat*0.8}%,${12+layer*4}%,${layerAlpha});
        clip-path:polygon(${canopyPoints.join(', ')})"></div>`;
    }
    // Bioluminescent orbs scattered through canopy
    const bioH = (p.hue + 160) % 360;
    const bioH2 = (p.hue + 120) % 360;
    for (let i = 0; i < 25; i++) {
      const bx = jungleRng() * 95;
      const by = 15 + jungleRng() * 65;
      const bs = 2 + jungleRng() * 6;
      const orbH = jungleRng() > 0.5 ? bioH : bioH2;
      const orbL = 50 + jungleRng() * 30;
      jungleHtml += `<div style="position:absolute;left:${bx}%;top:${by}%;width:${bs}px;height:${bs}px;
        border-radius:50%;background:hsla(${orbH},75%,${orbL}%,${0.3+jungleRng()*0.5});
        box-shadow:0 0 ${bs*2}px hsla(${orbH},75%,${orbL}%,0.3), 0 0 ${bs*5}px hsla(${orbH},60%,${orbL}%,0.1);
        animation:pulse-glow ${2+jungleRng()*5}s ease infinite;animation-delay:${jungleRng()*-5}s"></div>`;
    }
    // Hanging vine streaks
    for (let i = 0; i < 6; i++) {
      const vx = 5 + jungleRng() * 85;
      const vh = 15 + jungleRng() * 30;
      jungleHtml += `<div style="position:absolute;top:${20+jungleRng()*20}%;left:${vx}%;width:1px;height:${vh}%;
        background:linear-gradient(to bottom, hsla(${p.hue},${p.sat*0.4}%,20%,0.3), hsla(${bioH},50%,30%,0.15), transparent);
        filter:blur(0.5px)"></div>`;
    }
    far.innerHTML = jungleHtml;
  } else if (locType === 'Pillar Forest') {
    // Towering stone pillars — Zhangjiajie-like vertical columns
    APP._landData.hasStandardTerrain = true;
    far.style.height = '55%';
    const pillarRng = mulberry32(location.seed + 5566);
    let pillarHtml = '';
    // Generate distinct pillars
    for (let i = 0; i < 12; i++) {
      const px = 3 + pillarRng() * 88;
      const pw = 2.5 + pillarRng() * 5;
      const ph = 30 + pillarRng() * 55;
      const depth = pillarRng(); // 0=far, 1=near
      const alpha = 0.25 + depth * 0.35;
      const lightness = 12 + (1 - depth) * 10;
      const lean = -3 + pillarRng() * 6;
      pillarHtml += `<div style="position:absolute;bottom:0;left:${px}%;width:${pw}%;height:${ph}%;
        background:linear-gradient(to top, hsl(${p.hue},${p.sat*0.4}%,${lightness}%) 0%, hsl(${p.hue},${p.sat*0.3}%,${lightness+6}%) 80%, hsl(${p.hue},${p.sat*0.5}%,${lightness+3}%) 100%);
        opacity:${alpha};transform:rotate(${lean}deg);transform-origin:bottom center;
        clip-path:polygon(10% 100%, 0% 5%, 15% 0%, 85% 0%, 100% 5%, 90% 100%)"></div>`;
      // Vegetation on flat tops
      if (pillarRng() > 0.4) {
        pillarHtml += `<div style="position:absolute;bottom:${ph-2}%;left:${px-1}%;width:${pw+2}%;height:${4+pillarRng()*4}%;
          background:radial-gradient(ellipse, hsla(${(p.hue+90)%360},${p.sat*0.6}%,20%,${alpha*0.6}), transparent);
          border-radius:50% 50% 20% 20%;filter:blur(1px)"></div>`;
      }
    }
    // Mist between pillars
    pillarHtml += `<div style="position:absolute;bottom:5%;left:0;width:100%;height:30%;
      background:linear-gradient(to top, hsla(${p.hue},20%,70%,0.06), transparent);
      filter:blur(12px);pointer-events:none"></div>`;
    far.innerHTML = pillarHtml;
  } else if (locType === 'Salt Flats') {
    // Vast reflective plain — minimal terrain with mirror-like surface
    APP._landData.hasStandardTerrain = true;
    APP._landData.isSalt = true;
    far.style.height = '35%';
    const saltRng = mulberry32(location.seed + 6677);
    let saltHtml = '';
    // Low distant mountains on the horizon
    const horizonPoints = ['100% 100%', '0% 100%'];
    for (let i = 0; i <= 40; i++) {
      const x = (i / 40) * 100;
      const h = 5 + Math.sin(i * 0.3 + saltRng() * 5) * 8 + saltRng() * 3;
      horizonPoints.push(`${x}% ${100 - h}%`);
    }
    saltHtml += `<div style="position:absolute;bottom:50%;left:0;width:100%;height:50%;
      background:hsla(${p.hue},${p.sat*0.3}%,20%,0.25);
      clip-path:polygon(${horizonPoints.join(', ')});filter:blur(1px)"></div>`;
    // Reflection line
    saltHtml += `<div style="position:absolute;bottom:35%;left:0;width:100%;height:1px;
      background:linear-gradient(90deg, transparent 5%, hsla(${p.hue},15%,70%,0.1) 30%, hsla(${p.hue},20%,75%,0.15) 50%, hsla(${p.hue},15%,70%,0.1) 70%, transparent 95%)"></div>`;
    // Salt polygon cracks
    for (let i = 0; i < 6; i++) {
      const cx = saltRng() * 80 + 10;
      const cy = 60 + saltRng() * 30;
      const cs = 8 + saltRng() * 15;
      saltHtml += `<div style="position:absolute;left:${cx}%;top:${cy}%;width:${cs}vw;height:${cs*0.5}vw;
        border:1px solid hsla(${p.hue},10%,60%,0.06);border-radius:20%;transform:rotate(${saltRng()*30}deg)"></div>`;
    }
    far.innerHTML = saltHtml;
  } else if (locType === 'Geothermal Springs') {
    // Hot springs with mineral terraces and steam vents
    APP._landData.hasStandardTerrain = true;
    APP._landData.isGeothermal = true;
    far.style.height = '45%';
    const geoRng = mulberry32(location.seed + 7788);
    let geoHtml = '';
    // Terraced mineral pools
    for (let t = 0; t < 4; t++) {
      const tx = 5 + geoRng() * 60;
      const tw = 10 + geoRng() * 20;
      const ty = 55 + t * 10;
      const tH = (p.hue + geoRng() * 40) % 360;
      geoHtml += `<div style="position:absolute;left:${tx}%;top:${ty}%;width:${tw}%;height:${4+geoRng()*3}%;
        background:linear-gradient(to bottom, hsla(${tH},50%,45%,0.2), hsla(${tH},40%,35%,0.1));
        border-radius:50%;border-bottom:1px solid hsla(${tH},30%,60%,0.12)"></div>`;
    }
    // Steam plumes
    for (let s = 0; s < 3; s++) {
      const sx = 15 + geoRng() * 65;
      geoHtml += `<div style="position:absolute;bottom:${25+geoRng()*20}%;left:${sx}%;width:${12+geoRng()*15}px;height:${35+geoRng()*30}px;
        background:linear-gradient(to top, hsla(${p.hue},15%,75%,0.12), hsla(${p.hue},10%,80%,0.04), transparent);
        filter:blur(5px);animation:spore-rise ${7+geoRng()*5}s ease-in-out infinite;animation-delay:${geoRng()*-6}s"></div>`;
    }
    // Mountain backdrop
    const farPoints = ['100% 100%', '0% 100%'];
    for (let i = 0; i <= 30; i++) {
      const x = (i / 30) * 100;
      const baseH = 25 + Math.sin(i * 0.35 + geoRng() * 5) * 18 + geoRng() * 8;
      farPoints.push(`${x}% ${100 - baseH}%`);
    }
    far.style.clipPath = `polygon(${farPoints.join(', ')})`;
    far.innerHTML = geoHtml;
  } else if (locType === 'Badlands') {
    // Layered eroded terrain with exposed strata
    APP._landData.hasStandardTerrain = true;
    far.style.height = '50%';
    const badRng = mulberry32(location.seed + 8899);
    let badHtml = '';
    // Layered strata bands in the exposed cliff face
    const strataColors = [];
    for (let s = 0; s < 6; s++) {
      const sH = (p.hue + badRng() * 30 - 15) % 360;
      const sL = 15 + s * 4 + badRng() * 5;
      strataColors.push(`hsl(${sH},${p.sat*0.4}%,${sL}%)`);
    }
    // Eroded ridge silhouette with strata visible
    const farPoints = ['100% 100%', '0% 100%'];
    for (let i = 0; i <= 35; i++) {
      const x = (i / 35) * 100;
      const baseH = 30 + Math.sin(i * 0.25 + badRng() * 4) * 20;
      // Jagged erosion: sharp variations
      const erosion = (badRng() > 0.7 ? -12 : 0) + badRng() * 8;
      farPoints.push(`${x}% ${100 - baseH - erosion}%`);
    }
    far.style.clipPath = `polygon(${farPoints.join(', ')})`;
    far.style.background = `linear-gradient(to bottom, ${strataColors.join(', ')})`;
    // Hoodoo columns in foreground
    for (let i = 0; i < 5; i++) {
      const hx = 8 + badRng() * 78;
      const hw = 2 + badRng() * 3;
      const hh = 15 + badRng() * 25;
      badHtml += `<div style="position:absolute;bottom:0;left:${hx}%;width:${hw}%;height:${hh}%;
        background:linear-gradient(to top, ${strataColors[2]}, ${strataColors[4]});
        clip-path:polygon(15% 100%, 5% 8%, 30% 0%, 70% 0%, 95% 8%, 85% 100%);
        opacity:0.4"></div>`;
    }
    far.innerHTML = badHtml;
  } else if (locType === 'Floating Mesa') {
    // Anti-gravity terrain — flat-topped chunks hovering above the ground
    APP._landData.hasStandardTerrain = true;
    APP._landData.isFloating = true;
    far.style.height = '65%';
    const floatRng = mulberry32(location.seed + 9911);
    let floatHtml = '';
    // Ground level
    floatHtml += `<div style="position:absolute;bottom:0;left:0;width:100%;height:15%;
      background:linear-gradient(to top, hsl(${p.hue},${p.sat*0.4}%,12%), hsl(${p.hue},${p.sat*0.3}%,16%))"></div>`;
    // Floating mesa chunks at different heights
    for (let i = 0; i < 5; i++) {
      const mx = 5 + floatRng() * 75;
      const mw = 8 + floatRng() * 18;
      const my = 20 + floatRng() * 40; // height off ground
      const mh = 4 + floatRng() * 8;
      const mesaH = (p.hue + floatRng() * 15) % 360;
      const alpha = 0.35 + floatRng() * 0.3;
      // Mesa body
      floatHtml += `<div style="position:absolute;bottom:${my}%;left:${mx}%;width:${mw}%;height:${mh}%;
        background:linear-gradient(to bottom, hsl(${mesaH},${p.sat*0.4}%,22%) 0%, hsl(${mesaH},${p.sat*0.3}%,15%) 100%);
        border-radius:3px;opacity:${alpha};
        box-shadow:0 ${4+floatRng()*4}px ${12+floatRng()*8}px rgba(0,0,0,0.3)"></div>`;
      // Underside glow from whatever is holding it up
      floatHtml += `<div style="position:absolute;bottom:${my-1}%;left:${mx+mw*0.15}%;width:${mw*0.7}%;height:3%;
        background:radial-gradient(ellipse, hsla(${(p.hue+180)%360},50%,55%,${0.08+floatRng()*0.08}), transparent);
        filter:blur(4px)"></div>`;
      // Waterfall from some mesas
      if (floatRng() > 0.5) {
        floatHtml += `<div style="position:absolute;bottom:${my*0.3}%;left:${mx+mw*0.4}%;width:${1+floatRng()*1.5}%;height:${my*0.65}%;
          background:linear-gradient(to bottom, hsla(${(p.hue+180)%360},40%,60%,0.15), hsla(${(p.hue+180)%360},30%,50%,0.05), transparent);
          filter:blur(2px)"></div>`;
      }
    }
    // Floating debris particles
    for (let i = 0; i < 10; i++) {
      const dx = floatRng() * 90 + 5;
      const dy = 20 + floatRng() * 50;
      const ds = 2 + floatRng() * 5;
      floatHtml += `<div style="position:absolute;left:${dx}%;top:${dy}%;width:${ds}px;height:${ds*0.7}px;
        background:hsl(${p.hue},${p.sat*0.3}%,18%);opacity:${0.2+floatRng()*0.2};border-radius:30%;
        animation:wave-bob ${3+floatRng()*4}s ease-in-out infinite;animation-delay:${floatRng()*-4}s"></div>`;
    }
    far.innerHTML = floatHtml;
  } else if (locType === 'Sinkhole World') {
    // Karst landscape with deep cenotes and cave openings
    APP._landData.hasStandardTerrain = true;
    far.style.height = '48%';
    const sinkRng = mulberry32(location.seed + 1122);
    let sinkHtml = '';
    // Terrain with sinkholes
    const farPoints = ['100% 100%', '0% 100%'];
    for (let i = 0; i <= 30; i++) {
      const x = (i / 30) * 100;
      let baseH = 22 + Math.sin(i * 0.4 + sinkRng() * 5) * 15 + sinkRng() * 6;
      // Sinkhole depressions
      if (sinkRng() > 0.75) baseH = Math.max(5, baseH - 15 - sinkRng() * 10);
      farPoints.push(`${x}% ${100 - baseH}%`);
    }
    far.style.clipPath = `polygon(${farPoints.join(', ')})`;
    // Glowing cenote pools at bottom of sinkholes
    for (let i = 0; i < 4; i++) {
      const cx = 10 + sinkRng() * 70;
      const cw = 3 + sinkRng() * 6;
      const poolH = (p.hue + 120 + sinkRng() * 40) % 360;
      sinkHtml += `<div style="position:absolute;bottom:${5+sinkRng()*10}%;left:${cx}%;width:${cw}vw;height:${cw*0.3}vw;
        background:radial-gradient(ellipse, hsla(${poolH},60%,45%,0.25), hsla(${poolH},50%,35%,0.08), transparent);
        border-radius:50%;filter:blur(3px);
        animation:pulse-glow ${4+sinkRng()*5}s ease infinite;animation-delay:${sinkRng()*-5}s"></div>`;
    }
    far.innerHTML = sinkHtml;
  } else if (locType === 'Coastal World') {
    // Dramatic fjords and sea cliffs with crashing waves
    APP._landData.hasStandardTerrain = true;
    APP._landData.isCoastal = true;
    far.style.height = '50%';
    const coastRng = mulberry32(location.seed + 7701);
    let coastHtml = '';
    // Sea layer behind cliffs
    const seaH = (p.hue + 180) % 360;
    coastHtml += `<div style="position:absolute;bottom:0;left:0;width:100%;height:35%;
      background:linear-gradient(to bottom, hsl(${seaH},45%,32%) 0%, hsl(${seaH},50%,22%) 100%)"></div>`;
    // Cliff silhouettes — dramatic vertical drops
    const cliffPoints = ['100% 100%', '0% 100%'];
    for (let i = 0; i <= 40; i++) {
      const x = (i / 40) * 100;
      let h = 25 + Math.sin(i * 0.3 + coastRng() * 5) * 12;
      // Fjord cuts — sharp drops
      if (coastRng() > 0.8) h = Math.max(8, h - 20 - coastRng() * 10);
      // Cliff peaks — abrupt rises
      else if (coastRng() > 0.85) h += 15 + coastRng() * 15;
      h += coastRng() * 5;
      cliffPoints.push(`${x}% ${100 - h}%`);
    }
    far.style.clipPath = `polygon(${cliffPoints.join(', ')})`;
    // Sea stacks and arches
    for (let i = 0; i < 4; i++) {
      const sx = 10 + coastRng() * 75;
      const sw = 1.5 + coastRng() * 3;
      const sh = 8 + coastRng() * 18;
      coastHtml += `<div style="position:absolute;bottom:${5+coastRng()*8}%;left:${sx}%;width:${sw}%;height:${sh}%;
        background:hsl(${p.hue},${p.sat*0.3}%,15%);opacity:${0.4+coastRng()*0.3};
        clip-path:polygon(30% 0, 70% 0, 85% 100%, 15% 100%);border-radius:2px 2px 0 0"></div>`;
    }
    // Wave foam lines
    for (let i = 0; i < 3; i++) {
      const wy = 2 + i * 4;
      const dur = 5 + coastRng() * 3;
      coastHtml += `<div style="position:absolute;bottom:${wy}%;left:0;width:100%;height:1px;
        background:linear-gradient(90deg, transparent 5%, hsla(0,0%,90%,${0.08+coastRng()*0.06}) 30%, hsla(0,0%,90%,${0.1+coastRng()*0.05}) 50%, hsla(0,0%,90%,${0.06}) 70%, transparent 95%);
        animation:wave-bob${i === 0 ? '' : '2'} ${dur}s ease-in-out infinite;animation-delay:${coastRng()*-3}s"></div>`;
    }
    // Seabirds (tiny dots drifting)
    for (let i = 0; i < 5; i++) {
      const bx = coastRng() * 80 + 10, by = 15 + coastRng() * 25;
      coastHtml += `<div style="position:absolute;left:${bx}%;top:${by}%;width:3px;height:1px;
        background:rgba(200,210,220,${0.15+coastRng()*0.15});border-radius:50%;
        animation:drift-left ${60+coastRng()*40}s linear infinite;animation-delay:${coastRng()*-40}s"></div>`;
    }
    far.innerHTML = coastHtml;
  } else if (locType === 'River Delta') {
    // Branching river systems across a wide floodplain
    APP._landData.hasStandardTerrain = true;
    APP._landData.isRiver = true;
    far.style.height = '45%';
    const riverRng = mulberry32(location.seed + 7702);
    let riverHtml = '';
    // Low rolling terrain
    const farPoints = ['100% 100%', '0% 100%'];
    for (let i = 0; i <= 35; i++) {
      const x = (i / 35) * 100;
      const h = 15 + Math.sin(i * 0.25 + riverRng() * 4) * 10 + Math.cos(i * 0.5 + riverRng() * 3) * 5 + riverRng() * 4;
      farPoints.push(`${x}% ${100 - h}%`);
    }
    far.style.clipPath = `polygon(${farPoints.join(', ')})`;
    // River channels — sinuous lines of water cutting through terrain
    const waterH = (p.hue + 160) % 360;
    for (let i = 0; i < 5; i++) {
      const rx = 8 + riverRng() * 60;
      const rw = 0.5 + riverRng() * 1.5;
      const rLen = 30 + riverRng() * 40;
      const curve = -15 + riverRng() * 30;
      const rAlpha = 0.15 + riverRng() * 0.15;
      riverHtml += `<div style="position:absolute;bottom:0;left:${rx}%;width:${rw}%;height:${rLen}%;
        background:linear-gradient(to top, hsla(${waterH},50%,40%,${rAlpha}) 0%, hsla(${waterH},45%,35%,${rAlpha*0.5}) 60%, transparent 100%);
        transform:skewX(${curve}deg);filter:blur(1px)"></div>`;
      // Fork at end
      if (riverRng() > 0.4) {
        riverHtml += `<div style="position:absolute;bottom:0;left:${rx + (riverRng()-0.5)*5}%;width:${rw*0.7}%;height:${rLen*0.5}%;
          background:linear-gradient(to top, hsla(${waterH},45%,38%,${rAlpha*0.7}) 0%, transparent 100%);
          transform:skewX(${curve + 10 + riverRng()*15}deg);filter:blur(1px)"></div>`;
      }
    }
    // Sediment fans at delta mouth
    for (let i = 0; i < 3; i++) {
      const fx = 20 + riverRng() * 50;
      const fw = 8 + riverRng() * 12;
      riverHtml += `<div style="position:absolute;bottom:0;left:${fx}%;width:${fw}%;height:${5+riverRng()*8}%;
        background:radial-gradient(ellipse at top, hsla(${(p.hue+30)%360},30%,28%,0.2), transparent);
        border-radius:50% 50% 0 0"></div>`;
    }
    // Mist over water
    riverHtml += `<div style="position:absolute;bottom:0;left:0;width:100%;height:20%;
      background:linear-gradient(to top, hsla(${waterH},20%,70%,0.04) 0%, transparent 100%);pointer-events:none"></div>`;
    far.innerHTML = riverHtml;
  } else if (locType === 'Island Chain') {
    // Volcanic islands rising from the sea
    APP._landData.hasStandardTerrain = false;
    APP._landData.isIsland = true;
    far.style.height = '50%';
    far.style.clipPath = 'none';
    const islandRng = mulberry32(location.seed + 7703);
    let islandHtml = '';
    // Ocean base
    const seaH = (p.hue + 170) % 360;
    islandHtml += `<div style="position:absolute;bottom:0;left:0;width:100%;height:100%;
      background:linear-gradient(to bottom, hsl(${seaH},40%,28%) 0%, hsl(${seaH},48%,18%) 100%)"></div>`;
    // Islands at varying distances
    for (let i = 0; i < 6; i++) {
      const ix = 5 + islandRng() * 80;
      const iw = 4 + islandRng() * 10;
      const ih = 12 + islandRng() * 25;
      const iy = 25 + islandRng() * 20; // vertical position (depth)
      const iAlpha = 0.3 + (1 - iy/50) * 0.5;
      const ilH = (p.hue + islandRng() * 15) % 360;
      // Island peak
      islandHtml += `<div style="position:absolute;bottom:${iy}%;left:${ix}%;width:${iw}%;height:${ih}%;
        background:linear-gradient(to top, hsl(${ilH},${p.sat*0.4}%,16%) 20%, hsl(${ilH},${p.sat*0.3}%,22%) 60%, hsl(${ilH},${p.sat*0.25}%,28%) 100%);
        clip-path:polygon(${20+islandRng()*15}% 0, ${60+islandRng()*20}% 0, 95% 100%, 5% 100%);
        opacity:${iAlpha}"></div>`;
      // Volcanic steam from peak (some islands)
      if (islandRng() > 0.6) {
        islandHtml += `<div style="position:absolute;bottom:${iy+ih*0.8}%;left:${ix+iw*0.3}%;width:${iw*0.4}%;height:${8+islandRng()*6}%;
          background:radial-gradient(ellipse at bottom, hsla(0,0%,80%,0.06), transparent);
          filter:blur(5px);animation:eruption-drift ${8+islandRng()*6}s ease infinite;animation-delay:${islandRng()*-5}s"></div>`;
      }
    }
    // Wave lines between islands
    for (let i = 0; i < 4; i++) {
      const wy = 30 + i * 5;
      islandHtml += `<div style="position:absolute;bottom:${wy}%;left:0;width:100%;height:1px;
        background:linear-gradient(90deg, transparent, hsla(0,0%,90%,${0.04+islandRng()*0.04}), transparent);
        animation:wave-bob ${5+islandRng()*3}s ease-in-out infinite;animation-delay:${islandRng()*-3}s"></div>`;
    }
    far.innerHTML = islandHtml;
  } else if (locType === 'Storm Peaks') {
    // Extreme jagged peaks with violent atmospheric activity
    APP._landData.hasStandardTerrain = true;
    APP._landData.isStorm = true;
    far.style.height = '55%';
    const stormRng = mulberry32(location.seed + 7704);
    let stormHtml = '';
    // Extremely jagged silhouette with dramatic peaks
    const farPoints = ['100% 100%', '0% 100%'];
    for (let i = 0; i <= 45; i++) {
      const x = (i / 45) * 100;
      let h = 20 + Math.sin(i * 0.35 + stormRng() * 5) * 15;
      // Dramatic spikes
      if (stormRng() > 0.6) h += 20 + stormRng() * 25;
      else h += stormRng() * 8;
      farPoints.push(`${x}% ${100 - h}%`);
    }
    far.style.clipPath = `polygon(${farPoints.join(', ')})`;
    // Lightning flashes (CSS animated bright patches)
    for (let i = 0; i < 3; i++) {
      const lx = 15 + stormRng() * 65;
      const ly = 10 + stormRng() * 30;
      const lw = 1 + stormRng() * 2;
      stormHtml += `<div style="position:absolute;left:${lx}%;top:${ly}%;width:${lw}px;height:${15+stormRng()*25}%;
        background:linear-gradient(to bottom, hsla(220,60%,85%,0.35), hsla(240,50%,70%,0.15), transparent);
        filter:blur(1px);animation:shimmer ${2+stormRng()*3}s ease infinite;animation-delay:${stormRng()*-4}s;
        transform:skewX(${-5+stormRng()*10}deg)"></div>`;
    }
    // Heavy cloud banks
    for (let i = 0; i < 4; i++) {
      const cx = stormRng() * 80;
      const cy = 5 + stormRng() * 25;
      const cw = 15 + stormRng() * 25;
      stormHtml += `<div style="position:absolute;left:${cx}%;top:${cy}%;width:${cw}vw;height:${3+stormRng()*5}vw;
        background:radial-gradient(ellipse, hsla(${p.hue},20%,25%,${0.15+stormRng()*0.15}), transparent);
        border-radius:50%;filter:blur(12px);
        animation:drift-left ${80+stormRng()*50}s linear infinite;animation-delay:${stormRng()*-60}s"></div>`;
    }
    // Wind streaks
    for (let i = 0; i < 6; i++) {
      const wy = 20 + stormRng() * 40;
      stormHtml += `<div style="position:absolute;top:${wy}%;left:0;width:100%;height:1px;
        background:linear-gradient(90deg, transparent 10%, hsla(0,0%,80%,${0.04+stormRng()*0.03}) 40%, transparent 90%);
        animation:drift-left ${20+stormRng()*15}s linear infinite;animation-delay:${stormRng()*-15}s"></div>`;
    }
    far.innerHTML = stormHtml;
  } else if (locType === 'Glacial Shelf') {
    // Massive glacial cascades with crevasse network
    APP._landData.hasStandardTerrain = true;
    APP._landData.isGlacial = true;
    far.style.height = '48%';
    const glacRng = mulberry32(location.seed + 7705);
    let glacHtml = '';
    // Terraced glacial steps
    const farPoints = ['100% 100%', '0% 100%'];
    for (let i = 0; i <= 35; i++) {
      const x = (i / 35) * 100;
      let h = 20 + Math.sin(i * 0.25 + glacRng() * 4) * 12;
      // Glacial steps — flat sections with sudden drops
      const step = Math.floor((i + glacRng() * 3) / 5);
      h += step * 4;
      h += glacRng() * 3;
      farPoints.push(`${x}% ${100 - h}%`);
    }
    far.style.clipPath = `polygon(${farPoints.join(', ')})`;
    // Crevasses — deep blue/cyan glowing cracks
    const crevH = (p.hue + 190) % 360;
    for (let i = 0; i < 6; i++) {
      const cx = 5 + glacRng() * 80;
      const cw = 0.3 + glacRng() * 0.8;
      const ch = 15 + glacRng() * 30;
      glacHtml += `<div style="position:absolute;bottom:${glacRng()*15}%;left:${cx}%;width:${cw}%;height:${ch}%;
        background:linear-gradient(to top, hsla(${crevH},65%,50%,0.25) 0%, hsla(${crevH},55%,40%,0.1) 50%, transparent 100%);
        filter:blur(2px)"></div>`;
    }
    // Ice shelf calving face — vertical blue-white wall
    glacHtml += `<div style="position:absolute;bottom:0;left:30%;width:40%;height:8%;
      background:linear-gradient(to top, hsl(${crevH},30%,75%), hsl(${crevH},25%,65%));
      opacity:0.15;clip-path:polygon(0 0, 100% 20%, 100% 100%, 0 100%)"></div>`;
    // Frost haze along the surface
    glacHtml += `<div style="position:absolute;bottom:0;left:0;width:100%;height:15%;
      background:linear-gradient(to top, hsla(${crevH},15%,85%,0.06) 0%, transparent 100%)"></div>`;
    far.innerHTML = glacHtml;
  } else if (locType === 'Caldera World') {
    // Massive caldera with active magma chamber
    APP._landData.hasStandardTerrain = true;
    APP._landData.isCaldera = true;
    far.style.height = '50%';
    const calRng = mulberry32(location.seed + 7706);
    let calHtml = '';
    // Caldera rim — rises on both sides, dips dramatically in center
    const farPoints = ['100% 100%', '0% 100%'];
    for (let i = 0; i <= 40; i++) {
      const x = (i / 40) * 100;
      const center = Math.abs(x - 50) / 50; // 0 at center, 1 at edges
      const rimH = 20 + center * 35 + Math.sin(i * 0.5 + calRng() * 4) * 8 + calRng() * 5;
      farPoints.push(`${x}% ${100 - rimH}%`);
    }
    far.style.clipPath = `polygon(${farPoints.join(', ')})`;
    // Magma glow from caldera center
    calHtml += `<div style="position:absolute;bottom:0;left:25%;width:50%;height:25%;
      background:radial-gradient(ellipse at bottom, rgba(255,100,20,0.25) 0%, rgba(255,60,10,0.1) 40%, transparent 70%);
      filter:blur(6px);animation:lava-pulse ${5+calRng()*3}s ease-in-out infinite"></div>`;
    // Lava veins down the inner walls
    for (let i = 0; i < 4; i++) {
      const lx = 30 + calRng() * 40;
      const lw = 0.5 + calRng() * 1;
      calHtml += `<div style="position:absolute;bottom:${calRng()*10}%;left:${lx}%;width:${lw}%;height:${15+calRng()*20}%;
        background:linear-gradient(to top, rgba(255,100,20,0.4) 0%, rgba(255,70,10,0.15) 40%, transparent 100%);
        filter:blur(2px);animation:lava-pulse ${4+calRng()*4}s ease-in-out infinite;animation-delay:${calRng()*-4}s"></div>`;
    }
    // Smoke plumes rising from center
    for (let i = 0; i < 3; i++) {
      const sx = 35 + calRng() * 30;
      calHtml += `<div style="position:absolute;bottom:${10+calRng()*15}%;left:${sx}%;width:${6+calRng()*10}vw;height:${15+calRng()*20}%;
        background:radial-gradient(ellipse at bottom, hsla(0,0%,30%,${0.08+calRng()*0.06}), transparent);
        filter:blur(8px);animation:eruption-drift ${10+calRng()*8}s ease infinite;animation-delay:${calRng()*-6}s"></div>`;
    }
    far.innerHTML = calHtml;
  } else if (locType === 'Tidally Locked World') {
    // One half blazing light, other half frozen dark — dramatic terminator line
    APP._landData.hasStandardTerrain = true;
    APP._landData.isTidallyLocked = true;
    far.style.height = '45%';
    const tidRng = mulberry32(location.seed + 7707);
    let tidHtml = '';
    // Terrain silhouette
    const farPoints = ['100% 100%', '0% 100%'];
    for (let i = 0; i <= 35; i++) {
      const x = (i / 35) * 100;
      const h = 22 + Math.sin(i * 0.35 + tidRng() * 5) * 15 + Math.cos(i * 0.6 + tidRng() * 3) * 8 + tidRng() * 6;
      farPoints.push(`${x}% ${100 - h}%`);
    }
    far.style.clipPath = `polygon(${farPoints.join(', ')})`;
    // Terminator gradient — bright side vs dark side
    tidHtml += `<div style="position:absolute;top:0;left:0;width:100%;height:100%;
      background:linear-gradient(90deg, rgba(0,0,0,0.35) 0%, rgba(0,0,0,0.15) 35%, transparent 50%, rgba(255,200,120,0.06) 70%, rgba(255,180,80,0.1) 100%);
      pointer-events:none"></div>`;
    // Frozen side features — ice crystals on left
    for (let i = 0; i < 4; i++) {
      const fx = 2 + tidRng() * 20;
      const fy = 30 + tidRng() * 40;
      tidHtml += `<div style="position:absolute;left:${fx}%;top:${fy}%;width:${1+tidRng()*2}px;height:${1+tidRng()*2}px;
        border-radius:50%;background:hsla(200,60%,80%,${0.15+tidRng()*0.2});
        box-shadow:0 0 ${3+tidRng()*4}px hsla(200,60%,80%,0.15);
        animation:shimmer ${3+tidRng()*4}s ease infinite;animation-delay:${tidRng()*-3}s"></div>`;
    }
    // Heated side — heat shimmer on right
    tidHtml += `<div style="position:absolute;top:0;right:0;width:40%;height:100%;
      animation:heat-shimmer 6s ease-in-out infinite;pointer-events:none"></div>`;
    // Twilight band in the center — habitable strip glow
    tidHtml += `<div style="position:absolute;top:0;left:42%;width:16%;height:100%;
      background:linear-gradient(to bottom, hsla(${(p.hue+60)%360},30%,50%,0.04) 0%, hsla(${(p.hue+60)%360},40%,45%,0.06) 60%, transparent 100%);
      filter:blur(8px)"></div>`;
    far.innerHTML = tidHtml;
  } else {
    // Standard terrain — varies profile by surface type
    APP._landData.hasStandardTerrain = true;

    // Surface-dependent terrain profile parameters
    const surf = location.surface;
    const tFreq = surf === 'desert' ? 0.2 : surf === 'canyon' ? 0.6 : surf === 'crystal' || surf === 'glass' ? 0.7 :
                  surf === 'tundra' || surf === 'salt' ? 0.15 : surf === 'fungal' || surf === 'coral' ? 0.5 :
                  surf === 'metallic' ? 0.55 : surf === 'storm' ? 0.65 : 0.4;
    const tAmp = surf === 'desert' ? 12 : surf === 'canyon' ? 30 : surf === 'crystal' || surf === 'glass' ? 28 :
                 surf === 'tundra' || surf === 'salt' ? 8 : surf === 'fungal' || surf === 'coral' ? 18 :
                 surf === 'metallic' ? 22 : surf === 'storm' ? 35 : 25;
    const tBase = surf === 'desert' || surf === 'salt' ? 18 : surf === 'tundra' ? 15 :
                  surf === 'storm' || surf === 'canyon' ? 35 : surf === 'crystal' ? 32 : 30;
    const tJagged = surf === 'canyon' || surf === 'crystal' || surf === 'metallic' || surf === 'obsidian' || surf === 'storm';
    const tSmooth = surf === 'desert' || surf === 'tundra' || surf === 'moss' || surf === 'salt' || surf === 'bone';

    // FAR ridge
    const farPoints = ['100% 100%', '0% 100%'];
    for (let i = 0; i <= 30; i++) {
      const x = (i / 30) * 100;
      let baseH = tBase + Math.sin(i * tFreq + rng() * 6) * tAmp + Math.sin(i * (tFreq * 0.4) + rng() * 3) * (tAmp * 0.5);
      if (tJagged && rng() > 0.65) baseH += 10 + rng() * 15; // sharp peaks
      if (tSmooth) baseH += rng() * 3; else baseH += rng() * 10;
      // Canyon cuts
      if (surf === 'canyon' && rng() > 0.8) baseH = Math.max(10, baseH - 18 - rng() * 10);
      farPoints.push(`${x}% ${100 - baseH}%`);
    }
    far.style.clipPath = `polygon(${farPoints.join(', ')})`;
    far.style.height = '45%';

    // FAR2 ridge (atmospheric haze layer between far and mid)
    const far2Rng = mulberry32(location.seed + 2345);
    const far2Points = ['100% 100%', '0% 100%'];
    for (let i = 0; i <= 25; i++) {
      const x = (i / 25) * 100;
      const baseH = 25 + Math.sin(i * 0.5 + far2Rng() * 5) * 20 + Math.sin(i * 0.2 + far2Rng() * 4) * 10;
      const h = baseH + far2Rng() * 8;
      far2Points.push(`${x}% ${100 - h}%`);
    }
    far2.style.clipPath = `polygon(${far2Points.join(', ')})`;
    far2.style.height = '38%';

    // MID ridge
    const midRng = mulberry32(location.seed + 1234);
    const midPoints = ['100% 100%', '0% 100%'];
    for (let i = 0; i <= 25; i++) {
      const x = (i / 25) * 100;
      const h = 20 + Math.sin(i * 0.6 + midRng() * 4) * 18 + midRng() * 8;
      midPoints.push(`${x}% ${100 - h}%`);
    }
    mid.style.clipPath = `polygon(${midPoints.join(', ')})`;
    mid.style.height = '30%';

    // Heat shimmer for hot worlds
    if (location.temperature === 'molten' || location.temperature === 'warm') {
      far.style.animation = 'heat-shimmer 8s ease-in-out infinite';
    }

    // Surface texture overlay on mid terrain
    const texCSS = getSurfaceTextureCSS(location.surface);
    if (texCSS !== 'none') {
      const texDiv = document.createElement('div');
      texDiv.className = 'surface-texture';
      texDiv.style.background = texCSS;
      mid.appendChild(texDiv);
    }

    // Foreground silhouettes
    const fgRng = mulberry32(location.seed + 4444);
    const fgCount = 3 + Math.floor(fgRng() * 4);
    const silhouettes = generateForegroundSilhouettes(fgRng, location.surface, p, fgCount);
    let fgHtml = '';
    silhouettes.forEach(sil => {
      fgHtml += `<div class="fg-silhouette" style="position:absolute;bottom:0;left:0;width:100%;height:100%;
        clip-path:${sil.points};transition:background-color 3s ease"></div>`;
    });
    foreground.innerHTML = fgHtml;

    // Landmark (30% chance on standard terrain)
    const lmRng = mulberry32(location.seed + 3333);
    const landmarkHtml = generateLandmark(lmRng, location.surface, p);
    if (landmarkHtml) {
      far.innerHTML = landmarkHtml;
    }

    // Near terrain
    near.style.height = '12%';
  }

  // ── ATMOSPHERE — particles created once, CSS animated ──
  atmos.innerHTML = '';
  if (location.atmosphere === 'dense' || location.atmosphere === 'moderate') {
    let cloudHtml = '';
    const cloudCount = location.atmosphere === 'dense' ? 9 : 6;
    for (let i = 0; i < cloudCount; i++) {
      const cW = 180 + rng() * 400;
      const cH = 35 + rng() * 80;
      const cY = 5 + rng() * 45;
      const dur = 50 + rng() * 90;
      const delay = rng() * -60;
      const alpha = 0.05 + rng() * (location.atmosphere === 'dense' ? 0.2 : 0.14);
      cloudHtml += `<div class="cloud" style="width:${cW}px;height:${cH}px;top:${cY}%;
        opacity:${alpha};animation-duration:${dur}s;animation-delay:${delay}s"></div>`;
    }
    atmos.innerHTML = cloudHtml;
  }

  if (location.surface === 'bioluminescent' || locType === 'Bioluminescent Jungle') {
    const bioRng2 = mulberry32(location.seed + 9999);
    let bioHtml = '';
    const bioCount = locType === 'Bioluminescent Jungle' ? 45 : 30;
    const bioHue1 = (p.hue + 155) % 360;
    const bioHue2 = (p.hue + 190) % 360;
    for (let i = 0; i < bioCount; i++) {
      const bx = bioRng2() * 100, by = 55 + bioRng2() * 42;
      const bs = 2 + bioRng2() * 6;
      const bh = bioRng2() > 0.5 ? bioHue1 : bioHue2;
      const bl = 55 + bioRng2() * 25;
      bioHtml += `<div class="land-bio-particle" style="position:absolute;left:${bx}%;top:${by}%;width:${bs}px;height:${bs}px;
        border-radius:50%;background:hsl(${bh},88%,${bl}%);
        box-shadow:0 0 ${bs*3}px hsl(${bh},85%,${bl}%), 0 0 ${bs*6}px hsla(${bh},80%,${bl}%,0.3);
        animation:shimmer ${1.5+bioRng2()*3}s ease infinite;animation-delay:${bioRng2()*-3}s;
        transition:opacity 3s ease"></div>`;
    }
    atmos.innerHTML += bioHtml;
  }

  // Crystal sparkle particles in atmosphere
  if (location.surface === 'crystal' || location.surface === 'prismatic' || location.surface === 'glass') {
    const crystRng = mulberry32(location.seed + 7770);
    let crystHtml = '';
    const crystHue = location.surface === 'prismatic' ? p.hue : (p.hue + 120) % 360;
    for (let i = 0; i < 18; i++) {
      const cx = crystRng() * 100, cy = 50 + crystRng() * 48;
      const cs = 1 + crystRng() * 2;
      const hue = location.surface === 'prismatic' ? (crystRng() * 360) : crystHue;
      crystHtml += `<div style="position:absolute;left:${cx}%;top:${cy}%;width:${cs}px;height:${cs}px;
        border-radius:50%;background:hsl(${hue},70%,80%);box-shadow:0 0 ${cs*3}px hsl(${hue},70%,75%);
        animation:shimmer ${1.5+crystRng()*2}s ease infinite;animation-delay:${crystRng()*-2}s"></div>`;
    }
    atmos.innerHTML += crystHtml;
  }

  // Fungal spore particles rising
  if (location.surface === 'fungal') {
    const sporeRng = mulberry32(location.seed + 6600);
    let sporeHtml = '';
    for (let i = 0; i < 12; i++) {
      const sx = sporeRng() * 100;
      const dur = 6 + sporeRng() * 8;
      const size = 1.5 + sporeRng() * 2;
      sporeHtml += `<div style="position:absolute;left:${sx}%;bottom:${5+sporeRng()*15}%;width:${size}px;height:${size}px;
        border-radius:50%;background:hsla(${(p.hue+100)%360},50%,65%,0.4);
        box-shadow:0 0 ${size*2}px hsla(${(p.hue+100)%360},50%,60%,0.2);
        animation:spore-rise ${dur}s ease-in-out infinite;animation-delay:${sporeRng()*-dur}s"></div>`;
    }
    atmos.innerHTML += sporeHtml;
  }

  if (location.surface === 'volcanic' || location.temperature === 'molten' || locType === 'Volcanic Forge') {
    let ashHtml = '';
    const ashCount = locType === 'Volcanic Forge' ? 35 : 20;
    for (let i = 0; i < ashCount; i++) {
      const ax = rng() * 100;
      const dur = 3 + rng() * 5;
      const emberGlow = locType === 'Volcanic Forge' ? 0.6 + rng() * 0.3 : 0.4 + rng() * 0.3;
      ashHtml += `<div class="particle-fall" style="left:${ax}%;height:${2+rng()*3}px;
        background:rgba(255,${60+rng()*120},${20+rng()*40},${emberGlow});
        box-shadow:0 0 ${3+rng()*4}px rgba(255,${80+rng()*80},20,0.3);
        animation-duration:${dur}s;animation-delay:${rng()*-6}s"></div>`;
    }
    atmos.innerHTML += ashHtml;
  }

  if (location.temperature === 'frozen' || location.surface === 'tundra' || locType === 'Frozen Abyss') {
    let snowHtml = '';
    const snowCount = locType === 'Frozen Abyss' ? 50 : 35;
    for (let i = 0; i < snowCount; i++) {
      const sx = rng() * 100;
      const dur = 4 + rng() * 9;
      const size = 1 + rng() * 2.5;
      snowHtml += `<div class="particle-fall" style="left:${sx}%;height:${size}px;width:${size}px;
        background:rgba(210,225,255,0.5);border-radius:50%;
        animation-duration:${dur}s;animation-delay:${rng()*-8}s"></div>`;
    }
    atmos.innerHTML += snowHtml;
  }

  // Crystalline Spire — prismatic motes floating
  if (locType === 'Crystalline Spire') {
    const moteRng = mulberry32(location.seed + 1199);
    let moteHtml = '';
    for (let i = 0; i < 20; i++) {
      const mx = moteRng() * 100, my = 30 + moteRng() * 60;
      const ms = 1 + moteRng() * 2;
      const mh = (p.hue + moteRng() * 120) % 360;
      const mdur = 3 + moteRng() * 6;
      moteHtml += `<div style="position:absolute;left:${mx}%;top:${my}%;width:${ms}px;height:${ms}px;
        border-radius:50%;background:hsla(${mh},85%,75%,${0.3+moteRng()*0.4});
        box-shadow:0 0 ${ms*4}px hsla(${mh},80%,70%,0.4);
        animation:shimmer ${mdur}s ease infinite, spore-rise ${mdur*3}s ease-in-out infinite;
        animation-delay:${moteRng()*-mdur}s"></div>`;
    }
    atmos.innerHTML += moteHtml;
  }

  // Desert/canyon dust particles
  if (location.surface === 'desert' || location.surface === 'canyon' || location.surface === 'sulphur') {
    const dustRng = mulberry32(location.seed + 8800);
    let dustHtml = '';
    const dustHue = location.surface === 'sulphur' ? 55 : p.hue;
    for (let i = 0; i < 10; i++) {
      const dy = 75 + dustRng() * 20;
      const dur = 8 + dustRng() * 12;
      dustHtml += `<div style="position:absolute;top:${dy}%;left:${dustRng()*80}%;width:${30+dustRng()*50}px;height:${3+dustRng()*4}px;
        background:hsla(${dustHue},${p.sat*0.3}%,${50}%,0.06);border-radius:50%;filter:blur(3px);
        animation:fog-drift ${dur}s ease-in-out infinite;animation-delay:${dustRng()*-dur}s"></div>`;
    }
    atmos.innerHTML += dustHtml;
  }

  // Plasma surface — crackling energy motes
  if (location.surface === 'plasma') {
    const plasmaRng = mulberry32(location.seed + 11100);
    let plasmaHtml = '';
    const plasmaH1 = (p.hue + 120) % 360;
    const plasmaH2 = (p.hue + 200) % 360;
    for (let i = 0; i < 20; i++) {
      const px = plasmaRng() * 95;
      const py = 40 + plasmaRng() * 55;
      const ps = 1.5 + plasmaRng() * 4;
      const ph = plasmaRng() > 0.5 ? plasmaH1 : plasmaH2;
      plasmaHtml += `<div style="position:absolute;left:${px}%;top:${py}%;width:${ps}px;height:${ps}px;
        border-radius:50%;background:hsla(${ph},85%,65%,${0.3+plasmaRng()*0.4});
        box-shadow:0 0 ${ps*3}px hsla(${ph},85%,60%,0.4), 0 0 ${ps*6}px hsla(${ph},70%,50%,0.15);
        animation:shimmer ${0.8+plasmaRng()*2}s ease infinite;animation-delay:${plasmaRng()*-2}s;
        transition:opacity 3s ease"></div>`;
    }
    atmos.innerHTML += plasmaHtml;
  }

  // Obsidian — glass shard glints
  if (location.surface === 'obsidian') {
    const obsRng = mulberry32(location.seed + 11200);
    let obsHtml = '';
    for (let i = 0; i < 12; i++) {
      const ox = obsRng() * 90 + 5;
      const oy = 55 + obsRng() * 40;
      const os = 1 + obsRng() * 1.5;
      obsHtml += `<div style="position:absolute;left:${ox}%;top:${oy}%;width:${os}px;height:${os*2}px;
        background:hsla(${(p.hue+180)%360},20%,85%,${0.2+obsRng()*0.4});
        transform:rotate(${obsRng()*180}deg);
        animation:shimmer ${2+obsRng()*4}s ease infinite;animation-delay:${obsRng()*-4}s"></div>`;
    }
    atmos.innerHTML += obsHtml;
  }

  // Bone surface — drifting pale dust
  if (location.surface === 'bone') {
    const boneRng = mulberry32(location.seed + 11300);
    let boneHtml = '';
    for (let i = 0; i < 8; i++) {
      const by = 70 + boneRng() * 25;
      const dur = 10 + boneRng() * 15;
      boneHtml += `<div style="position:absolute;top:${by}%;left:${boneRng()*80}%;width:${25+boneRng()*40}px;height:${2+boneRng()*3}px;
        background:hsla(30,15%,65%,0.05);border-radius:50%;filter:blur(2px);
        animation:fog-drift ${dur}s ease-in-out infinite;animation-delay:${boneRng()*-dur}s"></div>`;
    }
    atmos.innerHTML += boneHtml;
  }

  // Geothermal — steam wisps
  if (locType === 'Geothermal Springs') {
    const geoSteamRng = mulberry32(location.seed + 11400);
    let steamHtml = '';
    for (let i = 0; i < 8; i++) {
      const sx = 10 + geoSteamRng() * 75;
      const dur = 8 + geoSteamRng() * 8;
      steamHtml += `<div style="position:absolute;bottom:${10+geoSteamRng()*25}%;left:${sx}%;width:${15+geoSteamRng()*20}px;height:${30+geoSteamRng()*25}px;
        background:linear-gradient(to top, hsla(${p.hue},15%,75%,0.08), transparent);
        filter:blur(6px);animation:spore-rise ${dur}s ease-in-out infinite;animation-delay:${geoSteamRng()*-dur}s"></div>`;
    }
    atmos.innerHTML += steamHtml;
  }

  // Mycelium — tiny thread-like particles connecting
  if (location.surface === 'mycelium') {
    const mycRng = mulberry32(location.seed + 11500);
    let mycHtml = '';
    for (let i = 0; i < 15; i++) {
      const mx = mycRng() * 90 + 5;
      const my = 60 + mycRng() * 35;
      const mw = 20 + mycRng() * 40;
      const mh = 0.5 + mycRng() * 1;
      const mycH = (p.hue + 60 + mycRng() * 40) % 360;
      mycHtml += `<div style="position:absolute;left:${mx}%;top:${my}%;width:${mw}px;height:${mh}px;
        background:hsla(${mycH},30%,50%,${0.05+mycRng()*0.06});
        transform:rotate(${-20+mycRng()*40}deg);border-radius:50%"></div>`;
    }
    atmos.innerHTML += mycHtml;
  }

  // Aurora element — stronger effect with multiple bands
  if (location.atmosphere === 'thin' || location.atmosphere === 'none' || location.surface === 'magnetic') {
    const auroraRng = mulberry32(location.seed + 4444);
    const auroraEl = document.createElement('div');
    const ah1 = (p.auroraHue || (p.hue + 120)) % 360;
    const ah2 = (ah1 + 40) % 360;
    auroraEl.className = 'land-aurora';
    auroraEl.style.cssText = `position:absolute;top:3%;left:5%;width:90%;height:35%;
      background:linear-gradient(90deg, transparent 5%, hsla(${ah1},75%,55%,0.12) 25%, hsla(${ah2},65%,45%,0.1) 50%, hsla(${ah1},70%,50%,0.08) 75%, transparent 95%);
      filter:blur(18px);animation:aurora 10s ease infinite;transition:opacity 3s ease`;
    atmos.appendChild(auroraEl);
    // Second band
    if (location.surface === 'magnetic' || auroraRng() > 0.5) {
      const auroraEl2 = document.createElement('div');
      const ah3 = (ah1 + 80) % 360;
      auroraEl2.className = 'land-aurora';
      auroraEl2.style.cssText = `position:absolute;top:8%;left:15%;width:70%;height:20%;
        background:linear-gradient(90deg, transparent, hsla(${ah3},60%,50%,0.08), hsla(${ah1},55%,45%,0.06), transparent);
        filter:blur(25px);animation:aurora 15s ease infinite reverse;transition:opacity 3s ease`;
      atmos.appendChild(auroraEl2);
    }
    APP._landEls.aurora = auroraEl;
  }

  // ── WEATHER SYSTEMS — created once, CSS animated ──
  weather.innerHTML = '';
  if (location.surface === 'storm') {
    // Lightning timer (setTimeout chain, not in main loop)
    APP._lightningTimer = setTimeout(function flash() {
      if (APP.state !== 'landed' || APP.focusMode) {
        APP._lightningTimer = setTimeout(flash, 15000 + Math.random() * 30000);
        return;
      }
      weather.innerHTML = '<div style="position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(255,255,255,0.04);pointer-events:none"></div>';
      setTimeout(() => { weather.innerHTML = ''; }, 120);
      APP._lightningTimer = setTimeout(flash, 20000 + Math.random() * 40000);
    }, 15000 + Math.random() * 25000);
  }

  if (location.surface === 'desert' || (location.atmosphere === 'thin' && location.temperature !== 'frozen')) {
    // Fog banks drifting low
    let fogHtml = '';
    const fogRng = mulberry32(location.seed + 5500);
    for (let i = 0; i < 2; i++) {
      const fW = 40 + fogRng() * 40;
      const fY = 65 + fogRng() * 20;
      const dur = 60 + fogRng() * 60;
      fogHtml += `<div style="position:absolute;top:${fY}%;left:${fogRng()*60}%;width:${fW}vw;height:${8+fogRng()*10}vh;
        background:hsla(${p.hue},${p.sat*0.3}%,${50}%,0.04);border-radius:50%;filter:blur(30px);
        animation:fog-drift ${dur}s ease-in-out infinite;animation-delay:${fogRng()*-dur}s"></div>`;
    }
    weather.innerHTML = fogHtml;
  }

  // Meteor showers for thin/no atmosphere at night (created but shown dynamically)
  if (location.atmosphere === 'thin' || location.atmosphere === 'none') {
    APP._landData.canMeteors = true;
  }

  // ── Initial lighting update ──
  updateLandscapeLighting();
}

// ═════════════════════════════════════════
// UPDATE LANDSCAPE LIGHTING — Called from main loop
// ═════════════════════════════════════════
function updateLandscapeLighting() {
  if (!APP._landEls || !APP._landData) return;
  const els = APP._landEls;
  const data = APP._landData;
  const p = data.palette;
  const dayP = APP.dayProgress;
  const skyBright = Math.sin(dayP * Math.PI);

  // ── Golden hour injection — dramatic warm tones ──
  let goldenMix = 0;
  if (dayP > 0.04 && dayP < 0.22) {
    // Sunrise golden hour
    goldenMix = dayP < 0.12 ? (dayP - 0.04) / 0.08 : (0.22 - dayP) / 0.1;
  } else if (dayP > 0.78 && dayP < 0.96) {
    // Sunset golden hour
    goldenMix = dayP < 0.88 ? (dayP - 0.78) / 0.1 : (0.96 - dayP) / 0.08;
  }
  goldenMix = Math.max(0, Math.min(1, goldenMix)) * 0.55; // stronger golden hour

  // ── SKY — blend curated day/night zenith and horizon ──
  const ns = p.nightSignature || {};
  const nightFactor = 1 - skyBright; // 0 at noon, 1 at midnight
  
  // Use curated arrays if available, fall back to legacy
  const skyZenith = (p.skyDayZenith && p.skyNightZenith) ?
    lerpHSL(p.skyNightZenith, p.skyDayZenith, skyBright) :
    [p.hue, lerp(p.sat * 0.4, p.sat * 0.85, skyBright), lerp(3, 62, skyBright)];
  const skyHorizon = (p.skyDayHorizon && p.skyNightHorizon) ?
    lerpHSL(p.skyNightHorizon, p.skyDayHorizon, skyBright) :
    [(p.hue + 20) % 360, lerp(p.sat * 0.4, p.sat * 0.85, skyBright), lerp(3, 50, skyBright)];
  
  // Night signature: skyWarmth shifts hue toward warm at night
  const nsWarmth = (ns.skyWarmth || 0) * nightFactor;
  if (nsWarmth > 0) {
    skyZenith[0] = (skyZenith[0] * (1 - nsWarmth) + 25 * nsWarmth + 360) % 360;
    skyZenith[1] = Math.min(90, skyZenith[1] + nsWarmth * 15);
  } else if (nsWarmth < 0) {
    skyZenith[1] = Math.max(5, skyZenith[1] + nsWarmth * 10); // desaturate for cold nights
  }

  // Night signature: glow color tints the sky subtly at night
  const nsGlow = p.nightGlow || [220, 25, 30];
  const nsGlowIntensity = (ns.glowIntensity || 0) * nightFactor;
  if (nsGlowIntensity > 0) {
    skyHorizon[0] = (skyHorizon[0] * (1 - nsGlowIntensity * 0.3) + nsGlow[0] * nsGlowIntensity * 0.3 + 360) % 360;
    skyHorizon[2] = Math.min(30, skyHorizon[2] + nsGlowIntensity * 8);
  }

  // Golden hour warms the sky
  const skyH = skyZenith[0], skyS = skyZenith[1], skyL = skyZenith[2];
  const effectiveH = goldenMix > 0 ? lerp(skyH, 28, goldenMix) : skyH;
  const effectiveS = goldenMix > 0 ? lerp(skyS, skyS + 18, goldenMix) : skyS;

  if (data.locType === 'Nebula Pocket') {
    els.sky.style.background = `
      radial-gradient(ellipse at 30% 40%, hsla(${skyH}, 70%, ${25 + skyBright * 30}%, 0.8) 0%, transparent 50%),
      radial-gradient(ellipse at 70% 60%, hsla(${(skyH + 60) % 360}, 60%, ${20 + skyBright * 25}%, 0.6) 0%, transparent 50%),
      radial-gradient(ellipse at 50% 50%, hsla(${(skyH + 120) % 360}, 50%, ${15 + skyBright * 20}%, 0.4) 0%, transparent 60%),
      linear-gradient(to bottom, hsl(${skyH}, ${skyS}%, ${skyL * 0.5}%) 0%, hsl(${(skyH + 30) % 360}, ${skyS}%, ${skyL * 0.3}%) 100%)
    `;
  } else if (data.isWater) {
    els.sky.style.background = `
      linear-gradient(to bottom,
        hsl(${effectiveH}, ${effectiveS}%, ${skyL}%) 0%,
        hsl(${skyHorizon[0]}, ${skyHorizon[1]}%, ${skyHorizon[2]}%) 100%)
    `;
  } else {
    // Standard sky: zenith → mid → horizon, with golden hour warming the horizon band
    const midH = lerp(effectiveH, skyHorizon[0], 0.5);
    const midS = lerp(effectiveS, skyHorizon[1], 0.4);
    const midL = lerp(skyL, skyHorizon[2], 0.5);
    const lowerH = goldenMix > 0 ? lerp(skyHorizon[0], 22, goldenMix * 0.6) : skyHorizon[0];
    const lowerS = goldenMix > 0 ? lerp(skyHorizon[1], skyHorizon[1] + 15, goldenMix) : skyHorizon[1];
    const lowerL = goldenMix > 0 ? lerp(skyHorizon[2], skyHorizon[2] + 10, goldenMix) : skyHorizon[2];
    els.sky.style.background = `
      linear-gradient(to bottom,
        hsl(${effectiveH}, ${effectiveS}%, ${skyL}%) 0%,
        hsl(${midH}, ${midS}%, ${midL}%) 50%,
        hsl(${lowerH}, ${lowerS}%, ${lowerL}%) 100%)
    `;
  }

  // ── SUN position ──
  const sunY = 28 - skyBright * 20;
  const sunX = 68 + dayP * 22;
  const sunAlpha = 0.3 + skyBright * 0.6;
  if (els.sun) {
    els.sun.style.top = `${sunY}%`;
    els.sun.style.left = `${sunX}%`;
    els.sun.style.opacity = sunAlpha;
  }

  // Binary star
  if (els.sun2) {
    const binaryPhase = (Date.now() * 0.0003 + data.starSeed) % (Math.PI * 2);
    const sun2X = sunX + Math.sin(binaryPhase) * 12;
    const sun2Y = sunY + Math.cos(binaryPhase) * 5;
    els.sun2.style.top = `${sun2Y}%`;
    els.sun2.style.left = `${sun2X}%`;
    els.sun2.style.opacity = sunAlpha * 0.8;
    if (els.binaryWarm) {
      const warmAlpha = (Math.sin(binaryPhase) + 1) / 2 * 0.06;
      const coolAlpha = (1 - (Math.sin(binaryPhase) + 1) / 2) * 0.06;
      els.binaryWarm.style.background = `rgba(255,200,120,${warmAlpha})`;
      els.binaryCool.style.background = `rgba(140,170,255,${coolAlpha})`;
    }
  }

  // Sun reflection on water
  if (els.sunReflection) {
    const reflY = 82 - skyBright * 3; // Below horizon
    els.sunReflection.style.top = `${reflY}%`;
    els.sunReflection.style.left = `${sunX}%`;
    els.sunReflection.style.opacity = sunAlpha * 0.25;
  }

  // Night stars visibility
  if (els.nightStars) {
    els.nightStars.style.opacity = skyBright < 0.4 ? (0.4 - skyBright) / 0.4 : 0;
  }

  // Aurora visibility
  if (els.aurora) {
    els.aurora.style.opacity = skyBright < 0.3 ? 1 : 0;
  }

  // Bioluminescence visibility
  const bioEls = els.atmos.querySelectorAll('.land-bio-particle');
  if (bioEls.length) {
    const bioOpacity = skyBright < 0.4 ? 1 : 0;
    bioEls.forEach(el => el.style.opacity = bioOpacity);
  }

  // Water bioluminescence
  const waterBioEls = els.far.querySelectorAll('.water-bio');
  if (waterBioEls.length) {
    const wbOpacity = skyBright < 0.4 ? 1 : 0;
    waterBioEls.forEach(el => el.style.opacity = wbOpacity);
  }

  // ── TERRAIN COLORS — use curated ground arrays ──
  const gd = p.gndDay || { far:[p.hue,p.sat*0.85,30], mid:[p.hue,p.sat*0.7,24], near:[p.hue,p.sat*0.5,18] };
  const gn = p.gndNight || { far:[p.hue,p.sat*0.4,6], mid:[p.hue,p.sat*0.3,4], near:[p.hue,p.sat*0.2,3] };
  
  // Lerp between night and day ground colors
  const farC = lerpHSL(gn.far, gd.far, skyBright);
  const midC = lerpHSL(gn.mid, gd.mid, skyBright);
  const nearC = lerpHSL(gn.near, gd.near, skyBright);

  // Night signature: ground glow — lightens ground and shifts hue at night
  const nsGroundBoost = (ns.groundLightBoost || 0) * nightFactor;
  const nsGroundHueShift = (ns.groundHueShift || 0) * nightFactor;
  const nsGroundSatBoost = (ns.groundSatBoost || 0) * nightFactor;
  farC[0] = (farC[0] + nsGroundHueShift + 360) % 360;
  farC[1] = Math.min(90, farC[1] + nsGroundSatBoost);
  farC[2] = Math.min(50, farC[2] + nsGroundBoost * 100);
  midC[0] = (midC[0] + nsGroundHueShift + 360) % 360;
  midC[1] = Math.min(90, midC[1] + nsGroundSatBoost * 0.7);
  midC[2] = Math.min(40, midC[2] + nsGroundBoost * 80);
  nearC[0] = (nearC[0] + nsGroundHueShift + 360) % 360;
  nearC[2] = Math.min(35, nearC[2] + nsGroundBoost * 60);

  // Golden hour warms terrain
  const goldenIntensity = goldenMix * 0.45;
  if (goldenMix > 0) {
    farC[0] = lerp(farC[0], (farC[0] + 350) % 360, goldenIntensity);
    farC[1] = Math.min(90, farC[1] + goldenMix * 10);
    midC[0] = lerp(midC[0], (midC[0] + 350) % 360, goldenIntensity * 0.7);
  }

  // Inverse Horizon modifier: ground luminosity inverts at night
  const mod = p.modifier;
  if (mod && mod.name === 'Inverse Horizon' && nightFactor > 0.4) {
    const invStr = nightFactor * 0.5;
    farC[2] = Math.min(45, farC[2] + invStr * 20);
    midC[2] = Math.min(38, midC[2] + invStr * 18);
    nearC[2] = Math.min(32, nearC[2] + invStr * 15);
    farC[1] = Math.min(85, farC[1] + invStr * 15); // more saturated ground at night
  }

  if (data.hasStandardTerrain) {
    els.far.style.backgroundColor = `hsl(${farC[0]}, ${farC[1]}%, ${farC[2]}%)`;

    // Far2 — atmospheric haze between far and mid
    const far2C = lerpHSL(farC, [skyHorizon[0], skyHorizon[1] * 0.4, lerp(farC[2], skyL, 0.3)], 0.3);
    els.far2.style.backgroundColor = `hsl(${far2C[0]}, ${far2C[1]}%, ${far2C[2]}%)`;

    els.mid.style.background = `
      linear-gradient(to bottom,
        hsl(${midC[0]}, ${midC[1]}%, ${midC[2]}%) 0%,
        hsl(${midC[0]}, ${midC[1]*0.75}%, ${midC[2]*0.7}%) 100%)
    `;

    els.near.style.background = `hsl(${nearC[0]}, ${nearC[1]}%, ${nearC[2]}%)`;

    // Foreground silhouettes — deepest darks for contrast
    const fgL = lerp(2, 10, skyBright);
    const fgEls = els.foreground.querySelectorAll('.fg-silhouette');
    fgEls.forEach(el => {
      el.style.backgroundColor = `hsl(${nearC[0]}, ${nearC[1]*0.35}%, ${fgL}%)`;
    });

    // Night signature: ground glow overlay
    if (nsGlowIntensity > 0.05 && nightFactor > 0.5) {
      const glowAlpha = nsGlowIntensity * 0.2 * nightFactor;
      els.near.style.boxShadow = `inset 0 -8px 35px hsla(${nsGlow[0]},${nsGlow[1]}%,${nsGlow[2]}%,${glowAlpha})`;
    } else if (!data.isVolcanic && !data.isFrozen) {
      els.near.style.boxShadow = 'none';
    }

    // Volcanic terrain special: lava glow at night
    if (data.isVolcanic) {
      const lavaGlow = Math.max(0, 1 - skyBright * 2) * 0.18;
      els.near.style.boxShadow = `inset 0 -12px 45px rgba(255,70,15,${lavaGlow})`;
    }
    // Frozen terrain special: ice shimmer
    if (data.isFrozen) {
      const iceShimmer = skyBright * 0.07 + nightFactor * nsGroundBoost * 0.4;
      els.far.style.boxShadow = `inset 0 0 60px hsla(${nsGlow[0]},${nsGlow[1]}%,${nsGlow[2]}%,${iceShimmer})`;
    }
  } else if (data.isWater) {
    // Ocean uses curated far colors shifted toward blue
    const waterH = (farC[0] + 200) % 360;
    els.far.style.color = `hsl(${waterH}, ${farC[1] + 25}%, ${farC[2] + 16}%)`;
    els.near.style.background = `
      linear-gradient(to bottom,
        hsla(${waterH}, ${farC[1]+18}%, ${nearC[2]+12}%, 0.85) 0%,
        hsl(${(waterH+15)%360}, ${farC[1]+8}%, ${nearC[2]+4}%) 100%)
    `;
    els.near.style.height = '20%';
    els.far.style.background = `
      linear-gradient(to bottom,
        hsl(${waterH}, ${farC[1] + 25}%, ${farC[2] + 16}%) 0%,
        hsl(${(waterH+15)%360}, ${farC[1] + 12}%, ${farC[2] + 6}%) 100%)
    `;
    els.far.style.height = '40%';
  } else if (data.locType !== 'Nebula Pocket' && data.locType !== 'Asteroid Field'
      && data.locType !== 'Ring System' && data.locType !== 'Comet'
      && data.locType !== 'Crystalline Spire') {
    els.near.style.background = `hsl(${nearC[0]}, ${nearC[1]*0.45}%, ${nearC[2]}%)`;
  }

  // Cloud color update (use CSS custom properties on the layer)
  const clouds = els.atmos.querySelectorAll('.cloud');
  if (clouds.length) {
    const cloudColor = `hsl(${effectiveH},${effectiveS*0.3}%,${skyL + 30}%)`;
    clouds.forEach(cl => cl.style.background = cloudColor);
  }
}

// ═══════════════════════════════════════════
// STARFIELD RENDERING
// ═══════════════════════════════════════════
const BG_STARS = [];
for (let i = 0; i < 300; i++) {
  BG_STARS.push({
    x: Math.random() * 4000 - 2000,
    y: Math.random() * 4000 - 2000,
    size: 0.3 + Math.random() * 1,
    brightness: 0.2 + Math.random() * 0.5,
    parallax: 0.02 + Math.random() * 0.08,
  });
}

function renderStarfield() {
  ctx.clearRect(0, 0, APP.width, APP.height);
  const cx = APP.camera.x, cy = APP.camera.y;
  const hw = APP.width / 2, hh = APP.height / 2;

  // Background distant stars — offscreen canvas, re-render when camera moves >80px
  if (!APP._bgStarsCanvas || APP._bgStarsCanvas.w !== APP.width || APP._bgStarsCanvas.h !== APP.height) {
    APP._bgStarsCanvas = {
      canvas: document.createElement('canvas'),
      w: APP.width, h: APP.height,
      cx: -99999, cy: -99999
    };
    APP._bgStarsCanvas.canvas.width = APP.width;
    APP._bgStarsCanvas.canvas.height = APP.height;
  }
  const bsc = APP._bgStarsCanvas;
  if (Math.abs(cx - bsc.cx) > 80 || Math.abs(cy - bsc.cy) > 80) {
    const bCtx = bsc.canvas.getContext('2d');
    bCtx.clearRect(0, 0, APP.width, APP.height);
    for (const s of BG_STARS) {
      const sx = ((s.x - cx * s.parallax) % APP.width + APP.width) % APP.width;
      const sy = ((s.y - cy * s.parallax) % APP.height + APP.height) % APP.height;
      bCtx.globalAlpha = s.brightness * 0.6;
      bCtx.fillStyle = '#c8ccdd';
      bCtx.beginPath();
      bCtx.arc(sx, sy, s.size, 0, Math.PI * 2);
      bCtx.fill();
    }
    bsc.cx = cx; bsc.cy = cy;
  }
  ctx.drawImage(bsc.canvas, 0, 0);

  // Nebula fog in background (cached — recompute every 100px of movement)
  if (!APP._nebulaCache ||
      Math.abs(cx - APP._nebulaCache.cx) > 100 ||
      Math.abs(cy - APP._nebulaCache.cy) > 100) {
    APP._nebulaCache = {
      cx, cy,
      val: (fbm(cx * 0.00001 + 100, cy * 0.00001 + 100, 2) + 1) / 2
    };
  }
  const nebulaVal = APP._nebulaCache.val;
  if (nebulaVal > 0.45) {
    const intensity = (nebulaVal - 0.45) * 2;
    const nh = ((cx * 0.001 + cy * 0.002) % 360 + 360) % 360;
    const nebBg = $('nebula-bg');
    nebBg.style.background = `
      radial-gradient(ellipse at ${40 + Math.sin(cx * 0.0001) * 20}% ${40 + Math.cos(cy * 0.0001) * 20}%,
        hsla(${nh}, 70%, 28%, ${intensity * 0.2}) 0%, transparent 55%),
      radial-gradient(ellipse at ${60 + Math.sin(cy * 0.00015) * 15}% ${55 + Math.cos(cx * 0.00012) * 15}%,
        hsla(${(nh + 70) % 360}, 55%, 22%, ${intensity * 0.15}) 0%, transparent 50%),
      radial-gradient(ellipse at ${30 + Math.cos(cx * 0.00008) * 15}% ${65 + Math.sin(cy * 0.00009) * 15}%,
        hsla(${(nh + 140) % 360}, 50%, 18%, ${intensity * 0.1}) 0%, transparent 45%)
    `;
    nebBg.classList.add('visible');
  } else {
    $('nebula-bg').classList.remove('visible');
  }

  // Real stars
  const stars = getStarsInView();
  APP._cachedVisibleStars = stars; // cache for scanner reuse
  for (const star of stars) {
    const sx = star.x - cx + hw;
    const sy = star.y - cy + hh;
    if (sx < -20 || sx > APP.width + 20 || sy < -20 || sy > APP.height + 20) continue;

    const dist = Math.sqrt((star.x - cx) ** 2 + (star.y - cy) ** 2);
    const pulse = 0.85 + Math.sin(Date.now() * 0.001 + star.seed) * 0.15;
    const alpha = star.brightness * pulse;

    // Glow
    ctx.globalAlpha = alpha * 0.4;
    const grd = ctx.createRadialGradient(sx, sy, 0, sx, sy, star.size * 10);
    grd.addColorStop(0, star.type.glow);
    grd.addColorStop(0.5, star.type.glow.replace(/[\d.]+\)$/, '0.08)'));
    grd.addColorStop(1, 'transparent');
    ctx.fillStyle = grd;
    ctx.fillRect(sx - star.size * 10, sy - star.size * 10, star.size * 20, star.size * 20);

    // Core
    ctx.globalAlpha = alpha;
    ctx.fillStyle = star.type.color;
    ctx.beginPath();
    ctx.arc(sx, sy, star.size, 0, Math.PI * 2);
    ctx.fill();
    // Bright center pip
    ctx.globalAlpha = alpha * 0.8;
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(sx, sy, star.size * 0.4, 0, Math.PI * 2);
    ctx.fill();

    // Scanner info for nearby stars
    if (dist < 300 && APP.state === 'starfield') {
      ctx.globalAlpha = Math.max(0, 1 - dist / 300) * 0.4;
      ctx.fillStyle = '#c8ccdd';
      ctx.font = '10px "JetBrains Mono", monospace';
      ctx.fillText(star.type.name, sx + star.size + 8, sy + 3);
    }
  }

  ctx.globalAlpha = 1;

  // Crosshair
  if (APP.state === 'starfield') {
    ctx.strokeStyle = 'rgba(200,210,220,0.15)';
    ctx.lineWidth = 0.5;
    ctx.beginPath();
    ctx.moveTo(hw - 12, hh); ctx.lineTo(hw - 4, hh);
    ctx.moveTo(hw + 4, hh); ctx.lineTo(hw + 12, hh);
    ctx.moveTo(hw, hh - 12); ctx.lineTo(hw, hh - 4);
    ctx.moveTo(hw, hh + 4); ctx.lineTo(hw, hh + 12);
    ctx.stroke();
  }
}

// ═══════════════════════════════════════════
// SYSTEM VIEW RENDERING
// ═══════════════════════════════════════════
let systemBodyEls = []; // persistent DOM overlays for clickable bodies

function createSystemBodyOverlays() {
  // Remove any old ones
  systemBodyEls.forEach(el => el.remove());
  systemBodyEls = [];
  if (!APP.currentSystem) return;

  APP.currentSystem.locations.forEach((loc, i) => {
    const el = document.createElement('div');
    el.className = 'system-body-el';
    const hitSize = Math.max(30, (loc.visualSize + 5) * 2);
    el.style.cssText = `position:fixed;width:${hitSize}px;height:${hitSize}px;z-index:6;cursor:pointer;border-radius:50%;`;
    el.addEventListener('click', (e) => {
      e.stopPropagation();
      landOnLocation(i);
    });
    el.addEventListener('mouseenter', () => {
      $('scanner-readout').innerHTML = `<span class="scanner-line" style="animation-delay:0s">${loc.scannerDesc}</span>`;
      $('scanner-readout').style.opacity = '1';
    });
    el.addEventListener('mouseleave', () => {
      $('scanner-readout').style.opacity = '0';
    });
    document.body.appendChild(el);
    systemBodyEls.push(el);
  });
}

function removeSystemBodyOverlays() {
  systemBodyEls.forEach(el => el.remove());
  systemBodyEls = [];
}

function renderSystemView() {
  if (!APP.currentSystem) return;
  const sys = APP.currentSystem;
  const cw = APP.width, ch = APP.height;
  sysCtx.clearRect(0, 0, cw, ch);

  // Background — use cached offscreen canvas
  if (!APP._sysStarsBg || APP._sysStarsBg.w !== cw || APP._sysStarsBg.h !== ch || APP._sysStarsBg.seed !== sys.star.seed) {
    const offscreen = document.createElement('canvas');
    offscreen.width = cw; offscreen.height = ch;
    const oCtx = offscreen.getContext('2d');
    oCtx.fillStyle = '#060610';
    oCtx.fillRect(0, 0, cw, ch);
    const rng = mulberry32(sys.star.seed + 333);
    for (let i = 0; i < 150; i++) {
      const x = rng() * cw, y = rng() * ch;
      const s = 0.3 + rng() * 1;
      oCtx.globalAlpha = 0.2 + rng() * 0.4;
      oCtx.fillStyle = '#aabbcc';
      oCtx.beginPath();
      oCtx.arc(x, y, s, 0, Math.PI * 2);
      oCtx.fill();
    }
    APP._sysStarsBg = { canvas: offscreen, w: cw, h: ch, seed: sys.star.seed };
  }
  sysCtx.drawImage(APP._sysStarsBg.canvas, 0, 0);

  // Central star
  const centerX = cw / 2, centerY = ch / 2;
  const starSize = 20;
  sysCtx.globalAlpha = 0.2;
  const grd = sysCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, starSize * 6);
  grd.addColorStop(0, sys.star.type.glow);
  grd.addColorStop(1, 'transparent');
  sysCtx.fillStyle = grd;
  sysCtx.fillRect(centerX - starSize * 6, centerY - starSize * 6, starSize * 12, starSize * 12);

  sysCtx.globalAlpha = 1;
  sysCtx.fillStyle = sys.star.type.color;
  sysCtx.beginPath();
  sysCtx.arc(centerX, centerY, starSize, 0, Math.PI * 2);
  sysCtx.fill();

  // Star label
  sysCtx.fillStyle = 'rgba(200,210,220,0.5)';
  sysCtx.font = '11px "JetBrains Mono", monospace';
  sysCtx.textAlign = 'center';
  sysCtx.fillText(sys.star.type.name, centerX, centerY + starSize + 18);

  // Orbits and bodies
  const maxOrbitR = Math.min(cw, ch) * 0.42;
  const now = Date.now();

  sys.locations.forEach((loc, i) => {
    const orbitR = 60 + loc.orbit * maxOrbitR;

    // Draw orbit path
    sysCtx.strokeStyle = 'rgba(200,210,220,0.06)';
    sysCtx.lineWidth = 0.5;
    sysCtx.beginPath();
    sysCtx.ellipse(centerX, centerY, orbitR, orbitR * (1 - loc.orbitEcc), 0, 0, Math.PI * 2);
    sysCtx.stroke();

    // Body position
    const angle = loc.orbitAngle + now * loc.orbitSpeed;
    const bx = centerX + Math.cos(angle) * orbitR;
    const by = centerY + Math.sin(angle) * orbitR * (1 - loc.orbitEcc);

    // Draw body on canvas
    const bodySize = loc.visualSize;
    const bodyColor = loc.palette.groundDay;
    sysCtx.fillStyle = bodyColor;
    sysCtx.globalAlpha = 0.8;
    sysCtx.beginPath();
    sysCtx.arc(bx, by, bodySize, 0, Math.PI * 2);
    sysCtx.fill();
    sysCtx.globalAlpha = 1;

    // Label
    const displayName = loc.name || loc.catalogId;
    sysCtx.fillStyle = 'rgba(200,210,220,0.45)';
    sysCtx.font = '10px "JetBrains Mono", monospace';
    sysCtx.textAlign = 'center';
    sysCtx.fillText(displayName, bx, by + bodySize + 14);
    sysCtx.fillText(loc.type.name, bx, by + bodySize + 26);

    // Update the persistent clickable overlay position
    if (systemBodyEls[i]) {
      const hitSize = parseFloat(systemBodyEls[i].style.width);
      systemBodyEls[i].style.left = `${bx - hitSize / 2}px`;
      systemBodyEls[i].style.top = `${by - hitSize / 2}px`;
    }
  });
}

// ═══════════════════════════════════════════
// STATE TRANSITIONS
// ═══════════════════════════════════════════
function approachStar(star) {
  APP.currentStar = star;
  APP.currentSystem = generateSystem(star);
  APP.state = 'system';

  $('system-view').style.display = 'block';
  setTimeout(() => {
    $('system-view').classList.add('visible');
    createSystemBodyOverlays();
  }, 50);
  $('hud-location').textContent = star.type.name + ' System';
  $('btn-launch').style.display = 'inline-block';
  $('btn-launch').textContent = 'Depart';
  $('scanner-readout').innerHTML = `<span class="scanner-line">${APP.currentSystem.locations.length} objects detected</span>`;
  $('scanner-readout').style.opacity = '1';
  setTimeout(() => { $('scanner-readout').style.opacity = '0'; }, 3000);
}

function landOnLocation(idx) {
  const loc = APP.currentSystem.locations[idx];
  APP.currentLocation = loc;
  APP.state = 'landed';

  // Clean up system view clickables
  removeSystemBodyOverlays();
  $('system-view').classList.remove('visible');
  setTimeout(() => { $('system-view').style.display = 'none'; }, 1000);

  // Render landscape
  initLandscape(loc, APP.currentSystem);
  // Cinematic descent
  $('landscape-layer').classList.remove('launching');
  $('landscape-layer').classList.add('landing-in');
  $('landscape-layer').classList.add('visible');
  $('hud-frame').classList.add('visible');

  // Show editor after descent completes
  setTimeout(() => {
    $('editor-layer').classList.remove('landing-in');
    $('editor-layer').classList.add('landing-in');
    $('editor-layer').classList.add('visible');
    $('editor-scrim').classList.add('visible');
    $('opacity-control').classList.add('visible');
    $('btn-focus').style.display = 'inline-block';
    $('btn-textcolor').style.display = 'inline-block';
    $('btn-font').style.display = 'inline-block';
    $('btn-spellcheck').style.display = 'inline-block';
    $('btn-daynight').style.display = 'inline-block';
    $('btn-launch').textContent = 'Launch';

    // Check if first visit
    const sysKey = APP.currentSystem.key;
    if (!APP.logbook.visited[sysKey]) {
      APP.logbook.visited[sysKey] = {
        star: APP.currentStar,
        locations: APP.currentSystem.locations.map(l => ({
          catalogId: l.catalogId,
          name: l.name,
          type: l.type.name,
          palette: l.palette,
          file: l.file,
        }))
      };
    }

    if (!loc.name) {
      showNamingModal(loc);
    } else {
      $('hud-location').textContent = loc.name;
      $('editor-textarea').focus();
    }
  }, 1500);
}

function launch() {
  if (APP.state === 'landed') {
    // Warn about unsaved changes
    if (APP.dirty) {
      if (!confirm('You have unsaved changes. Launch anyway?')) return;
    }
    // Save location state
    if (APP.currentLocation) {
      const sysKey = APP.currentSystem.key;
      if (APP.logbook.visited[sysKey]) {
        const idx = APP.currentSystem.locations.indexOf(APP.currentLocation);
        if (idx >= 0) {
          APP.logbook.visited[sysKey].locations[idx].name = APP.currentLocation.name;
          APP.logbook.visited[sysKey].locations[idx].file = APP.fileName;
        }
      }
    }

    APP.state = 'system';
    // Clean up 3D landscape
    if (APP.webglActive) {
      cleanupLandscape3D();
    }
    // Clean up weather timers
    if (APP._lightningTimer) { clearTimeout(APP._lightningTimer); APP._lightningTimer = null; }
    APP._landEls = null;
    APP._landData = null;
    $('editor-layer').classList.remove('visible');
    $('editor-layer').classList.remove('landing-in');
    $('editor-scrim').classList.remove('visible');
    $('opacity-control').classList.remove('visible');
    $('landscape-layer').classList.remove('landing-in');
    $('landscape-layer').classList.add('launching');
    $('hud-frame').classList.remove('visible');
    $('btn-focus').style.display = 'none';
    $('btn-textcolor').style.display = 'none';
    $('btn-font').style.display = 'none';
    $('btn-spellcheck').style.display = 'none';
    $('btn-daynight').style.display = 'none';
    document.body.classList.remove('focus-mode');
    APP.focusMode = false;

    setTimeout(() => {
      // Clean up landscape after launch anim
      $('landscape-layer').classList.remove('visible', 'launching');
      $('system-view').style.display = 'block';
      setTimeout(() => {
        $('system-view').classList.add('visible');
        createSystemBodyOverlays();
      }, 50);
      $('btn-launch').textContent = 'Depart';
      $('hud-location').textContent = APP.currentStar.type.name + ' System';
    }, 1300);
  } else if (APP.state === 'system') {
    // Leave system
    APP.state = 'starfield';
    removeSystemBodyOverlays();
    $('system-view').classList.remove('visible');
    setTimeout(() => { $('system-view').style.display = 'none'; }, 1000);
    $('btn-launch').style.display = 'none';
    $('hud-location').textContent = 'Deep Space';
    APP.currentSystem = null;
    APP.currentStar = null;
    APP.currentLocation = null;
    $('scanner-readout').style.opacity = '0';
  }
}

// ═══════════════════════════════════════════
// NAMING MODAL
// ═══════════════════════════════════════════
function showNamingModal(loc) {
  $('naming-modal').classList.add('visible');
  $('naming-input').value = '';
  $('naming-input').focus();

  function confirm() {
    const name = $('naming-input').value.trim() || loc.catalogId;
    loc.name = name;
    $('hud-location').textContent = name;
    $('naming-modal').classList.remove('visible');
    $('editor-textarea').focus();
    cleanup();
  }
  function skip() {
    loc.name = loc.catalogId;
    $('hud-location').textContent = loc.catalogId;
    $('naming-modal').classList.remove('visible');
    $('editor-textarea').focus();
    cleanup();
  }
  function onKey(e) {
    if (e.key === 'Enter') confirm();
    if (e.key === 'Escape') skip();
  }
  function cleanup() {
    $('naming-input').removeEventListener('keydown', onKey);
  }
  $('naming-input').addEventListener('keydown', onKey);
}

// ═══════════════════════════════════════════
// STARFIELD EDITOR (write in transit)
// ═══════════════════════════════════════════
function activateStarfieldEditor() {
  if (APP.state !== 'starfield') return;
  APP.editorActive = true;
  $('editor-layer').classList.add('visible');
  $('editor-scrim').classList.add('visible');
  $('opacity-control').classList.add('visible');
  $('btn-focus').style.display = 'inline-block';
  $('btn-textcolor').style.display = 'inline-block';
  $('btn-font').style.display = 'inline-block';
  $('btn-spellcheck').style.display = 'inline-block';
  $('hud-location').textContent = 'In Transit';
  $('editor-textarea').focus();
}

function deactivateStarfieldEditor() {
  if (APP.state !== 'starfield') return;
  if (!$('editor-textarea').value.trim()) {
    APP.editorActive = false;
    $('editor-layer').classList.remove('visible');
    $('editor-scrim').classList.remove('visible');
    $('opacity-control').classList.remove('visible');
    $('btn-focus').style.display = 'none';
    $('btn-textcolor').style.display = 'none';
    $('btn-font').style.display = 'none';
    $('btn-spellcheck').style.display = 'none';
    $('hud-location').textContent = 'Deep Space';
  }
}

// ═══════════════════════════════════════════
// INPUT HANDLING
// ═══════════════════════════════════════════
document.addEventListener('keydown', (e) => {
  APP.keys[e.key.toLowerCase()] = true;

  // Don't intercept when typing in ANY input element
  const ae = document.activeElement;
  const isTyping = ae && (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA');

  if (ae === $('editor-textarea') || ae === $('naming-input')) {
    // File shortcuts work while typing in main editor
    if (e.ctrlKey && e.key === 's') {
      e.preventDefault();
      if (e.shiftKey) saveFileAs(); else saveFile();
    }
    if (e.ctrlKey && e.key === 'o') {
      e.preventDefault();
      openFile();
    }
    if (e.ctrlKey && e.key === 'n') {
      e.preventDefault();
      newFile();
    }
    if (e.ctrlKey && e.key === 'm') {
      e.preventDefault();
      insertMetadata();
    }
    if (e.key === 'Escape') {
      e.preventDefault();
      if (ae === $('editor-textarea')) {
        $('editor-textarea').blur();
      }
    }
    return;
  }

  // If focused on some other input (logbook rename, etc), only handle Ctrl shortcuts + Escape
  if (isTyping) {
    if (e.ctrlKey && e.key === 's') { e.preventDefault(); if (e.shiftKey) saveFileAs(); else saveFile(); }
    if (e.key === 'Escape') { ae.blur(); }
    return;
  }

  // Global file shortcuts (when not in any input)
  if (e.ctrlKey && e.key === 's') {
    e.preventDefault();
    if (e.shiftKey) saveFileAs(); else saveFile();
  }
  if (e.ctrlKey && e.key === 'o') {
    e.preventDefault();
    openFile();
  }
  if (e.ctrlKey && e.key === 'n') {
    e.preventDefault();
    newFile();
  }

  // Global shortcuts
  if (e.key === 'Escape') {
    if ($('recovery-modal').classList.contains('visible')) return; // don't intercept during recovery
    if ($('font-modal').classList.contains('visible')) {
      hideFontModal();
    } else if (APP.focusMode) {
      toggleFocus(); // Exit focus mode with Escape
    } else if ($('logbook').classList.contains('visible')) {
      $('logbook').classList.remove('visible');
    } else if (APP.state === 'landed' || APP.state === 'system') {
      launch();
    }
  }
  if (e.key === 'l' || e.key === 'L') {
    toggleLogbook();
  }
  if (e.key === 'f' || e.key === 'F') {
    if (APP.state === 'landed' || APP.editorActive) toggleFocus();
  }
  if (e.key === 't' || e.key === 'T') {
    if (APP.state === 'landed' || APP.editorActive) toggleTextColor();
  }
  if (e.key === 'n' || e.key === 'N') {
    if (APP.state === 'landed') toggleDayNight();
  }
  if (e.key === 'k' || e.key === 'K') {
    if (APP.state === 'landed' || APP.editorActive) toggleSpellcheck();
  }
  if (e.key === '[') {
    const s = $('opacity-slider');
    s.value = Math.max(0.35, parseFloat(s.value) - 0.05);
    updateFrostOpacity();
  }
  if (e.key === ']') {
    const s = $('opacity-slider');
    s.value = Math.min(1.0, parseFloat(s.value) + 0.05);
    updateFrostOpacity();
  }
});

document.addEventListener('keyup', (e) => {
  APP.keys[e.key.toLowerCase()] = false;
});

// Click on starfield to approach stars
canvas.addEventListener('click', (e) => {
  if (APP.state !== 'starfield') return;

  const mx = e.clientX, my = e.clientY;
  const hw = APP.width / 2, hh = APP.height / 2;

  // Check if clicked near a star
  const stars = getStarsInView();
  let closest = null, closestDist = 30;

  for (const star of stars) {
    const sx = star.x - APP.camera.x + hw;
    const sy = star.y - APP.camera.y + hh;
    const d = Math.sqrt((sx - mx) ** 2 + (sy - my) ** 2);
    if (d < closestDist) {
      closestDist = d;
      closest = star;
    }
  }

  if (closest) {
    approachStar(closest);
  }
});

// Start typing activates starfield editor
$('editor-textarea').addEventListener('focus', () => {
  if (APP.state === 'starfield' && !APP.editorActive) {
    activateStarfieldEditor();
  }
});

$('editor-textarea').addEventListener('blur', () => {
  if (APP.state === 'starfield') {
    deactivateStarfieldEditor();
  }
});

// Click on starfield background to start typing
document.addEventListener('keypress', (e) => {
  const ae = document.activeElement;
  const isTyping = ae && (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA');
  if (APP.state === 'starfield' && !APP.editorActive && !isTyping &&
      !e.ctrlKey && !e.metaKey && !e.altKey &&
      e.key.length === 1 && !$('logbook').classList.contains('visible') &&
      !$('recovery-modal').classList.contains('visible')) {
    e.preventDefault(); // Prevent browser from also inserting the character
    activateStarfieldEditor();
    $('editor-textarea').value = e.key;
    // Move cursor to end
    setTimeout(() => {
      $('editor-textarea').selectionStart = $('editor-textarea').selectionEnd = 1;
    }, 0);
  }
});

// Word count + dirty tracking
$('editor-textarea').addEventListener('input', () => {
  const text = $('editor-textarea').value.trim();
  const count = text ? text.split(/\s+/).length : 0;
  $('hud-wordcount').textContent = `${count} word${count !== 1 ? 's' : ''}`;

  // Dirty tracking
  const currentText = $('editor-textarea').value;
  if (currentText !== APP.lastSavedText) {
    APP.dirty = true;
    $('dirty-dot').classList.add('visible');
  } else {
    APP.dirty = false;
    $('dirty-dot').classList.remove('visible');
  }
});

// ═══════════════════════════════════════════
// HUD BUTTONS
// ═══════════════════════════════════════════
$('btn-launch').addEventListener('click', launch);
$('btn-logbook').addEventListener('click', toggleLogbook);

// Reset Logbook handler
$('btn-reset-logbook').addEventListener('click', () => {
  if (!confirm('Clear your entire flight log? This will erase all visited systems and transit files. This cannot be undone.')) return;
  // Reset in-memory state
  APP.logbook = { visited: {}, transitFiles: [] };
  // Clear from localStorage
  try {
    const saved = JSON.parse(localStorage.getItem('voyage-writer-state') || '{}');
    saved.logbook = APP.logbook;
    localStorage.setItem('voyage-writer-state', JSON.stringify(saved));
  } catch(e) {}
  // Clear IDB autosave (may contain logbook references)
  IDB.del('autosave').catch(() => {});
  // Re-render logbook
  renderLogbook();
});
$('btn-focus').addEventListener('click', toggleFocus);
$('btn-textcolor').addEventListener('click', toggleTextColor);
$('btn-daynight').addEventListener('click', toggleDayNight);
$('btn-fullscreen').addEventListener('click', toggleFullscreen);
$('btn-font').addEventListener('click', showFontModal);
$('btn-spellcheck').addEventListener('click', toggleSpellcheck);
$('btn-save').addEventListener('click', saveFile);
$('btn-saveas').addEventListener('click', saveFileAs);
$('btn-open').addEventListener('click', openFile);
$('btn-new').addEventListener('click', newFile);

$('opacity-slider').addEventListener('input', updateFrostOpacity);

// ─── UI Helpers ───
function updateHudFilename() {
  const name = APP.fileName || '';
  $('hud-filename').textContent = name;
  // Update title bar
  document.title = name ? `${name} — Void Writer` : 'Void Writer';
}

function showSaveFlash(msg) {
  const el = $('save-flash');
  el.textContent = msg || 'saved';
  el.classList.remove('show');
  // Force reflow for re-triggering animation
  void el.offsetWidth;
  el.classList.add('show');
}

function markClean() {
  APP.dirty = false;
  APP.lastSavedText = $('editor-textarea').value;
  $('dirty-dot').classList.remove('visible');
  // Clear recovery data after successful save
  IDB.del('autosave').catch(() => {});
}

function updateFrostOpacity() {
  const val = parseFloat($('opacity-slider').value);
  
  // When landed, day/night cycle dynamically scales opacity and blur
  let opScale = 1, blurScale = 1;
  if (APP.state === 'landed') {
    const bright = Math.sin(APP.dayProgress * Math.PI);
    const nightF = 1 - bright;
    opScale = 0.65 + nightF * 0.35;
    blurScale = 0.55 + nightF * 0.45;
  }
  
  document.documentElement.style.setProperty('--frost-opacity', (val * opScale).toFixed(3));
  // Strong blur floor — even at lowest opacity, shapes must be diffused
  const blurBase = 24;
  const blurBoost = Math.max(0, (val - 0.4) * 40);
  document.documentElement.style.setProperty('--frost-blur', Math.round((blurBase + blurBoost) * blurScale) + 'px');
  // At high opacity, subtly brighten the top border for depth
  const borderAlpha = 0.06 + val * 0.08;
  const frostBg = $('frost-bg');
  if (frostBg) frostBg.style.borderTopColor = `rgba(200,210,220,${borderAlpha})`;
  // Scale scrim darkness with frost opacity — higher frost = darker scrim
  // (only for focus mode; normal mode scrim is handled by main loop)
  const scrim = $('editor-scrim');
  if (scrim && scrim.classList.contains('visible') && APP.focusMode) {
    const scrimAlpha = 0.35 + (val - 0.35) * 0.55;
    scrim.style.background = `rgba(0,0,0,${scrimAlpha.toFixed(3)})`;
  }
}

function toggleFocus() {
  APP.focusMode = !APP.focusMode;
  document.body.classList.toggle('focus-mode', APP.focusMode);
  $('btn-focus').textContent = APP.focusMode ? 'Unfocus' : 'Focus';
  // Refresh scrim level for new mode
  updateFrostOpacity();
}

function toggleTextColor() {
  const cycle = { 'light': 'dark', 'dark': 'auto', 'auto': 'light' };
  APP.textMode = cycle[APP.textMode];
  const labels = { 'light': 'Text: Light', 'dark': 'Text: Dark', 'auto': 'Text: Auto' };
  $('btn-textcolor').textContent = labels[APP.textMode];
}

function toggleSpellcheck() {
  APP.spellcheck = !APP.spellcheck;
  $('editor-textarea').spellcheck = APP.spellcheck;
  $('btn-spellcheck').textContent = APP.spellcheck ? 'Spell: On' : 'Spell: Off';
  // Force re-render of spellcheck underlines by briefly blurring and refocusing
  if (document.activeElement === $('editor-textarea')) {
    $('editor-textarea').blur();
    setTimeout(() => $('editor-textarea').focus(), 0);
  }
}

function toggleDayNight() {
  if (APP.dayPinned === null || APP.dayPinned === 'night') {
    APP.dayPinned = 'day';
    APP.dayProgress = 0.5;
    $('btn-daynight').textContent = '☾';
  } else {
    APP.dayPinned = 'night';
    APP.dayProgress = 0.05;
    $('btn-daynight').textContent = '☀';
  }
  if (APP.currentLocation && APP.currentSystem) {
    updateLandscapeLighting();
  }
}

function toggleFullscreen() {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen().catch(e => {
      console.warn('Fullscreen request failed:', e);
    });
  } else {
    document.exitFullscreen();
  }
}

// Update fullscreen button icon on change
document.addEventListener('fullscreenchange', () => {
  $('btn-fullscreen').textContent = document.fullscreenElement ? '⛶' : '⛶';
  $('btn-fullscreen').style.opacity = document.fullscreenElement ? '1' : '0.7';
});

// ─── Font Modal ───
function getSystemFonts() {
  // Common fonts likely to be available, plus check for installed fonts
  const commonFonts = [
    'Georgia',
    'Times New Roman',
    'Palatino Linotype',
    'Book Antiqua',
    'Garamond',
    'Baskerville',
    'Cambria',
    'Didot',
    'Hoefler Text',
    'Courier New',
    'Lucida Console',
    'Monaco',
    'Consolas',
    'SF Mono',
    'Menlo',
    'Arial',
    'Helvetica',
    'Verdana',
    'Trebuchet MS',
    'Gill Sans',
    'Futura',
    'Optima',
    'Avenir',
    'Segoe UI',
    'Roboto',
    'system-ui'
  ];
  
  // Include the current Google Fonts
  const googleFonts = ['Cormorant Garamond', 'JetBrains Mono', 'Poiret One'];
  
  return [...googleFonts, ...commonFonts];
}

function populateFontSelect() {
  const select = $('font-select');
  select.innerHTML = '';
  const fonts = getSystemFonts();
  
  fonts.forEach(font => {
    const opt = document.createElement('option');
    opt.value = font;
    opt.textContent = font;
    opt.style.fontFamily = font;
    select.appendChild(opt);
  });
  
  // Set current font
  select.value = APP.editorFont || 'Cormorant Garamond';
}

function showFontModal() {
  populateFontSelect();
  $('font-size-slider').value = APP.editorFontSize || 19;
  $('font-size-display').textContent = ($('font-size-slider').value) + 'px';
  $('font-modal').classList.add('visible');
  $('font-select').focus();
}

function hideFontModal() {
  $('font-modal').classList.remove('visible');
  $('editor-textarea').focus();
}

function applyFont(fontFamily, fontSize) {
  APP.editorFont = fontFamily;
  APP.editorFontSize = fontSize;
  $('editor-textarea').style.fontFamily = `"${fontFamily}", var(--editor-font)`;
  $('editor-textarea').style.fontSize = fontSize + 'px';
  
  // Persist to localStorage
  try {
    const saved = JSON.parse(localStorage.getItem('voyage-writer-state') || '{}');
    saved.editorFont = fontFamily;
    saved.editorFontSize = fontSize;
    localStorage.setItem('voyage-writer-state', JSON.stringify(saved));
  } catch(e) {}
}

$('font-select').addEventListener('change', () => {
  applyFont($('font-select').value, parseInt($('font-size-slider').value));
});

$('font-size-slider').addEventListener('input', () => {
  const size = parseInt($('font-size-slider').value);
  $('font-size-display').textContent = size + 'px';
  applyFont($('font-select').value, size);
});

$('font-modal').addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    e.preventDefault();
    e.stopPropagation();
    hideFontModal();
  }
});

// ═══════════════════════════════════════════
// FILE OPERATIONS
// ═══════════════════════════════════════════

function getLocationMeta() {
  // Build YAML front-matter for current writing context
  if (!APP.currentLocation || APP.state !== 'landed') return null;
  const loc = APP.currentLocation;
  const star = APP.currentStar;
  const lines = [
    '---',
    `location: "${loc.name || loc.catalogId}"`,
    `type: "${loc.type.name}"`,
    `star: "${star ? star.type.name : 'unknown'}"`,
    `temperature: "${loc.temperature}"`,
    `atmosphere: "${loc.atmosphere}"`,
    `surface: "${loc.surface}"`,
    `coordinates: [${Math.round(APP.camera.x)}, ${Math.round(APP.camera.y)}]`,
    `date: "${new Date().toISOString().slice(0, 10)}"`,
    '---',
    '',
  ];
  return lines.join('\n');
}

async function quickSave() {
  // Write directly to existing handle — no picker
  const text = $('editor-textarea').value;
  if (!text.trim()) return false;
  try {
    const writable = await APP.fileHandle.createWritable();
    await writable.write(text);
    await writable.close();
    return true;
  } catch (e) {
    // Handle is stale (file deleted, moved, or permission lost)
    console.warn('File handle stale, falling back to Save As:', e.message);
    APP.fileHandle = null;
    return false;
  }
}

function suggestFilename() {
  if (APP.fileName) return APP.fileName;
  if (APP.currentLocation && APP.currentLocation.name) {
    return APP.currentLocation.name.toLowerCase().replace(/[^a-z0-9]+/g, '-') + '.md';
  }
  return 'untitled.md';
}

async function saveFile() {
  const text = $('editor-textarea').value;
  if (!text.trim()) return;

  try {
    if (APP.fileHandle && 'showSaveFilePicker' in window) {
      // Quick save to existing handle
      const ok = await quickSave();
      if (ok) {
        markClean();
        showSaveFlash('saved');
        updateLogbookFileAssoc();
        return;
      }
      // Fell through — handle was stale, do Save As
    }
    // No handle yet or not supported — full Save As
    await saveFileAs();
  } catch (e) {
    if (e.name !== 'AbortError') console.error(e);
  }
}

async function saveFileAs() {
  const text = $('editor-textarea').value;
  if (!text.trim()) return;

  try {
    if ('showSaveFilePicker' in window) {
      const handle = await window.showSaveFilePicker({
        suggestedName: suggestFilename(),
        types: [
          { description: 'Markdown', accept: { 'text/markdown': ['.md'] } },
          { description: 'Text', accept: { 'text/plain': ['.txt'] } },
        ]
      });
      const writable = await handle.createWritable();
      await writable.write(text);
      await writable.close();
      APP.fileHandle = handle;
      APP.fileName = handle.name;
    } else {
      // Fallback: download
      const blob = new Blob([text], { type: 'text/markdown' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = suggestFilename();
      a.click();
      URL.revokeObjectURL(url);
      APP.fileName = a.download;
    }
    markClean();
    showSaveFlash('saved');
    updateHudFilename();
    updateLogbookFileAssoc();
  } catch (e) {
    if (e.name !== 'AbortError') console.error(e);
  }
}

function updateLogbookFileAssoc() {
  // Track in transit files
  if ((APP.state === 'starfield' || APP.editorActive) && APP.fileName) {
    if (!APP.logbook.transitFiles.some(f => f.name === APP.fileName)) {
      APP.logbook.transitFiles.push({
        name: APP.fileName,
        coords: { x: Math.round(APP.camera.x), y: Math.round(APP.camera.y) },
        date: Date.now()
      });
    }
  }
  // Track on landed locations
  if (APP.state === 'landed' && APP.currentSystem && APP.currentLocation && APP.fileName) {
    const sysKey = APP.currentSystem.key;
    if (APP.logbook.visited[sysKey]) {
      const idx = APP.currentSystem.locations.indexOf(APP.currentLocation);
      if (idx >= 0) {
        APP.logbook.visited[sysKey].locations[idx].file = APP.fileName;
        APP.currentLocation.file = APP.fileName;
      }
    }
  }
}

async function openFile() {
  // Guard against unsaved changes
  if (APP.dirty) {
    if (!confirm('You have unsaved changes. Open a different file?')) return;
  }

  try {
    if ('showOpenFilePicker' in window) {
      const [handle] = await window.showOpenFilePicker({
        types: [
          { description: 'Text files', accept: { 'text/*': ['.md', '.txt'] } }
        ]
      });
      const file = await handle.getFile();
      const text = await file.text();
      $('editor-textarea').value = text;
      APP.fileHandle = handle;
      APP.fileName = handle.name;
    } else {
      // Fallback: file input
      await new Promise((resolve) => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.txt,.md';
        input.onchange = async (e) => {
          const file = e.target.files[0];
          if (file) {
            const text = await file.text();
            $('editor-textarea').value = text;
            APP.fileName = file.name;
            APP.fileHandle = null;
          }
          resolve();
        };
        input.click();
      });
    }

    APP.lastSavedText = $('editor-textarea').value;
    APP.dirty = false;
    $('dirty-dot').classList.remove('visible');
    updateHudFilename();
    $('editor-textarea').dispatchEvent(new Event('input'));
    IDB.del('autosave').catch(() => {});

    // Activate editor if in starfield
    if (APP.state === 'starfield' && !APP.editorActive) {
      activateStarfieldEditor();
    }
  } catch (e) {
    if (e.name !== 'AbortError') console.error(e);
  }
}

async function newFile() {
  if (APP.dirty) {
    if (!confirm('You have unsaved changes. Start a new file?')) return;
  }
  $('editor-textarea').value = '';
  APP.fileHandle = null;
  APP.fileName = null;
  APP.lastSavedText = '';
  APP.dirty = false;
  $('dirty-dot').classList.remove('visible');
  updateHudFilename();
  $('hud-wordcount').textContent = '0 words';
  IDB.del('autosave').catch(() => {});
}

function insertMetadata() {
  const meta = getLocationMeta();
  if (!meta) return; // only works when landed
  const ta = $('editor-textarea');
  const pos = ta.selectionStart;
  const text = ta.value;
  // Insert at the very top if cursor is at start, otherwise at cursor
  const insertPos = pos === 0 ? 0 : pos;
  ta.value = text.slice(0, insertPos) + meta + text.slice(insertPos);
  ta.selectionStart = ta.selectionEnd = insertPos + meta.length;
  ta.dispatchEvent(new Event('input'));
  ta.focus();
}

// ═══════════════════════════════════════════
// AUTO-SAVE & CRASH RECOVERY
// ═══════════════════════════════════════════
const AUTOSAVE_INTERVAL_MS = 30000; // 30 seconds
const RECOVERY_MAX_AGE_MS = 7 * 24 * 60 * 60 * 1000; // 7 days

function buildAutoSavePayload() {
  const text = $('editor-textarea').value;
  if (!text.trim()) return null;
  return {
    text,
    cursorPos: $('editor-textarea').selectionStart,
    scrollTop: $('editor-textarea').scrollTop,
    fileName: APP.fileName,
    locationSeed: APP.currentLocation ? APP.currentLocation.seed : null,
    locationName: APP.currentLocation ? (APP.currentLocation.name || APP.currentLocation.catalogId) : null,
    appState: APP.state,
    cameraX: APP.camera.x,
    cameraY: APP.camera.y,
    timestamp: Date.now(),
  };
}

function startAutoSave() {
  if (APP.autoSaveInterval) return;
  APP.autoSaveInterval = setInterval(async () => {
    if (!APP.dirty) return;
    const payload = buildAutoSavePayload();
    if (payload) {
      try { await IDB.set('autosave', payload); }
      catch (e) { console.warn('Auto-save failed:', e); }
    }
  }, AUTOSAVE_INTERVAL_MS);
}

async function checkRecovery() {
  try {
    const data = await IDB.get('autosave');
    if (!data || !data.text || !data.text.trim()) return;

    // Purge stale recovery data
    if (Date.now() - data.timestamp > RECOVERY_MAX_AGE_MS) {
      await IDB.del('autosave');
      return;
    }

    // Show recovery modal
    const preview = data.text.slice(0, 200) + (data.text.length > 200 ? '…' : '');
    $('recovery-preview').textContent = preview;

    const age = Date.now() - data.timestamp;
    const ageStr = age < 60000 ? 'moments ago' :
                   age < 3600000 ? `${Math.round(age / 60000)} min ago` :
                   age < 86400000 ? `${Math.round(age / 3600000)} hours ago` :
                   `${Math.round(age / 86400000)} days ago`;
    const where = data.locationName || 'in transit';
    $('recovery-meta').textContent = `${data.fileName || 'untitled'} · ${where} · ${ageStr} · ${data.text.split(/\s+/).length} words`;

    $('recovery-modal').classList.add('visible');

    return new Promise((resolve) => {
      function restore() {
        $('editor-textarea').value = data.text;
        APP.fileName = data.fileName;
        APP.lastSavedText = ''; // Not yet saved to disk, so still dirty relative to disk
        APP.dirty = true;
        $('dirty-dot').classList.add('visible');
        updateHudFilename();
        $('editor-textarea').dispatchEvent(new Event('input'));
        // Restore cursor and scroll
        try {
          $('editor-textarea').selectionStart = $('editor-textarea').selectionEnd = data.cursorPos || 0;
          $('editor-textarea').scrollTop = data.scrollTop || 0;
        } catch (e) {}
        // Restore camera position
        if (data.cameraX != null) { APP.camera.x = data.cameraX; APP.camera.y = data.cameraY; }
        cleanup();
        resolve();
      }
      function discard() {
        IDB.del('autosave').catch(() => {});
        cleanup();
        resolve();
      }
      function cleanup() {
        $('recovery-modal').classList.remove('visible');
        $('btn-recover').removeEventListener('click', restore);
        $('btn-discard').removeEventListener('click', discard);
      }
      $('btn-recover').addEventListener('click', restore);
      $('btn-discard').addEventListener('click', discard);
    });
  } catch (e) {
    console.warn('Recovery check failed:', e);
  }
}

// ─── beforeunload ───
window.addEventListener('beforeunload', (e) => {
  if (APP.dirty) {
    e.preventDefault();
    e.returnValue = '';
  }
});

// ═══════════════════════════════════════════
// LOGBOOK
// ═══════════════════════════════════════════
function toggleLogbook() {
  if ($('logbook').classList.contains('visible')) {
    $('logbook').classList.remove('visible');
  } else {
    $('logbook').classList.add('visible');
    renderLogbook();
  }
}

function renderLogbook() {
  const entries = $('logbook-entries');
  entries.innerHTML = '';

  const visited = APP.logbook.visited;
  const keys = Object.keys(visited);

  if (keys.length === 0) {
    entries.innerHTML = '<div style="color:rgba(200,210,220,0.3);font-style:italic;font-size:14px;">No systems visited yet. Fly toward a star and click to approach.</div>';
    logCtx.clearRect(0, 0, APP.width, APP.height);
    logCtx.fillStyle = '#050510';
    logCtx.fillRect(0, 0, APP.width, APP.height);
    APP._logbookNodes = [];
    return;
  }

  // Draw constellation on canvas
  logCtx.clearRect(0, 0, APP.width, APP.height);
  logCtx.fillStyle = '#050510';
  logCtx.fillRect(0, 0, APP.width, APP.height);

  // BG stars
  const rng = mulberry32(7654);
  for (let i = 0; i < 200; i++) {
    logCtx.fillStyle = `rgba(200,210,220,${0.1 + rng() * 0.3})`;
    logCtx.beginPath();
    logCtx.arc(rng() * APP.width, rng() * APP.height, 0.3 + rng() * 1, 0, Math.PI * 2);
    logCtx.fill();
  }

  const nodePositions = [];
  keys.forEach((key, i) => {
    const sys = visited[key];
    const star = sys.star;
    // Position nodes in a loose constellation layout
    const angle = (i / keys.length) * Math.PI * 2 + 0.5;
    const radius = 100 + (i % 3) * 80;
    const nx = (APP.width - 320) / 2 + Math.cos(angle) * radius;
    const ny = APP.height / 2 + Math.sin(angle) * radius;
    nodePositions.push({ x: nx, y: ny, key, sys });

    // Draw connections
    if (i > 0) {
      const prev = nodePositions[i - 1];
      logCtx.strokeStyle = 'rgba(200,210,220,0.08)';
      logCtx.lineWidth = 1;
      logCtx.setLineDash([4, 8]);
      logCtx.beginPath();
      logCtx.moveTo(prev.x, prev.y);
      logCtx.lineTo(nx, ny);
      logCtx.stroke();
      logCtx.setLineDash([]);
    }

    // Draw node
    logCtx.fillStyle = star.type.color;
    logCtx.globalAlpha = 0.6;
    const grd = logCtx.createRadialGradient(nx, ny, 0, nx, ny, 20);
    grd.addColorStop(0, star.type.glow);
    grd.addColorStop(1, 'transparent');
    logCtx.fillStyle = grd;
    logCtx.fillRect(nx - 20, ny - 20, 40, 40);

    logCtx.globalAlpha = 1;
    logCtx.fillStyle = star.type.color;
    logCtx.beginPath();
    logCtx.arc(nx, ny, 5, 0, Math.PI * 2);
    logCtx.fill();

    // Label
    logCtx.fillStyle = 'rgba(200,210,220,0.5)';
    logCtx.font = '10px "JetBrains Mono", monospace';
    logCtx.textAlign = 'center';
    logCtx.fillText(star.type.name, nx, ny + 18);

    // Add sidebar entries
    sys.locations.forEach((loc, locIdx) => {
      const entry = document.createElement('div');
      entry.className = 'logbook-entry';
      const displayName = loc.name || loc.catalogId;
      entry.innerHTML = `
        <div class="logbook-entry-name" style="display:flex;align-items:center;justify-content:space-between;">
          <span>
            <span class="logbook-entry-swatch" style="background:${loc.palette.groundDay}"></span>
            <span class="entry-name-text">${displayName}</span>
          </span>
          <button class="hud-btn rename-btn" style="padding:2px 8px;font-size:9px;letter-spacing:0.1em;">rename</button>
        </div>
        <div class="logbook-entry-type">${loc.type}${loc.file ? ' · ' + loc.file : ''}</div>
      `;
      // Rename handler
      entry.querySelector('.rename-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        const nameSpan = entry.querySelector('.entry-name-text');
        const input = document.createElement('input');
        input.type = 'text';
        input.value = displayName;
        input.style.cssText = 'background:transparent;border:none;border-bottom:1px solid rgba(200,210,220,0.3);color:var(--text-color);font-family:var(--editor-font);font-size:15px;outline:none;width:140px;';
        nameSpan.replaceWith(input);
        input.focus();
        input.select();
        function commitRename() {
          const newName = input.value.trim() || displayName;
          loc.name = newName;
          // Also update the live system if it matches
          if (APP.currentSystem && APP.currentSystem.key === key) {
            const liveLoc = APP.currentSystem.locations[locIdx];
            if (liveLoc) liveLoc.name = newName;
          }
          const span = document.createElement('span');
          span.className = 'entry-name-text';
          span.textContent = newName;
          input.replaceWith(span);
        }
        input.addEventListener('keydown', (ke) => {
          if (ke.key === 'Enter') commitRename();
          if (ke.key === 'Escape') { input.replaceWith(nameSpan); }
          ke.stopPropagation();
        });
        input.addEventListener('blur', commitRename);
      });
      // Warp handler
      entry.addEventListener('click', () => {
        // Warp to this system
        APP.camera.x = star.x;
        APP.camera.y = star.y;
        $('logbook').classList.remove('visible');
        if (APP.state === 'starfield') {
          approachStar(star);
        }
      });
      entries.appendChild(entry);
    });
  });
  APP._logbookNodes = nodePositions;

  // Transit files section
  if (APP.logbook.transitFiles.length > 0) {
    const divider = document.createElement('div');
    divider.className = 'logbook-title';
    divider.style.marginTop = '24px';
    divider.style.fontSize = '14px';
    divider.textContent = 'Written in Transit';
    entries.appendChild(divider);

    APP.logbook.transitFiles.forEach(f => {
      const entry = document.createElement('div');
      entry.className = 'logbook-entry';
      entry.innerHTML = `
        <div class="logbook-entry-name">
          <span class="logbook-entry-swatch" style="background:rgba(200,210,220,0.3)"></span>
          ${f.name}
        </div>
        <div class="logbook-entry-type">${f.coords.x} · ${f.coords.y}</div>
      `;
      entry.addEventListener('click', () => {
        APP.camera.x = f.coords.x;
        APP.camera.y = f.coords.y;
        $('logbook').classList.remove('visible');
      });
      entries.appendChild(entry);
    });
  }
}

// Logbook canvas click handler — warp to clicked constellation node
$('logbook-canvas').addEventListener('click', (e) => {
  if (!APP._logbookNodes || !APP._logbookNodes.length) return;
  const rect = logCanvas.getBoundingClientRect();
  const mx = e.clientX - rect.left, my = e.clientY - rect.top;
  for (const node of APP._logbookNodes) {
    const d = Math.sqrt((node.x - mx) ** 2 + (node.y - my) ** 2);
    if (d < 20) {
      APP.camera.x = node.sys.star.x;
      APP.camera.y = node.sys.star.y;
      $('logbook').classList.remove('visible');
      if (APP.state === 'starfield') {
        approachStar(node.sys.star);
      }
      return;
    }
  }
});

// ═══════════════════════════════════════════
// MAIN LOOP
// ═══════════════════════════════════════════
function update() {
  // Movement (only in starfield)
  if (APP.state === 'starfield' && !APP.editorActive && document.activeElement !== $('editor-textarea')) {
    const accel = 0.3;
    const maxSpeed = 5;
    const friction = 0.96;

    if (APP.keys['w'] || APP.keys['arrowup']) APP.velocity.y -= accel;
    if (APP.keys['s'] || APP.keys['arrowdown']) APP.velocity.y += accel;
    if (APP.keys['a'] || APP.keys['arrowleft']) APP.velocity.x -= accel;
    if (APP.keys['d'] || APP.keys['arrowright']) APP.velocity.x += accel;

    APP.velocity.x = Math.max(-maxSpeed, Math.min(maxSpeed, APP.velocity.x)) * friction;
    APP.velocity.y = Math.max(-maxSpeed, Math.min(maxSpeed, APP.velocity.y)) * friction;

    APP.camera.x += APP.velocity.x;
    APP.camera.y += APP.velocity.y;
  }

  // Coords display (only update when changed)
  const coordStr = `${Math.round(APP.camera.x)} · ${Math.round(APP.camera.y)}`;
  if (APP._lastCoordStr !== coordStr) {
    $('hud-coords').textContent = coordStr;
    APP._lastCoordStr = coordStr;
  }

  // Day/night cycle
  // Day/night cycle
  if (APP.state === 'landed' && APP.dayPinned === null) {
    // Eternal Twilight modifier: oscillate slowly within golden hour zone
    if (APP.currentLocation && APP.currentLocation.palette.modifier &&
        APP.currentLocation.palette.modifier.name === 'Eternal Twilight') {
      // Gently oscillate between 0.82 and 0.92 (perpetual sunset)
      const t = Date.now() * 0.00001;
      APP.dayProgress = 0.82 + Math.sin(t) * 0.05;
    } else {
      APP.dayProgress = (APP.dayProgress + 0.00003) % 1;
    }
  }
  // Update landscapes
  if (APP.state === 'landed' && APP.currentLocation && APP.currentSystem) {
    APP._landFrame = (APP._landFrame || 0) + 1;
    
    // Update 3D every frame
    if (APP.webglActive) {
      updateLandscape3D();
    }
    
    // Update CSS fallback every 6 frames
    if (!APP.webglActive && APP._landFrame % 6 === 0) {
      updateLandscapeLighting();
    }
  }

  // Update frost panel color for day/night (throttled — every 8 frames)
  APP._frostFrame = (APP._frostFrame || 0) + 1;
  if (APP._frostFrame % 8 === 0) {
  if (APP.state === 'landed' && APP.currentLocation) {
    const bright = Math.sin(APP.dayProgress * Math.PI);
    const nightFactor = 1 - bright;
    const p = APP.currentLocation.palette;
    const nsFrost = p.nightFrost || [14, 14, 22];
    const nsGlow = p.nightGlow || [220, 25, 30];
    
    // Night: use curated nightFrost tint; Day: slightly warmer dark glass tinted by palette
    const skyZ = p.skyDayZenith || [p.hue, p.sat, 55];
    // Day glass stays DARK — tinted subtly by world palette, not washed out to white
    // Convert sky zenith hue to a subtle warm-dark tint (range ~18-40)
    const dayR = 24 + Math.round(Math.cos(skyZ[0] * Math.PI / 180) * 8);
    const dayG = 22 + Math.round(Math.cos((skyZ[0] + 120) * Math.PI / 180) * 6);
    const dayB = 28 + Math.round(Math.cos((skyZ[0] + 240) * Math.PI / 180) * 8);
    
    // Night frost tint from signature
    const nightR = nsFrost[0], nightG = nsFrost[1], nightB = nsFrost[2];
    
    // Golden hour shifts frost panel warmer
    const dayP = APP.dayProgress;
    let goldenWarm = 0;
    if ((dayP > 0.04 && dayP < 0.22) || (dayP > 0.78 && dayP < 0.96)) {
      goldenWarm = dayP < 0.5 ?
        Math.max(0, Math.min(1, dayP < 0.12 ? (dayP - 0.04) / 0.08 : (0.22 - dayP) / 0.1)) :
        Math.max(0, Math.min(1, dayP < 0.88 ? (dayP - 0.78) / 0.1 : (0.96 - dayP) / 0.08));
    }
    const warmR = goldenWarm * 18, warmG = goldenWarm * -4, warmB = goldenWarm * -14;
    const fr = Math.round(Math.min(255, nightR + (dayR - nightR) * bright + warmR));
    const fg = Math.round(Math.max(0, nightG + (dayG - nightG) * bright + warmG));
    const fb = Math.round(Math.max(0, nightB + (dayB - nightB) * bright + warmB));
    document.documentElement.style.setProperty('--frost-r', fr);
    document.documentElement.style.setProperty('--frost-g', fg);
    document.documentElement.style.setProperty('--frost-b', fb);
    
    // Dynamic frost opacity — lower during day so bright world bleeds through dark glass
    // Night: full opacity (0.78). Day: reduced (0.50) for translucent world-tinted glass.
    const userOpacity = parseFloat($('opacity-slider').value);
    const dayOpacityScale = 0.65 + nightFactor * 0.35; // 0.65 at noon, 1.0 at midnight
    const dynamicOpacity = userOpacity * dayOpacityScale;
    document.documentElement.style.setProperty('--frost-opacity', dynamicOpacity.toFixed(3));
    
    // Dynamic blur — less blur during day so terrain forms are visible through glass
    const dayBlurScale = 0.55 + nightFactor * 0.45; // 0.55 at noon, 1.0 at midnight
    const baseBlur = 24 + Math.max(0, (userOpacity - 0.4) * 40);
    document.documentElement.style.setProperty('--frost-blur', Math.round(baseBlur * dayBlurScale) + 'px');
    
    // Brighter panel border during day for definition against bright world
    const borderAlpha = 0.06 + bright * 0.10;
    const frostBg = $('frost-bg');
    if (frostBg) {
      frostBg.style.borderColor = `rgba(200,210,220,${borderAlpha.toFixed(3)})`;
      frostBg.style.borderTopColor = `rgba(200,210,220,${(borderAlpha * 1.6).toFixed(3)})`;
    }
    
    // Dynamic scrim — lighter during day so bright world shows through dark glass
    const scrim = $('editor-scrim');
    if (scrim && scrim.classList.contains('visible') && !APP.focusMode) {
      const scrimAlpha = 0.10 + nightFactor * 0.25; // 0.10 at noon, 0.35 at midnight
      scrim.style.background = `rgba(0,0,0,${scrimAlpha.toFixed(3)})`;
    }
    // Accent color from curated palette
    document.documentElement.style.setProperty('--accent', p.accent || 'rgba(140,160,200,0.6)');
    // Night signature glow tints the inner vignette — more visible during day for warm depth
    const nightGlowStr = p.nightSignature ? p.nightSignature.glowIntensity * 0.15 : 0;
    const glowAlpha = 0.03 + bright * 0.08 + nightFactor * nightGlowStr;
    const glowL = Math.min(60, nsGlow[2] + bright * 30);
    document.documentElement.style.setProperty('--accent-glow', `hsla(${nsGlow[0]},${nsGlow[1]}%,${glowL}%,${glowAlpha})`);
  } else {
    document.documentElement.style.setProperty('--frost-r', 15);
    document.documentElement.style.setProperty('--frost-g', 15);
    document.documentElement.style.setProperty('--frost-b', 25);
  }

  // Text color — manual override or auto from day/night
  function applyTextColor(mode) {
    if (mode === 'light') {
      document.documentElement.style.setProperty('--text-color', '#e8e4df');
      document.documentElement.style.setProperty('--text-shadow', '0 1px 3px rgba(0,0,0,0.5)');
    } else if (mode === 'dark') {
      document.documentElement.style.setProperty('--text-color', '#2a2520');
      document.documentElement.style.setProperty('--text-shadow', '0 1px 3px rgba(255,255,255,0.2)');
    }
  }
  if (APP.textMode === 'auto') {
    // Glass is always dark — light text is always readable
    applyTextColor('light');
  } else {
    applyTextColor(APP.textMode);
  }
  } // end throttled frost/text update

  // Render
  if (APP.state === 'starfield') {
    renderStarfield();
  } else if (APP.state === 'system') {
    renderStarfield(); // still visible behind system view
    renderSystemView();
  }
  // landed state: skip starfield render entirely — landscape covers viewport

  requestAnimationFrame(update);
}

// Scanner readout on star proximity
let lastScannedStar = null;
let lastScannedSystem = null;
setInterval(() => {
  if (APP.state !== 'starfield') return;
  const stars = APP._cachedVisibleStars || [];
  const cx = APP.camera.x, cy = APP.camera.y;
  let nearest = null, nearDist = 200;

  for (const s of stars) {
    const d = Math.sqrt((s.x - cx) ** 2 + (s.y - cy) ** 2);
    if (d < nearDist) {
      nearDist = d;
      nearest = s;
    }
  }

  if (nearest && nearest !== lastScannedStar) {
    lastScannedStar = nearest;
    lastScannedSystem = null; // invalidate cache
    const rng = mulberry32(nearest.seed + 7777);
    const [minP, maxP] = nearest.type.planets;
    const numLoc = minP + Math.floor(rng() * (maxP - minP + 1));

    if (nearDist < 80) {
      // Close range: reveal individual location types
      if (!lastScannedSystem) lastScannedSystem = generateSystem(nearest);
      const sys = lastScannedSystem;
      let lines = `<span class="scanner-line">${nearest.type.name}</span>
         <span class="scanner-line" style="animation-delay:0.2s">${numLoc} objects detected</span>`;
      sys.locations.forEach((loc, i) => {
        const delay = 0.5 + i * 0.35;
        lines += `<span class="scanner-line" style="animation-delay:${delay}s;font-size:11px;opacity:0.65">${loc.scannerDesc}</span>`;
      });
      lines += `<span class="scanner-line" style="animation-delay:${0.5 + sys.locations.length * 0.35}s;font-size:10px;opacity:0.4">click to approach</span>`;
      $('scanner-readout').innerHTML = lines;
      $('scanner-readout').style.opacity = '1';
    } else if (nearDist < 150) {
      // Mid range: count only
      $('scanner-readout').innerHTML =
        `<span class="scanner-line">${nearest.type.name}</span>
         <span class="scanner-line" style="animation-delay:0.3s">${numLoc} objects detected</span>`;
      $('scanner-readout').style.opacity = '1';
    } else if (nearDist < 200) {
      // Long range: star type only
      $('scanner-readout').innerHTML =
        `<span class="scanner-line">${nearest.type.name}</span>`;
      $('scanner-readout').style.opacity = '1';
    }
  } else if (!nearest) {
    lastScannedStar = null;
    lastScannedSystem = null;
    $('scanner-readout').style.opacity = '0';
  }
}, 500);

// ─── Load persisted state ───
try {
  const saved = localStorage.getItem('voyage-writer-state');
  if (saved) {
    const data = JSON.parse(saved);
    if (data.camera) { APP.camera.x = data.camera.x; APP.camera.y = data.camera.y; }
    if (data.logbook) APP.logbook = data.logbook;
    if (data.editorFont) APP.editorFont = data.editorFont;
    if (data.editorFontSize) APP.editorFontSize = data.editorFontSize;
    // Apply saved font
    if (data.editorFont || data.editorFontSize) {
      applyFont(APP.editorFont, APP.editorFontSize);
    }
  }
} catch(e) {}

// ─── Save state periodically ───
setInterval(() => {
  try {
    localStorage.setItem('voyage-writer-state', JSON.stringify({
      camera: APP.camera,
      logbook: APP.logbook,
    }));
  } catch(e) {}
}, 5000);

// ─── Initialize ───
APP._cachedVisibleStars = [];

// Check for crash recovery, then start
(async function init() {
  await checkRecovery();
  startAutoSave();
  // If recovery restored text, activate the editor
  if ($('editor-textarea').value.trim() && APP.state === 'starfield') {
    activateStarfieldEditor();
  }
  update();
})();
</script>
</body>
</html>
